<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"dfault0.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing摘要：123456789Existing binary analysis based approaches only work on firmware, which is less accessible except for those equip">
<meta property="og:type" content="article">
<meta property="og:title" content="模糊测试相关论文笔记">
<meta property="og:url" content="http://dfault0.github.io/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Dfault0&#39;s blog">
<meta property="og:description" content="1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing摘要：123456789Existing binary analysis based approaches only work on firmware, which is less accessible except for those equip">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210729161035679.png">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210730110451403.png">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210730111053438.png">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210730201732830.png">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210730204946092.png">
<meta property="og:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210730204917972.png">
<meta property="article:published_time" content="2021-07-25T10:32:14.000Z">
<meta property="article:modified_time" content="2022-05-14T06:05:03.443Z">
<meta property="article:author" content="Dfault0">
<meta property="article:tag" content="Fuzzing">
<meta property="article:tag" content="paper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/fourth/AppData/Roaming/Typora/typora-user-images/image-20210729161035679.png">


<link rel="canonical" href="http://dfault0.github.io/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://dfault0.github.io/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/","path":"2021/07/25/模糊测试相关论文笔记/","title":"模糊测试相关论文笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>模糊测试相关论文笔记 | Dfault0's blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dfault0's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing"><span class="nav-number">1.</span> <span class="nav-text">1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">摘要：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">主要思想：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">主要贡献：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number">1.4.</span> <span class="nav-text">所面临的挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.5.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">1.6.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-policy"><span class="nav-number">1.7.</span> <span class="nav-text">fuzzing policy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%99%90%EF%BC%9A"><span class="nav-number">1.8.</span> <span class="nav-text">局限：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices"><span class="nav-number">2.</span> <span class="nav-text">2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">2.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="nav-number">2.2.</span> <span class="nav-text">主要思想：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%81%9A%E5%87%BA%E7%9A%84%E8%B4%A1%E7%8C%AE%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">本文做出的贡献：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fuzzing-Trigger-Identification%EF%BC%9A"><span class="nav-number">2.4.</span> <span class="nav-text">Fuzzing Trigger Identification：</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dfault0</p>
  <div class="site-description" itemprop="description">I CAN</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://dfault0.github.io/2021/07/25/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dfault0">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dfault0's blog">
      <meta itemprop="description" content="I CAN">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="模糊测试相关论文笔记 | Dfault0's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          模糊测试相关论文笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 18:32:14" itemprop="dateCreated datePublished" datetime="2021-07-25T18:32:14+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-14 14:05:03" itemprop="dateModified" datetime="2022-05-14T14:05:03+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Fuzzing/" itemprop="url" rel="index"><span itemprop="name">Fuzzing</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing"><a href="#1-IOTFUZZER-Discovering-Memory-Corruptions-in-IoT-Through-App-based-Fuzzing" class="headerlink" title="1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing"></a>1.IOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Existing binary analysis based approaches only work on firmware, which is less accessible except for those equipped with special tools for extracting the code from the device.</span><br><span class="line">现有的二进制分析的方法只能在固件上面工作，但是除了配备特殊工具的设备外，固件的获取具有一定的难度。</span><br><span class="line"> IOTFUZZER：自动fuzzing框架，目的是查找物联网设备中的内存损坏漏洞（不需要获取其固件镜像）</span><br><span class="line"> </span><br><span class="line">The key idea ：most IoT devices are controlled through their official mobile apps, and such an app often contains rich information about the protocol it uses to communicate with its device. </span><br><span class="line">主要思想：大多数的物联网设备是由APP控制的，这些APP中有与其交互的各种协议</span><br><span class="line"></span><br><span class="line"> Therefore, by identifying and reusing program-specific logic (e.g., encryption) to mutate the test case (particularly message fields), we are able to effectively probe IoT targets without relying on any knowledge about its protocol specifications. </span><br><span class="line"> 通过识别和重用APP特定的逻辑来变异测试用例，我们就可以有效得探测物联网目标，而不依赖于任何关于其协议规范的知识</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="主要思想："><a href="#主要思想：" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A unique property of IOTFUZZER is that it runs a protocol-guided fuzz and utilizes the information carried by the IoT app without reverse-engineering the protocol or explicit recovering such knowledge from the app, as prior approaches [20], [10] do. </span><br><span class="line">协议引导并且利用APP携带的信息</span><br><span class="line"></span><br><span class="line">it performs a dynamic analysis to identify the content inside the app that forms the messages to be delivered to the target device, and automatically mutates such content during the runtime so as to use the app’s program logics to produce meaningful test cases for probing the target firmware.</span><br><span class="line">利用动态执行来识别程序内部传递到目标设备的内容，并且自动变异这些内容</span><br></pre></td></tr></table></figure>

<h2 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	•New framework. We present the first firmware-free fuzzing framework, IOTFUZZER, for security analysis of IoT devices. By utilizing the information carried by official mobile apps and their program logics, IOTFUZZER could automatically detect memory corruption vulnerabilities in IoT devices without direct access to the firmware.</span><br><span class="line">	• New techniques. We developed a set of new techniques to enable an automatic, blackbox IoT fuzzer, which includes protocol-guided fuzzing without protocol specifications, in-context cryptographic and networking function replay for message generation and delivery, and a lightweight mechanism to remotely monitor the target IoT device’s status.</span><br><span class="line">	• Implementation and findings. We implemented a full-featured prototype of IOTFUZZER and evaluated it</span><br><span class="line">over 17 real-world IoT devices. Our study discovered 15 security-critical memory vulnerabilities, with 8 of them never reported before.</span><br><span class="line">	新框架：利用官方APP携带的信息和逻辑，IOTFUZZER自动检测内存损坏漏洞，而不需要获取固件</span><br><span class="line">	新技术：自动黑盒物联网fuzz工具，协议指导，消息生成和传递上下文加密和网络功能重放以及远程监控，轻量级</span><br><span class="line">	评估	</span><br></pre></td></tr></table></figure>

<h2 id="所面临的挑战"><a href="#所面临的挑战" class="headerlink" title="所面临的挑战"></a>所面临的挑战</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Challenges. Therefore, in order to generate fuzzing messages without making assumptions on protocol formats, we need to solve the following challenges.</span><br><span class="line">	• Challenge 1: Mutating fields in networking messages. Therefore, we need to automatically recognize and fuzz the protocol fields for unknown protocols.</span><br><span class="line">	我们需要自动识别和协议的字段信息等。</span><br><span class="line">	• Challenge 2: Handling encrypted messages. Thus, we need a lightweight and flexible</span><br><span class="line">solution to reuse the message encryption functions in the app.</span><br><span class="line">	需要一个轻量级的解决方法来重用在APP里面的加密函数</span><br><span class="line">	• Challenge 3: Monitoring crashes. In order to identify the system crash and the corresponding probing message that triggers the crash, we need to design an effective mechanism to remotely and automatically monitor the device status.</span><br><span class="line">	为了检测崩溃，我们需要设计一个远程检测设备状态的机制</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	• Mutating protocol fields at data sources. Since protocol reverse engineering for unknown protocols is expensive, we can mutate the data which is used in the protocol message (note that most of these data</span><br><span class="line">will be strings) at their sources (e.g., at data definition sites or some data use sites such as when passed as arguments to functions). Then correspondingly, following the original program logic, these mutated strings will eventually become protocol fields.</span><br><span class="line">	在数据源处变异协议的各个字段</span><br><span class="line">	• Reusing cryptographic functions at runtime. Since we have modified the data sources at the very be-</span><br><span class="line">ginning, the normal program execution will help us complete the message encryption procedure and gen-</span><br><span class="line">erate ready-to-send messages. Therefore, we do not need to re-implement the complete encryption logic</span><br><span class="line">out-of-the-box.</span><br><span class="line">	在APP运行时重用APP里面的加密函数：就不用逆向出具体的加密函数了</span><br><span class="line">	• Detecting liveness with heartbeat mechanism. Though we cannot monitor the status of the running</span><br><span class="line">device locally, we can infer whether the program or the system is alive by sending a heartbeat message. The heartbeat message can be any messages that query the status of the device.</span><br><span class="line">	使用heartbeat机制来检测设备的状态：心跳机制是一种检测故障的机制</span><br><span class="line">	也就是向设备发送一个消息，如果设备正常，设备会怎么样，设备不正常又会怎么样。</span><br></pre></td></tr></table></figure>

<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210729161035679.png" alt="image-20210729161035679"></p>
<p>具体来说有四个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) UI analysis: In the first step, the goal is to analyze the code of IoT app and discover all UI components that will lead to the sending of networking messages. With such information, we can trigger message sending events by driving the corresponding UI controls. The purpose of UI analysis is to facilitate data-flow analysis and fuzzing in the following steps.</span><br><span class="line">2) Data-flow analysis: In order to identify the program elements (e.g., string constant, input from system APIs, etc.) whose values are related to the content of the message to be sent to the IoT device, we track the data flows from a set of selected elements (Section III-B) to find those indeed affecting some message fields. Those program elements are then used to mutate the content of the fields for fuzzing the device. Note that unlike taint-based fuzzers [7], [28] looking for the inputs of a program that can reach a known vulnerable function (e.g., printf) inside the program, our approach utilizes the data-flow analysis to determine how to command the IoT app to generate meaningful test outputs for fuzzing its remote target. </span><br><span class="line">3) Runtime mutation: Once the protocol fields are recognized, according to the fuzzing policy we defined, IOTFUZZER mutates the original fields (e.g., original string) at their first use sites. Then, the IoT app will follow its normal execution logic to compute and build the message and send it to IoT device with the mutated data.</span><br><span class="line">4) Response monitoring: The final step is to monitor the running status of IoT device remotely and capture the triggered crash. For TCP-based communication, the connection between the IoT app and the IoT device will be interrupted, which is easy to detect. For UDP-based communication, we use a heartbeat mechanism to detect the crashes occurred at uncertain times.</span><br><span class="line"></span><br><span class="line">1）UI分析：分析应用程序的代码，确定最终可以导致消息传递的UI组件。</span><br><span class="line">2）数据流分析：确定如何命令APP生成有意义的输入，追踪一组选定元素的数据流，以找到确实影响某些消息字段的元素（如，字符串常量、系统API输入等）</span><br><span class="line">3）运行时变异：根据定义的模糊策略，IOTFUZZER会在其首次使用的地方对原始字段进行变异。然后APP将遵循其正常执行逻辑来计算和构建消息，并将其与变异数据一起发送到物联网设备</span><br><span class="line">3）检测响应：基于UDP的通信，我们使用心跳机制来检测目标设备的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UI分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造call path：</span><br><span class="line">	使用Androguard 构建APP的调用图，从目标网络通信api开始，构建了到UI事件处理程序（event handlers）的反向代码路径。隐式控制流转换及其他事件驱动的调用，使用EdgeMiner 获取。代码路径的接收器是一组最终发送网络信息的时间处理器</span><br><span class="line">	</span><br><span class="line">activity转换图构造：</span><br><span class="line">	为了在fuzzing中到达特定的activity并且触发网络发送事件</span><br><span class="line">	使用Monkeyrunner 根据事件的执行顺序，通过简单的策略与每个activity中的UI元素进行交互。我们就可以获得一些列的UI event和触发他们的顺序。我们也记录了activity之间的转换。我们根据call path 过滤掉不会触发消息发送的event.转移图的节点是具有触发消息发送API的事件的activity，边是创建或恢复activity的事件</span><br></pre></td></tr></table></figure>

<p>数据流分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	为了在执行阶段变异协议的字段，我们需要识别协议的字段，和使用协议字段作为参数的函数。</span><br><span class="line">	command message通常是由硬编码字符串，用户输入或者系统API构成，我们使用TaintDroid的修改版本动态污点分析来识别他们。</span><br><span class="line">	在第一个使用消息的位置上对消息进行变异，就不用设置消息的格式了，所以记录了将受污染数据作为参数的函数，以便找到这个位置</span><br><span class="line">	我们不会将污点传播到加密函数，首先我们执行加密函数标识，然后将其中一个污点接收器设置为这些加密函数的参数</span><br><span class="line">	</span><br><span class="line">	污点来源：APP中的所有字符串、消息中常用的系统API（如WifiInfo.getMacAddress(),Location.getLatitude(), Location.getLongitude()),以及来自UI的用户输入(例如，EditText.getText()）</span><br><span class="line">	</span><br><span class="line">	污点传播：修改传播规则，扩大更多的污点源。使用字典来存储污点标签，每当创建一个新的标签时，就将其添加到字典中，并追踪这个标签的依赖关系。</span><br><span class="line">	污点接收器：这个是我们识别网络API和加密功能中使用的数据。</span><br><span class="line">	</span><br><span class="line">识别加密函数：</span><br><span class="line">	由于加密算法通常包含算术和位操作。我们选择包含这两种运算的函数，然后记录消息发送事件的执行轨迹，并基于相对于网络函数的位置来细化我们的候选函数。</span><br></pre></td></tr></table></figure>

<p>运行 时变异：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	动态hook之前记录的函数，并在运行时变异协议字段参数以生成探测消息</span><br><span class="line">好处：</span><br><span class="line">	1.协议字段在编码或者加密之前就可以模糊化</span><br><span class="line">	2.不需要逆向工程就可以知道未知协议领域的fuzzing</span><br><span class="line">	</span><br><span class="line">	使用Xposed框架来hook之前我们得到的函数（需要上下文相关：只有在特定的上下文环境下才会被触发）。之后原始数据就可以被变异之后的值代替传递到hook函数</span><br><span class="line">	注意：如果一个协议字段被传递给几个hook函数，他可能会被模糊化几次，并且同一个函数可能会被hook来模糊化几个协议字段。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730110451403.png" alt="image-20210730110451403"></p>
<p>因为我们每次变异协议的时候，不能变异所有的字段（容易被设备拒绝），只能变异字段的一个子集</p>
<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730111053438.png" alt="image-20210730111053438"></p>
<h2 id="fuzzing-policy"><a href="#fuzzing-policy" class="headerlink" title="fuzzing policy"></a>fuzzing policy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) Changing the lengths of strings for stack-based or heap-based overflow and out-of-bound access. In our implementation, IOTFUZZER duplicates the original strings several times (from dozens to thousands) or appends a variable number of character &quot;A&quot; to the original string to construct malformed messages.</span><br><span class="line">更改基于堆栈或者基于堆溢出和越界访问的字符串的长度</span><br><span class="line">2) Changing the integer , double or float values for integer overflow and out-of-bound access. Therefore, we mutate the original values into boundary cases and very-large values. Also, to trigger the cases of miscounting of boundary conditions, we also generate the off-by-one values for potential off-by-one error.</span><br><span class="line">更改整数，双精度，或者浮点数的值来造成整数溢出和越界访问。</span><br><span class="line">3) Changing the types, or providing empty values for misinterpretation of the value and uninitialized variable vulnerability. For example, if a string value is replaced with an integer value, a null pointer dereference may be triggered (as the case of Section IV -E1).In the implementation of IOTFUZZER, we mutate the types of Object at the Java level of Android apps</span><br><span class="line">更改类型，或者提供空值为了错误解释值和未初始化变量漏洞</span><br></pre></td></tr></table></figure>

<p>Response Monitoring</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	1) Expected Response. In this case, the probing messages are handled properly by the IoT device, and</span><br><span class="line">no exception occurs. Such a situation is out of our interests.</span><br><span class="line">	预期的响应：没有任何错误发生</span><br><span class="line">	2) Unexpected Response. The probing messages go beyond the intended logic of the program (e.g., reaching the input parameter boundary), and trigger untreated errors.</span><br><span class="line">	超出预期的响应：超出逻辑，触发未处理的错误</span><br><span class="line">	3) No Response. When no response is answered for a certain probing message, it may either trigger a DoS vulnerability, or it is just an error handled locally without replying, or running in a dead loop.</span><br><span class="line">	无响应：可能是DOS漏洞、在设备端处理了错误、或者是一个的死循环</span><br><span class="line">	4) Disconnection. For connection-oriented communication protocol like TCP , the network connection will be interrupted when a system crash is triggered by the probing message.</span><br><span class="line">	断开连接：由于发送的探测消息导致了设备系统崩溃</span><br></pre></td></tr></table></figure>

<p>碰撞检测机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP连接：</span><br><span class="line">	查看连接的状态推断设备系统是否崩溃</span><br><span class="line">UDP连接：</span><br><span class="line">	心跳机制，首先我们从APP中提取心跳信息，用以检测设备是否处于活动状态</span><br><span class="line">	在fuzzing过程中，每隔10个探测信息就插入一个心跳消息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某些已确认的崩溃是由相同的种子产生的变异消息所触发的，所以作者还记录了每个种子和变异消息对的关系。</span><br></pre></td></tr></table></figure>

<h2 id="局限："><a href="#局限：" class="headerlink" title="局限："></a>局限：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文主要的焦点是从移动应用的数据输入通道自动识别内存损坏漏洞，但是对于其他类型的漏洞无能为力。</span><br><span class="line">并不能给出产生内存损坏漏洞的根本原因和类型</span><br><span class="line">本文是没有考虑有云的情况的。可能云会发出警报。</span><br></pre></td></tr></table></figure>

<h1 id="2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices"><a href="#2-DIANE-Identifying-Fuzzing-Triggers-in-Apps-to-Generate-Under-constrained-Inputs-for-IoT-Devices" class="headerlink" title="2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices"></a>2. DIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">However , due to the difficulties in extracting and emulating custom firmware, black-box fuzzing is often the only viable analysis option. Unfortunately, this solution mostly produces invalid inputs, which are quickly discarded by the targeted IoT device and do not penetrate its code. </span><br><span class="line">固件获取困难，但是传统的黑盒测试会产生很多无意义的输入</span><br><span class="line">Another proposed approach is to leverage the companion app (i.e., the mobile app typically used to control an IoT device) to generate well-structured fuzzing inputs. Unfortunately, the existing solutions produce fuzzing inputs that are constrained by app-side validation code, thus significantly limiting the range of discovered vulnerabilities.</span><br><span class="line">从官方的APP端进行fuzzing，APP端对输入的验证会限制fuzzing的效率。</span><br><span class="line"></span><br><span class="line">Our key observation is that there exist functions inside the companion app that can be used to generate optimal (i.e., valid yet under-constrained) fuzzing inputs. fuzzing triggers：are executed before any data-transforming functions (e.g., network serialization), but after the input validation code. </span><br><span class="line">fuzzing triggers：在数据传输函数之前执行，在输入验证函数之后执行</span><br><span class="line">DIANE： a tool that combines static and dynamic analysis to find fuzzing triggers in Android companion apps, and then uses them to fuzz IoT devices automatically. </span><br><span class="line">DIANE：就是一个结合静态分析和动态分析来找到fuzzing triggers，以便于使用他们来进行fuzzing物联网设备的工具</span><br></pre></td></tr></table></figure>

<p>思考：万一验证端在设备上怎么办？</p>
<h2 id="主要思想：-1"><a href="#主要思想：-1" class="headerlink" title="主要思想："></a>主要思想：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i) fuzzing triggers identification, and </span><br><span class="line">ii) fuzzing. </span><br><span class="line">To do this, first, we automatically retrieve those functions within an app that send data to the IoT device.</span><br><span class="line">首先需要自动检测出APP中涉及到发送数据到物联网设备的函数</span><br><span class="line">Then, for each of these functions, we build an inter-procedural backward slice, which we dynamically analyze to ultimately identify fuzzing triggers. </span><br><span class="line">对于每一个上面检测到的函数，我们做一个过程向后切片，这样可以帮助我们动态识别fuzzing triggers</span><br><span class="line">Finally, we use dynamic instrumentation to repeatedly invoke these fuzzing triggers using different arguments. This generates a stream of network data that fuzzes the functionality of the IoT device, to ultimately spot vulnerabilities.</span><br><span class="line">最后我们使用动态的机制来使用不同的参数重复调用这些fuzzing trigger。这样会产生网络数据流（可以功能性得fuzzing物联网设备）</span><br></pre></td></tr></table></figure>

<h2 id="本文做出的贡献："><a href="#本文做出的贡献：" class="headerlink" title="本文做出的贡献："></a>本文做出的贡献：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• We propose an approach to identify fuzzing triggers, which are functions that, in the app’s control flow, are located between the app-side validation logic and the data-encoding functions. When executed, the identified fuzzing triggers produce valid yet under-constrained inputs, enabling effective fuzzing of IoT devices.</span><br><span class="line">可以识别出fuzzing trigger：在APP的控制流层面是位于APP内部逻辑验证和数据编码函数之间的</span><br><span class="line">• We leverage our approach to implement DIANE, an automated black-box fuzzer for IoT devices. </span><br><span class="line">是一个黑色测试工具，来测试物联网设备</span><br><span class="line">   • We evaluate our tool against 11 popular, real-world IoT devices. In our experiments, we show that by identifying fuzzing triggers and using them to generate inputs for the analyzed devices, we can effectively discover vulnerabilities. Specifically, we found 11 vulnerabilities in 5 different devices, 9 of which were previously unknown.</span><br><span class="line">   评估有效</span><br><span class="line">• We show that, for a majority of IoT devices and companion apps, identifying and leveraging fuzzing triggers is essential to generate bug-triggering inputs.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730201732830.png" alt="image-20210730201732830"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On the one hand, if the fuzzed function is too close to the UI, the fuzzing is ineffective due to app-side validation that might be present later in the execution. </span><br><span class="line">On the other hand, picking a function too close to the point where data is put onto the network might be ineffective.</span><br><span class="line"></span><br><span class="line">总之，fuzzing入口点（fuzzing trigger）不能离输入太近，也不能离发送数据太近。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">寻找fuzzing trigger： </span><br><span class="line"> 	i) static call-graph analysis, </span><br><span class="line"> 	ii) network traffic analysis, </span><br><span class="line"> 	iii) static data-flow analysis,and </span><br><span class="line"> 	iv) dynamic analysis of the function arguments.</span><br><span class="line"> 	</span><br><span class="line"> 	uses a “bottom-up” approach. </span><br><span class="line"> 	Specifically, we start from identifying low-level functions that potentially generate network traffic, </span><br><span class="line"> 	and then we progressively move “upward” in the app call-graph (i.e., from low-level networking functions to high-level UI-processing ones). This approach allows us to identify functions that produce valid yet under-constrained inputs, skipping all the sanitization checks performed by data-processing functions.</span><br><span class="line"> 	We then use these functions, which we call fuzzing triggers, to efficiently fuzz the analyzed IoT device, while monitoring it for anomalous behaviors, which indicate when a bug is triggered.</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204946092.png" alt="image-20210730204946092"></p>
<h2 id="Fuzzing-Trigger-Identification："><a href="#Fuzzing-Trigger-Identification：" class="headerlink" title="Fuzzing Trigger Identification："></a>Fuzzing Trigger Identification：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">We consider the first data-transforming function in the trace a valid fuzzing trigger, as it dominates every other data-transforming function (itself included).</span><br><span class="line">第一个数据转换函数为fuzzing trigger</span><br><span class="line"></span><br><span class="line">Our bottom-up Fuzzing Trigger Identification algorithm is composed of four steps: </span><br><span class="line"></span><br><span class="line">i) sendMessage Candidates Identification,</span><br><span class="line">ii) sendMessage Validation, 	</span><br><span class="line">iii) Data-Transforming Function Identification, and 	</span><br><span class="line">iv) Top-Chain Functions Collection.	</span><br></pre></td></tr></table></figure>

<p>​    i) sendMessage Candidates Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">		statically analyzing the companion app. We aim at finding all the border methods that might implement the network interactions with the analyzed IoT device (function getBorderMethods in Algorithm 1). Specifically, we collect all the methods that perform (at least) a call to native functions or a</span><br><span class="line">call to methods in the Android framework that implement network I/O functionality (see Appendix A for more details).</span><br><span class="line">		静态分析</span><br><span class="line">		候选消息发送函数（border function）：在java函数和native层之间交换的，用于发送数据的函数；或者是在安卓框架中实现了网络信息发送的函数</span><br></pre></td></tr></table></figure>

<p>​    ii) sendMessage Validation：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		First, we dynamically hook all the candidate functions and run the app. When we observe network activity, we register the last executed candidate sendMessage function. （运行APP，记录最后执行的候选消息发送函数）</span><br><span class="line">		In particular, each time a candidate sendMessage function is executed, we collect the elapsed time between its execution and the observed network activity. （记录执行的时间（从开始执行到观察到网络活动为止））</span><br><span class="line">		Then, we leverage the K-mean algorithm to cluster the observed elapsed time measures. Specifically, we group our candidates into two clusters (i.e., k=2). To do so, we compute each feature vector as the mean, standard deviation, and mode of the elapsed times of each candidate. The rationale is that functions that cause network activity have a smaller mean and standard deviation, as they are less</span><br><span class="line">affected by noise. </span><br><span class="line">		（使用K-means算法对观察到的时间进行聚类，K=2,特征为：均值、标准差和每个候选人的经过时间模式。主要是因为理想的候选人的观察时间应该有很小的均值和标准差，并且噪音对他们的影响并不大）</span><br><span class="line">		Finally, among the sendMessage candidates, we select those belonging to the cluster having the smallest mean of the elapsed times. Only the sendMessage functions within this cluster will be considered in the subsequent steps of our analysis. This approach is represented by the function dynamicFilter in Algorithm 1.</span><br></pre></td></tr></table></figure>

<p>​    iii) Data-Transforming Function Identification：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">We first statically identify the possible variables that hold the data being sent by the considered sendMessage function, and the code locations where these variables might be set in the app (function getArgAndObjLocs in Algorithm 1). </span><br><span class="line">静态分辨出sendmessage函数发送的可能的变量，并且找到设置这些变量的位置</span><br><span class="line">To achieve this, we create a set S_v containing tuples (v,cl), where v is a variable used by the sendMessage (i.e., sendMessage arguments or objects referenced within the sendMessage body), and cl is the code location where v is set.	</span><br><span class="line">创建一个集合，集合中的元素都是元组（v,cl）</span><br><span class="line"></span><br><span class="line">For each tuple (v,cl)∈S_v, we perform a static inter-procedural backward slicing (Line 6 in Algorithm 1) from cl up to any function retrieving values from any UI objects. Then, we divide the computed program slices in function scopes (getFunctionScopesat Line 7). Given a program slice, a function scope is defined as a subsequence inst_f of sequential instructions in the slice that belong to the same function f.</span><br><span class="line">对于每一个元组，我们执行一个静态的向后切片，从cl到任何函数（这个函数接受了从UI中的数据），然后将计算出的程序片段划分到函数范围中。给定一个程序切片，函数范围就是切片中属于同一函数f的连续指令的子序列</span><br><span class="line"></span><br><span class="line">For each collected function scope, we perform a liveness analysis [63]: We consider the variables (i.e., local variables and class fields) referenced within the function scope, and we compute the set Lifof variables that are live at the beginning of the scope, and the set Lo_f variables that are live at the end of the scope(Line 8).</span><br><span class="line">对于每一个函数域（FunctionScope），我们对其进行活性分析（liveness analysis）,考虑函数作用域内部应用的变量（局部变量和类的字段），并计算Li_f：在函数域开头的活跃变量集合，Lo_f:生存在函数域结束的活动变量集合</span><br><span class="line">换句话说， 𝐿𝑖_𝑓中包含的是函数𝑓中用于数据转换的所有数据（包括𝑓的参数、𝑓中在赋值前被读取过的类字段）， 𝐿𝑜_𝑓中包含的是函数𝑓生成后的数据（包括𝑓的返回值、𝑓中新建或修改过的类字段）。</span><br><span class="line"></span><br><span class="line">To identify data-transforming functions, we leverage the observation that these functions increase the entropy of the data they consume</span><br><span class="line">为了识别data-transforming function,我们利用了这些函数增加了他们消耗的数据的信息熵的这一现象（数据转换函数的输入和输出具有较大的信息熵差别）。因此先hook每个FunctionScope对应的函数，然后在执行app的过程中动态计算𝐿𝑖_𝑓和𝐿𝑜_𝑓中每个变量的信息熵，并将结果保存到对应的变量中。</span><br><span class="line"></span><br><span class="line">Finally, we inspect every collected function scope and calculate the quotient debetween the maximum entropy registered among all the variables in Lofand the minimum value of entropy registered among all the variables in Lif(Line 11). If deis greater than a certain threshold Tf(set to 2.0 in our experiments, as previous work suggested [80]), we consider the function f to be a data-transforming function (Line 12).</span><br><span class="line">对每个FunctionScope，从𝐿𝑜_𝑓中选取最大熵值，从𝐿𝑖_𝑓中选取最小熵值，二者相除得到𝑑_𝑒。这个值表示该函数的信息熵值变化情况，如果𝑑_𝑒大于一定阈值（文章中是2.0），则说明该函数进行了数据散列变化，因此将其选为Data- ransforming函数。</span><br></pre></td></tr></table></figure>

<p>​    iv) Top-Chain Functions Collection.    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">We call a sequence of data-transforming functions a transformation data chain, and we refer to the first function in the sequence with the term top-chain function. We say that a top-chain function f affects a variable v if modifying the content of f’s variables eventually affects v’s value.</span><br><span class="line">top-chain function将会影响变量v的值，如果修改了函数f的变量的内容最终会影响V的值</span><br><span class="line"> the top-chain functions that affect sendMessage variables</span><br><span class="line"> To identify top-chain functions, we build the dominance tree^2 of each data-transforming function detected at the previous step (Line 13), </span><br><span class="line">我们为每一个data transforming函数建立数据结构：支配树</span><br><span class="line">and select those data-transforming functions that are not dominated by any other data-transforming function (Line 16). Finally, we consider as fuzzing triggers the collected top-chain functions.</span><br><span class="line">Note that, if no data-transforming function dominates a sendMessage function, we consider the sendMessage as a fuzzing trigger (Line 14, 15, and 16).</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\fourth\AppData\Roaming\Typora\typora-user-images\image-20210730204917972.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Our approach executes the same app multiple times, being consistent across the different runs. Thus, ideally, we want the app to follow always the same execution paths. T o achieve this goal, we require the analyst to run the app once, while DIANE records the generated UI inputs. Then, we automatically replay the same inputs in the subsequent runs, by leveraging RERAN [40]. </span><br><span class="line">我们的APP需要执行多次，为了减少UI误差，我们首先运行APP，然后使用DIANE记录所有的UI输入，然后使用RERAN来重放</span><br></pre></td></tr></table></figure>

<p>test case generation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">• String lengths: </span><br><span class="line">	We change the length of strings in order to trigger buffer overflows and out-of-bound accesses. We</span><br><span class="line">generate random strings with different lengths.</span><br><span class="line">	改变字符串长度：产生溢出或者越界</span><br><span class="line"></span><br><span class="line">• Numerical values: </span><br><span class="line">	We change the values of integer, double or float values to cause integer overflows or out-of-bound accesses. We generate very large values, negative values, and the zero value.</span><br><span class="line"></span><br><span class="line">• Empty values:</span><br><span class="line">	We provide empty values, in the attempt to cause misinterpretation, uninitialized variable vulnerabilities, and null pointer dereferences.</span><br><span class="line">	制造空值，触发未初始化变量和空指针引用</span><br><span class="line"></span><br><span class="line">• Array lengths:</span><br><span class="line">	W e modify the content of arrays by removing or adding elements.</span><br></pre></td></tr></table></figure>

<p>Identifying Crashes</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Connection dropped. </span><br><span class="line">	Specifically, for TCP connections, we look for cases where the app sent a FIN packet and received no response (FIN + ACK), and then sent a sequence of two or more SYN packets.</span><br><span class="line">	FIN数据包无响应，且连续发送SYN数据包</span><br><span class="line">• HTTP Internal Server Error (500).</span><br><span class="line">	Instances where the app and the device communicate through HTTP , and the device returns an Internal Server Error [1] (status code 500), are considered as a signal that the device has entered in a faulty state.</span><br><span class="line">	设备500错误</span><br><span class="line">• Irregular network traffic size. </span><br><span class="line">	If the amount of data exchanged between the app and the device overcomes a threshold S_e, we save the current crash-inducing input. Our intuition is that, when a device enters a faulty state (e.g., due to a crash) it usually becomes temporarily unavailable for the app, thus drastically reducing the amount of data exchanged. In our experiments, we empirically verified that when the amount of exchanged data was less than 50% (compared to a regular run), something unusual happened to the device. For this reason, we set Seto be 50%.</span><br><span class="line">	不正常的流量：流量突然减少50%（与正常情况相比）</span><br><span class="line">• Heartbeat Monitoring. </span><br><span class="line">	While fuzzing a given device, we continuously ping it and monitor its response time. We report any crash-inducing inputs causing the response time to be above a certain threshold T_p. In our experiments, we set T_p to 10 seconds, as we empirically verified that the average response time of an IoT device falls within 1 second under normal conditions.</span><br><span class="line">	发送ping数据包，超过10s设备未响应，则出现异常</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Fuzzing/" rel="tag"># Fuzzing</a>
              <a href="/tags/paper/" rel="tag"># paper</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/05/08/PE%E8%84%B1%E5%A3%B3/" rel="prev" title="PE脱壳">
                  <i class="fa fa-chevron-left"></i> PE脱壳
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/28/xiaodiPenetration/" rel="next" title="xiaodiPenetration">
                  xiaodiPenetration <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dfault0</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
